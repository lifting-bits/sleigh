--- Ghidra/Processors/x86/data/languages/ia.sinc
+++ Ghidra/Processors/x86/data/languages/ia.sinc
@@ -9,6 +9,13 @@
 @endif
 
 define endian=little;
+@ifdef IA64
+@define INST_NEXT_PTR "RIP"
+@else
+@define INST_NEXT_PTR "EIP"
+@endif
+define pcodeop claim_eq;
+
 
 define space ram type=ram_space size=$(SIZE) default;
 define space register type=register_space size=4;
@@ -712,9 +719,19 @@
 addr32: [Base + Index*ss]				is mod=2 & r_m=4; Index & Base & ss; imm32=0 { local tmp=Base+Index*ss; export tmp; }
 addr32: [Base]							is mod=2 & r_m=4; index=4 & Base; imm32=0    { export Base; }
 @ifdef IA64
-addr32: [riprel]						is bit64=1 & mod=0 & r_m=4; index=4 & base=5; simm32 [ riprel=inst_next+simm32; ] { export *[const]:4 riprel; }
+addr32: [riprel]						is bit64=1 & mod=0 & r_m=4; index=4 & base=5; simm32 [ riprel=inst_next+simm32; ] {
+remill_please_dont_use_this_temp_name7c:$(SIZE)= riprel;
+claim_eq(remill_please_dont_use_this_temp_name7c, $(INST_NEXT_PTR)+simm32);
+ export *[const]:4 riprel;
+ 
+}
 
-Addr32_64: [eiprel]						is mod=0 & r_m=5; simm32	[ eiprel=inst_next+simm32; ] { export *[const]:8 eiprel; }
+Addr32_64: [eiprel]						is mod=0 & r_m=5; simm32	[ eiprel=inst_next+simm32; ] {
+remill_please_dont_use_this_temp_name7e:$(SIZE)= eiprel;
+claim_eq(remill_please_dont_use_this_temp_name7e, $(INST_NEXT_PTR)+simm32);
+ export *[const]:8 eiprel;
+ 
+}
 Addr32_64: [imm32]		is mod=0 & r_m=4; index=4 & base=5; imm32    { export *[const]:8 imm32; }
 Addr32_64: addr32		is addr32									 { tmp:8 = sext(addr32); export tmp; }
 	
@@ -728,7 +745,12 @@
 addr64: [Rmr64 + simm32_64]				is mod=2 & Rmr64; simm32_64                        { local tmp=Rmr64+simm32_64; export tmp; }
 addr64: [Rmr64]							is mod=1 & r_m!=4 & Rmr64; simm8=0                 { export Rmr64; }
 addr64: [Rmr64]							is mod=2 & r_m!=4 & Rmr64; simm32=0                { export Rmr64; }
-addr64: [riprel]						is mod=0 & r_m=5; simm32 [ riprel=inst_next+simm32; ] { export *[const]:8 riprel; }
+addr64: [riprel]						is mod=0 & r_m=5; simm32 [ riprel=inst_next+simm32; ] {
+remill_please_dont_use_this_temp_name87:$(SIZE)= riprel;
+claim_eq(remill_please_dont_use_this_temp_name87, $(INST_NEXT_PTR)+simm32);
+ export *[const]:8 riprel;
+ 
+}
 addr64: [Base64 + Index64*ss]			is mod=0 & r_m=4; Index64 & Base64 & ss            { local tmp=Base64+Index64*ss; export tmp; }
 addr64: [Base64]						is mod=0 & r_m=4; rexXprefix=0 & index64=4 & Base64    { export Base64; }
 addr64: [simm32_64 + Index64*ss]		is mod=0 & r_m=4; Index64 & base64=5 & ss; simm32_64   { local tmp=simm32_64+Index64*ss; export tmp; }
@@ -743,8 +765,22 @@
 addr64: [Base64 + Index64*ss]			is mod=2 & r_m=4; Index64 & Base64 & ss; imm32=0   { local tmp=Base64+Index64*ss; export tmp; }
 @endif
 
-currentCS: CS is protectedMode=0 & CS { tmp:4 = (inst_next >> 4) & 0xf000; CS = tmp:2; export CS; }
-currentCS: CS is protectedMode=1 & CS { tmp:4 = (inst_next >> 16) & 0xffff; CS = tmp:2; export CS; }
+currentCS: CS is protectedMode=0 & CS {
+remill_please_dont_use_this_temp_name94:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name94, $(INST_NEXT_PTR));
+ tmp:4 = (inst_next >> 4) & 0xf000;
+ CS = tmp:2;
+ export CS;
+ 
+}
+currentCS: CS is protectedMode=1 & CS {
+remill_please_dont_use_this_temp_name95:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name95, $(INST_NEXT_PTR));
+ tmp:4 = (inst_next >> 16) & 0xffff;
+ CS = tmp:2;
+ export CS;
+ 
+}
  
 segWide: is segover=0		        { export 0:$(SIZE); }
 segWide: CS: is segover=1 & CS	{ export 0:$(SIZE); }
@@ -785,9 +821,24 @@
 @endif
 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
 
-rel8: reloc is simm8        [ reloc=inst_next+simm8; ] { export *[ram]:$(SIZE) reloc; }
-rel16: reloc is simm16      [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] { export *[ram]:$(SIZE) reloc; }
-rel32: reloc is simm32      [ reloc=inst_next+simm32; ] { export *[ram]:$(SIZE) reloc; }
+rel8: reloc is simm8        [ reloc=inst_next+simm8; ] {
+remill_please_dont_use_this_temp_namead:$(SIZE)= reloc;
+claim_eq(remill_please_dont_use_this_temp_namead, $(INST_NEXT_PTR)+simm8);
+ export *[ram]:$(SIZE) reloc;
+ 
+}
+rel16: reloc is simm16      [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] {
+remill_please_dont_use_this_temp_nameaf:$(SIZE)= reloc;
+claim_eq(remill_please_dont_use_this_temp_nameaf, (($(INST_NEXT_PTR) >> 16) << 16) | (($(INST_NEXT_PTR) + simm16) & 0xFFFF));
+ export *[ram]:$(SIZE) reloc;
+ 
+}
+rel32: reloc is simm32      [ reloc=inst_next+simm32; ] {
+remill_please_dont_use_this_temp_nameb1:$(SIZE)= reloc;
+claim_eq(remill_please_dont_use_this_temp_nameb1, $(INST_NEXT_PTR)+simm32);
+ export *[ram]:$(SIZE) reloc;
+ 
+}
 
 
 m8:   "byte ptr" Mem   	is Mem      { export *:1 Mem; }
@@ -2079,65 +2130,273 @@
 :BTS rm64,imm8     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; (rm64 & reg_opcode=5 ...); imm8   { local bit=imm8&0x3f; local val=(rm64>>bit)&1; rm64=rm64 | (1<<bit); CF=(val!=0); }
 @endif
 
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16     { push22(&:2 inst_next); call rel16; }
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16     { push42(&:2 inst_next); call rel16; }
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16     {
+remill_please_dont_use_this_temp_name140:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name140, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call rel16;
+ 
+}
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16     {
+remill_please_dont_use_this_temp_name141:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name141, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call rel16;
+ 
+}
 @ifdef IA64
-:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; rel16     { push88(&:8 inst_next); call rel16; }
+:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; rel16     {
+remill_please_dont_use_this_temp_name142:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name142, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel16;
+ 
+}
 @endif
 
 #  When is a Call a Jump, when it jumps right after.  Not always the case but...
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push22(&:2 inst_next); goto rel16; }
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push42(&:2 inst_next); goto rel16; }
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      {
+remill_please_dont_use_this_temp_name143:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name143, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ goto rel16;
+ 
+}
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16      {
+remill_please_dont_use_this_temp_name144:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name144, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ goto rel16;
+ 
+}
 @ifdef IA64
-:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; simm16=0 & rel16      { push88(&:8 inst_next); goto rel16; }
+:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; simm16=0 & rel16      {
+remill_please_dont_use_this_temp_name145:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name145, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel16;
+ 
+}
 @endif
 
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32     { push24(&:4 inst_next); call rel32; }
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push44(&:4 inst_next); call rel32; }
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32     {
+remill_please_dont_use_this_temp_name146:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name146, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call rel32;
+ 
+}
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     {
+remill_please_dont_use_this_temp_name147:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name147, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call rel32;
+ 
+}
 @ifdef IA64
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push88(&:8 inst_next); call rel32; }
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; rel32     { push88(&:8 inst_next); call rel32; }
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     {
+remill_please_dont_use_this_temp_name148:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name148, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel32;
+ 
+}
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; rel32     {
+remill_please_dont_use_this_temp_name149:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name149, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel32;
+ 
+}
 @endif
 
 #  When is a call a Jump, when it jumps right after.  Not always the case but...
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push24(&:4 inst_next); goto rel32; }
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push44(&:4 inst_next); goto rel32; }
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32      {
+remill_please_dont_use_this_temp_name14a:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14a, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ goto rel32;
+ 
+}
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      {
+remill_please_dont_use_this_temp_name14b:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14b, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ goto rel32;
+ 
+}
 @ifdef IA64
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32     { push88(&:8 inst_next); goto rel32; }
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; simm32=0 & rel32      { push88(&:8 inst_next); goto rel32; }
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32     {
+remill_please_dont_use_this_temp_name14c:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14c, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel32;
+ 
+}
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; simm32=0 & rel32      {
+remill_please_dont_use_this_temp_name14d:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14d, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel32;
+ 
+}
 @endif
 
 :CALL rm16	    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=2 ...	{ local dest:4 = segment(currentCS,rm16); push22(&:2 inst_next); call [dest]; }
-:CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:2 = rm16; push42(&:2 inst_next); call [dest]; }
+:CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   {
+ local dest:2 = rm16;
+remill_please_dont_use_this_temp_name14e:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14e, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call [dest];
+ 
+}
 @ifdef IA64
-:CALL rm16      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:8 = inst_next + zext(rm16); push88(&:8 inst_next); call [dest]; }
+:CALL rm16      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   {
+remill_please_dont_use_this_temp_name14f:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name14f, $(INST_NEXT_PTR));
+ local dest:8 = inst_next + zext(rm16);
+claim_eq(remill_please_dont_use_this_temp_name14f, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+ 
+}
 @endif
 
-:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push24(&:4 inst_next); call [dest]; }
-:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push44(&:4 inst_next); call [dest]; }
+:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   {
+ local dest:4 = rm32;
+remill_please_dont_use_this_temp_name150:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name150, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call [dest];
+ 
+}
+:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   {
+ local dest:4 = rm32;
+remill_please_dont_use_this_temp_name151:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name151, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call [dest];
+ 
+}
 @ifdef IA64
-:CALL rm64      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & (opsize=1 | opsize=2) & byte=0xff; rm64 & reg_opcode=2 ...   { local dest:8 = rm64; push88(&:8 inst_next); call [dest]; }
+:CALL rm64      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & (opsize=1 | opsize=2) & byte=0xff; rm64 & reg_opcode=2 ...   {
+ local dest:8 = rm64;
+remill_please_dont_use_this_temp_name152:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name152, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+ 
+}
 @endif
 
 # direct far calls generate an opcode undefined exception in x86-64
-:CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; }
-:CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; }
-:CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; }
-:CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { push42(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; }
+:CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           {
+ push22(CS);
+ build ptr1616;
+remill_please_dont_use_this_temp_name153:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name153, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call ptr1616;
+ 
+}
+:CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           {
+ push42(CS);
+ build ptr1616;
+remill_please_dont_use_this_temp_name154:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name154, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call ptr1616;
+ 
+}
+:CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           {
+ push22(CS);
+ build ptr1632;
+remill_please_dont_use_this_temp_name155:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name155, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call ptr1632;
+ 
+}
+:CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           {
+ push42(CS);
+ build ptr1632;
+remill_please_dont_use_this_temp_name156:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name156, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call ptr1632;
+ 
+}
 :CALLF addr16       is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; addr16 & reg_opcode=3 ... { local ptr:$(SIZE) = segment(DS,addr16); local addrptr:$(SIZE) = segment(*:2 (ptr+2),*:2 ptr);
                                                                                                   push22(CS); push22(&:2 inst_next); call [addrptr]; }
-:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push42(&:2 inst_next); call [dest]; }
+:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ... {
+ local dest:4 = addr32;
+ push42(CS);
+remill_please_dont_use_this_temp_name157:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name157, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call [dest];
+ 
+}
 @ifdef IA64
-:CALLF addr64       is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push82(&:2 inst_next); call [dest]; }
+:CALLF addr64       is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xff; addr64 & reg_opcode=3 ... {
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name158:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name158, $(INST_NEXT_PTR));
+ push82(&:2 inst_next);
+ call [dest];
+ 
+}
 @endif
 
 
-:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ... { local dest:2 = addr16; push22(CS); push24(&:4 inst_next); call [dest]; }
-:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push44(&:4 inst_next); call [dest]; }
+:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ... {
+ local dest:2 = addr16;
+ push22(CS);
+remill_please_dont_use_this_temp_name159:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name159, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call [dest];
+ 
+}
+:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ... {
+ local dest:4 = addr32;
+ push42(CS);
+remill_please_dont_use_this_temp_name15a:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name15a, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call [dest];
+ 
+}
 @ifdef IA64
-:CALLF addr32       is $(LONGMODE_ON) &vexMode=0 & addrsize=1 & opsize=2 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push82(CS); push88(&:8 inst_next); call [dest]; }
-:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=1 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push84(&:4 inst_next); call [dest]; }
-:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=2 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push88(&:8 inst_next); call [dest]; }
+:CALLF addr32       is $(LONGMODE_ON) &vexMode=0 & addrsize=1 & opsize=2 & byte=0xff; addr32 & reg_opcode=3 ... {
+ local dest:4 = addr32;
+ push82(CS);
+remill_please_dont_use_this_temp_name15b:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name15b, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+ 
+}
+:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=1 & byte=0xff; addr64 & reg_opcode=3 ... {
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name15c:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name15c, $(INST_NEXT_PTR));
+ push84(&:4 inst_next);
+ call [dest];
+ 
+}
+:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=2 & byte=0xff; addr64 & reg_opcode=3 ... {
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name15d:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name15d, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+ 
+}
 @endif
 
 :CBW            is vexMode=0 & opsize=0 & byte=0x98                 { AX = sext(AL); }
@@ -2179,10 +2438,29 @@
 
 :CMC			is vexMode=0 & byte=0xf5						{ CF = CF==0; }
 
-:CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...    { if (!cc) goto inst_next; Reg16 = rm16; }
-:CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...   { build check_Reg32_dest; if (!cc) goto inst_next; Reg32 = rm32;}
+:CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...    {
+remill_please_dont_use_this_temp_name16f:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name16f, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg16 = rm16;
+ 
+}
+:CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...   {
+ build check_Reg32_dest;
+remill_please_dont_use_this_temp_name170:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name170, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg32 = rm32;
+
+}
 @ifdef IA64
-:CMOV^cc Reg64,rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=4 & cc; rm64 & Reg64 ...    { if (!cc) goto inst_next; Reg64 = rm64; }
+:CMOV^cc Reg64,rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=4 & cc; rm64 & Reg64 ...    {
+remill_please_dont_use_this_temp_name171:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name171, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg64 = rm64;
+ 
+}
 @endif
 
 :CMP AL,imm8        is vexMode=0 & byte=0x3c; AL & imm8                                 { subflags(   AL,imm8 ); local tmp =    AL -   imm8; resultflags(tmp); }
@@ -4075,14 +4353,62 @@
 :FCLEX          is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE2      { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; }
 :FNCLEX         is vexMode=0 & byte=0xDB; byte=0xE2                 { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; } 
 
-:FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0        { if ( !CF ) goto inst_next; ST0 = freg; }   
-:FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0        { if ( !ZF ) goto inst_next; ST0 = freg; }   
-:FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0        { if ( !CF & !ZF ) goto inst_next; ST0 = freg; } 
-:FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0        { if ( !PF ) goto inst_next; ST0 = freg; }   
-:FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0        { if ( CF ) goto inst_next; ST0 = freg; }    
-:FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0        { if ( ZF ) goto inst_next; ST0 = freg; }    
-:FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0        { if ( CF & ZF ) goto inst_next; ST0 = freg; }   
-:FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0        { if ( PF ) goto inst_next; ST0 = freg; }    
+:FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0        {
+remill_please_dont_use_this_temp_name321:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name321, $(INST_NEXT_PTR));
+ if ( !CF ) goto inst_next;
+ ST0 = freg;
+ 
+}   
+:FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0        {
+remill_please_dont_use_this_temp_name322:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name322, $(INST_NEXT_PTR));
+ if ( !ZF ) goto inst_next;
+ ST0 = freg;
+ 
+}   
+:FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0        {
+remill_please_dont_use_this_temp_name323:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name323, $(INST_NEXT_PTR));
+ if ( !CF & !ZF ) goto inst_next;
+ ST0 = freg;
+ 
+} 
+:FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0        {
+remill_please_dont_use_this_temp_name324:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name324, $(INST_NEXT_PTR));
+ if ( !PF ) goto inst_next;
+ ST0 = freg;
+ 
+}   
+:FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0        {
+remill_please_dont_use_this_temp_name325:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name325, $(INST_NEXT_PTR));
+ if ( CF ) goto inst_next;
+ ST0 = freg;
+ 
+}    
+:FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0        {
+remill_please_dont_use_this_temp_name326:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name326, $(INST_NEXT_PTR));
+ if ( ZF ) goto inst_next;
+ ST0 = freg;
+ 
+}    
+:FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0        {
+remill_please_dont_use_this_temp_name327:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name327, $(INST_NEXT_PTR));
+ if ( CF & ZF ) goto inst_next;
+ ST0 = freg;
+ 
+}   
+:FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0        {
+remill_please_dont_use_this_temp_name328:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name328, $(INST_NEXT_PTR));
+ if ( PF ) goto inst_next;
+ ST0 = freg;
+ 
+}    
                                                                  
 :FCOM spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); }         
 :FCOM spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); }         
