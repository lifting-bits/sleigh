From 9d1e7b00e8f5dca987038a78fbac400c835a78be Mon Sep 17 00:00:00 2001
From: Eric Kilmer <eric.d.kilmer@gmail.com>
Date: Mon, 12 Aug 2024 12:02:35 -0400
Subject: [PATCH 1/5] Fix UBSAN errors in decompiler

Co-authored-by: Alex Cameron <asc@tetsuo.sh>
---
 .../src/decompile/cpp/pcodecompile.cc          | 18 +++++++++++-------
 .../Decompiler/src/decompile/cpp/semantics.cc  |  2 ++
 .../Decompiler/src/decompile/cpp/semantics.hh  |  2 +-
 .../src/decompile/cpp/slgh_compile.cc          |  2 +-
 .../src/decompile/unittests/testfloatemu.cc    |  2 +-
 5 files changed, 16 insertions(+), 10 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
index ca9d71ab99..85d4dd281d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
@@ -621,8 +621,10 @@ vector<OpTpl *> *PcodeCompile::assignBitRange(VarnodeTpl *vn,uint4 bitoffset,uin
   uint4 smallsize = (numbits+7)/8; // Size of input (output of rhs)
   bool shiftneeded = (bitoffset != 0);
   bool zextneeded = true;
-  uintb mask = (uintb)2;
-  mask = ~(((mask<<(numbits-1))-1) << bitoffset);
+  uintb mask = 0;
+  const int4 masknumbits = sizeof(mask) * 8;
+  if (numbits - 1 < masknumbits && bitoffset < masknumbits)
+    mask = ~(((static_cast<uintb>(2) << (numbits - 1)) - 1) << bitoffset);
 
   if (vn->getSize().getType()==ConstTpl::real) {
     // If we know the size of the bitranged varnode, we can
@@ -726,9 +728,6 @@ ExprTree *PcodeCompile::createBitRange(SpecificSymbol *sym,uint4 bitoffset,uint4
     }
   }
 
-  uintb mask = (uintb)2;
-  mask = ((mask<<(numbits-1))-1);
-  
   if (truncneeded && ((bitoffset % 8)==0)) {
     truncshift = bitoffset/8;
     bitoffset = 0;
@@ -751,8 +750,13 @@ ExprTree *PcodeCompile::createBitRange(SpecificSymbol *sym,uint4 bitoffset,uint4
     appendOp(CPUI_INT_RIGHT,res,bitoffset,4);
   if (truncneeded)
     appendOp(CPUI_SUBPIECE,res,truncshift,4);
-  if (maskneeded)
-    appendOp(CPUI_INT_AND,res,mask,finalsize);
+  if (maskneeded) {
+    uintb mask = 0;
+    if (numbits - 1 < sizeof(mask) * 8)
+      mask = static_cast<uintb>(2) << (numbits - 1);
+    --mask;
+    appendOp(CPUI_INT_AND, res, mask, finalsize);
+  }
   force_size(res->outvn,ConstTpl(ConstTpl::real,finalsize),*res->ops);
   return res;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
index cd9b9835b1..8a4616c3b9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
@@ -22,6 +22,7 @@ ConstTpl::ConstTpl(const_type tp)
 
 {				// Constructor for relative jump constants and uniques
   type = tp;
+  select = v_space;
 }
 
 ConstTpl::ConstTpl(const_type tp,uintb val)
@@ -56,6 +57,7 @@ ConstTpl::ConstTpl(AddrSpace *sid)
 {
   type = spaceid;
   value.spaceid = sid;
+  select = v_space;
 }
 
 bool ConstTpl::isConstSpace(void) const
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
index e0b069959d..9117a45c75 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
@@ -47,7 +47,7 @@ class ConstTpl {
   uintb value_real;
   v_field select;		// Which part of handle to use as constant
 public:
-  ConstTpl(void) { type = real; value_real = 0; }
+  ConstTpl(void) { type = real; value_real = 0; select = v_space; }
   ConstTpl(const ConstTpl &op2) {
     type=op2.type; value=op2.value; value_real=op2.value_real; select=op2.select; }
   ConstTpl(const_type tp,uintb val);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index 50d85e22ba..9f3b456229 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -2164,8 +2164,8 @@ string SleighCompile::checkSymbols(SymbolScope *scope)
   ostringstream msg;
   SymbolTree::const_iterator iter;
   for(iter=scope->begin();iter!=scope->end();++iter) {
+    if ((*iter)->getType() != SleighSymbol::label_symbol) continue;
     LabelSymbol *sym = (LabelSymbol *)*iter;
-    if (sym->getType() != SleighSymbol::label_symbol) continue;
     if (sym->getRefCount() == 0)
       msg << "   Label <" << sym->getName() << "> was placed but not used" << endl;
     else if (!sym->isPlaced())
diff --git a/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc b/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
index 2571f55f1a..fe40e22b1b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
@@ -375,7 +375,7 @@ TEST(float_opTrunc_to_int) {
 
     for(float f:float_test_values) {
         // avoid undefined behavior
-        if((int64_t)f > std::numeric_limits<int>::max() || (int64_t)f < std::numeric_limits<int>::min())
+        if(f > std::numeric_limits<int>::max() || f < std::numeric_limits<int>::min() || std::isnan(f))
             continue;
         uintb true_result = ((uintb)(int32_t)f) & 0xffffffff;
         uintb encoding = format.getEncoding(f);
-- 
2.50.1

