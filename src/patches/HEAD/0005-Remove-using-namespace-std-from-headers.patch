From 4a5f05cb1bbad802c1f36ae4951dd649475fecaa Mon Sep 17 00:00:00 2001
From: Eric Kilmer <eric.d.kilmer@gmail.com>
Date: Wed, 2 Nov 2022 19:41:19 -0400
Subject: [PATCH 5/5] Remove 'using namespace std' from headers

Still uses it in source files to reduce diff and ease transition.

I did not regenerate the files because it would cause more diffs than
necessary.
---
 .../Decompiler/src/decompile/cpp/action.cc    |   2 +
 .../Decompiler/src/decompile/cpp/action.hh    | 122 ++--
 .../Decompiler/src/decompile/cpp/address.cc   |   2 +
 .../Decompiler/src/decompile/cpp/address.hh   |  24 +-
 .../src/decompile/cpp/architecture.cc         |   2 +
 .../src/decompile/cpp/architecture.hh         |  62 +-
 .../Decompiler/src/decompile/cpp/bfd_arch.cc  |   2 +
 .../Decompiler/src/decompile/cpp/bfd_arch.hh  |   6 +-
 .../Decompiler/src/decompile/cpp/block.cc     |   2 +
 .../Decompiler/src/decompile/cpp/block.hh     | 116 ++--
 .../src/decompile/cpp/blockaction.cc          |   2 +
 .../src/decompile/cpp/blockaction.hh          |  78 +--
 .../Decompiler/src/decompile/cpp/callgraph.cc |   2 +
 .../Decompiler/src/decompile/cpp/callgraph.hh |  20 +-
 .../src/decompile/cpp/capability.cc           |   2 +
 .../src/decompile/cpp/capability.hh           |   4 +-
 .../Decompiler/src/decompile/cpp/cast.cc      |   2 +
 .../Decompiler/src/decompile/cpp/codedata.cc  |   2 +
 .../Decompiler/src/decompile/cpp/codedata.hh  |  56 +-
 .../Decompiler/src/decompile/cpp/comment.cc   |   2 +
 .../Decompiler/src/decompile/cpp/comment.hh   |  28 +-
 .../src/decompile/cpp/comment_ghidra.cc       |   2 +
 .../src/decompile/cpp/comment_ghidra.hh       |   4 +-
 .../Decompiler/src/decompile/cpp/condexe.cc   |   2 +
 .../Decompiler/src/decompile/cpp/condexe.hh   |  12 +-
 .../src/decompile/cpp/consolemain.cc          |   2 +
 .../Decompiler/src/decompile/cpp/context.cc   |   2 +
 .../Decompiler/src/decompile/cpp/context.hh   |  14 +-
 .../src/decompile/cpp/coreaction.cc           |   2 +
 .../src/decompile/cpp/coreaction.hh           | 162 ++---
 .../Decompiler/src/decompile/cpp/cover.cc     |   2 +
 .../Decompiler/src/decompile/cpp/cover.hh     |  12 +-
 .../Decompiler/src/decompile/cpp/cpool.cc     |   2 +
 .../Decompiler/src/decompile/cpp/cpool.hh     |  22 +-
 .../src/decompile/cpp/cpool_ghidra.cc         |   2 +
 .../src/decompile/cpp/cpool_ghidra.hh         |   4 +-
 .../Decompiler/src/decompile/cpp/crc32.cc     |   2 +
 .../Decompiler/src/decompile/cpp/database.cc  |   2 +
 .../Decompiler/src/decompile/cpp/database.hh  | 152 ++---
 .../src/decompile/cpp/database_ghidra.cc      |   2 +
 .../src/decompile/cpp/database_ghidra.hh      |  32 +-
 .../Decompiler/src/decompile/cpp/double.cc    |   2 +
 .../Decompiler/src/decompile/cpp/double.hh    |  26 +-
 .../Decompiler/src/decompile/cpp/dynamic.cc   |   2 +
 .../Decompiler/src/decompile/cpp/dynamic.hh   |  12 +-
 .../Decompiler/src/decompile/cpp/emulate.cc   |   2 +
 .../Decompiler/src/decompile/cpp/emulate.hh   |  22 +-
 .../src/decompile/cpp/emulateutil.cc          |   2 +
 .../src/decompile/cpp/emulateutil.hh          |   8 +-
 .../Decompiler/src/decompile/cpp/error.hh     |  10 +-
 .../src/decompile/cpp/filemanage.cc           |   2 +
 .../src/decompile/cpp/filemanage.hh           |  30 +-
 .../Decompiler/src/decompile/cpp/float.cc     |   2 +
 .../Decompiler/src/decompile/cpp/float.hh     |   2 +-
 .../Decompiler/src/decompile/cpp/flow.cc      |   2 +
 .../Decompiler/src/decompile/cpp/flow.hh      |  30 +-
 .../Decompiler/src/decompile/cpp/fspec.cc     |   2 +
 .../Decompiler/src/decompile/cpp/fspec.hh     | 154 ++---
 .../Decompiler/src/decompile/cpp/funcdata.cc  |   2 +
 .../Decompiler/src/decompile/cpp/funcdata.hh  |  84 +--
 .../src/decompile/cpp/funcdata_block.cc       |   2 +
 .../src/decompile/cpp/funcdata_op.cc          |   2 +
 .../src/decompile/cpp/funcdata_varnode.cc     |   2 +
 .../src/decompile/cpp/ghidra_arch.cc          |   2 +
 .../src/decompile/cpp/ghidra_arch.hh          |  64 +-
 .../src/decompile/cpp/ghidra_context.cc       |   2 +
 .../src/decompile/cpp/ghidra_context.hh       |  10 +-
 .../src/decompile/cpp/ghidra_process.cc       |   2 +
 .../src/decompile/cpp/ghidra_process.hh       |  26 +-
 .../src/decompile/cpp/ghidra_translate.cc     |   2 +
 .../src/decompile/cpp/ghidra_translate.hh     |  14 +-
 .../src/decompile/cpp/globalcontext.cc        |   2 +
 .../src/decompile/cpp/globalcontext.hh        |  34 +-
 .../Decompiler/src/decompile/cpp/grammar.cc   |   2 +
 .../Decompiler/src/decompile/cpp/grammar.hh   | 140 ++---
 .../Decompiler/src/decompile/cpp/graph.cc     |   2 +
 .../Decompiler/src/decompile/cpp/graph.hh     |   6 +-
 .../Decompiler/src/decompile/cpp/heritage.cc  |   2 +
 .../Decompiler/src/decompile/cpp/heritage.hh  |  80 +--
 .../src/decompile/cpp/ifacedecomp.cc          |   2 +
 .../src/decompile/cpp/ifacedecomp.hh          | 238 ++++----
 .../Decompiler/src/decompile/cpp/ifaceterm.cc |   2 +
 .../Decompiler/src/decompile/cpp/ifaceterm.hh |  12 +-
 .../src/decompile/cpp/inject_ghidra.cc        |   2 +
 .../src/decompile/cpp/inject_ghidra.hh        |  28 +-
 .../src/decompile/cpp/inject_sleigh.cc        |   2 +
 .../src/decompile/cpp/inject_sleigh.hh        |  50 +-
 .../Decompiler/src/decompile/cpp/interface.cc |   2 +
 .../Decompiler/src/decompile/cpp/interface.hh | 104 ++--
 .../Decompiler/src/decompile/cpp/jumptable.cc |   2 +
 .../Decompiler/src/decompile/cpp/jumptable.hh |  74 +--
 .../Decompiler/src/decompile/cpp/libdecomp.cc |   2 +
 .../Decompiler/src/decompile/cpp/libdecomp.hh |   4 +-
 .../Decompiler/src/decompile/cpp/loadimage.cc |   2 +
 .../Decompiler/src/decompile/cpp/loadimage.hh |  22 +-
 .../src/decompile/cpp/loadimage_bfd.cc        |   2 +
 .../src/decompile/cpp/loadimage_bfd.hh        |  12 +-
 .../src/decompile/cpp/loadimage_ghidra.cc     |   2 +
 .../src/decompile/cpp/loadimage_ghidra.hh     |   2 +-
 .../src/decompile/cpp/loadimage_xml.cc        |   2 +
 .../src/decompile/cpp/loadimage_xml.hh        |  14 +-
 .../Decompiler/src/decompile/cpp/marshal.cc   |   1 +
 .../Decompiler/src/decompile/cpp/marshal.hh   |  78 ++-
 .../Decompiler/src/decompile/cpp/memstate.cc  |   2 +
 .../Decompiler/src/decompile/cpp/memstate.hh  |  12 +-
 .../Decompiler/src/decompile/cpp/merge.cc     |   2 +
 .../Decompiler/src/decompile/cpp/merge.hh     |  26 +-
 .../Decompiler/src/decompile/cpp/op.cc        |   2 +
 .../Decompiler/src/decompile/cpp/op.hh        |  56 +-
 .../src/decompile/cpp/opbehavior.cc           |   2 +
 .../src/decompile/cpp/opbehavior.hh           |   4 +-
 .../Decompiler/src/decompile/cpp/opcodes.cc   |   2 +
 .../Decompiler/src/decompile/cpp/opcodes.hh   |   4 +-
 .../Decompiler/src/decompile/cpp/options.cc   |   2 +
 .../Decompiler/src/decompile/cpp/options.hh   |  82 +--
 .../Decompiler/src/decompile/cpp/override.cc  |   2 +
 .../Decompiler/src/decompile/cpp/override.hh  |  22 +-
 .../Decompiler/src/decompile/cpp/paramid.cc   |   2 +
 .../Decompiler/src/decompile/cpp/paramid.hh   |  10 +-
 .../Decompiler/src/decompile/cpp/partmap.hh   |  11 +-
 .../src/decompile/cpp/pcodecompile.cc         |   2 +
 .../src/decompile/cpp/pcodecompile.hh         |  50 +-
 .../src/decompile/cpp/pcodeinject.cc          |   2 +
 .../src/decompile/cpp/pcodeinject.hh          |  84 +--
 .../src/decompile/cpp/pcodeparse.cc           |   2 +
 .../src/decompile/cpp/pcodeparse.hh           |  24 +-
 .../Decompiler/src/decompile/cpp/pcodeparse.y |   2 +
 .../Decompiler/src/decompile/cpp/pcoderaw.cc  |   2 +
 .../Decompiler/src/decompile/cpp/pcoderaw.hh  |   2 +-
 .../src/decompile/cpp/prefersplit.cc          |   2 +
 .../src/decompile/cpp/prefersplit.hh          |   8 +-
 .../src/decompile/cpp/prettyprint.cc          |   2 +
 .../src/decompile/cpp/prettyprint.hh          | 144 ++---
 .../Decompiler/src/decompile/cpp/printc.cc    |   2 +
 .../Decompiler/src/decompile/cpp/printc.hh    |  72 +--
 .../Decompiler/src/decompile/cpp/printjava.cc |   2 +
 .../Decompiler/src/decompile/cpp/printjava.hh |   4 +-
 .../src/decompile/cpp/printlanguage.cc        |   2 +
 .../src/decompile/cpp/printlanguage.hh        |  64 +-
 .../Decompiler/src/decompile/cpp/rangeutil.cc |   2 +
 .../Decompiler/src/decompile/cpp/rangeutil.hh |  38 +-
 .../Decompiler/src/decompile/cpp/raw_arch.cc  |   2 +
 .../Decompiler/src/decompile/cpp/raw_arch.hh  |   6 +-
 .../src/decompile/cpp/ruleaction.cc           |   2 +
 .../src/decompile/cpp/ruleaction.hh           | 564 +++++++++---------
 .../src/decompile/cpp/rulecompile.cc          |   2 +
 .../src/decompile/cpp/rulecompile.hh          |  44 +-
 .../Decompiler/src/decompile/cpp/ruleparse.y  |   2 +
 .../Decompiler/src/decompile/cpp/semantics.cc |   2 +
 .../Decompiler/src/decompile/cpp/semantics.hh |  42 +-
 .../Decompiler/src/decompile/cpp/sleigh.cc    |   2 +
 .../Decompiler/src/decompile/cpp/sleigh.hh    |  22 +-
 .../src/decompile/cpp/sleigh_arch.cc          |   2 +
 .../src/decompile/cpp/sleigh_arch.hh          |  82 +--
 .../src/decompile/cpp/sleighbase.cc           |   2 +
 .../src/decompile/cpp/sleighbase.hh           |  32 +-
 .../src/decompile/cpp/sleighexample.cc        |   2 +
 .../src/decompile/cpp/slgh_compile.cc         |   2 +
 .../src/decompile/cpp/slgh_compile.hh         | 144 ++---
 .../Decompiler/src/decompile/cpp/slghparse.cc |   2 +
 .../Decompiler/src/decompile/cpp/slghparse.hh |  14 +-
 .../Decompiler/src/decompile/cpp/slghparse.y  |   2 +
 .../src/decompile/cpp/slghpatexpress.cc       |   2 +
 .../src/decompile/cpp/slghpatexpress.hh       | 158 ++---
 .../src/decompile/cpp/slghpattern.cc          |   2 +
 .../src/decompile/cpp/slghpattern.hh          |  22 +-
 .../Decompiler/src/decompile/cpp/slghscan.cc  |   3 +
 .../Decompiler/src/decompile/cpp/slghscan.l   |   3 +
 .../src/decompile/cpp/slghsymbol.cc           |   2 +
 .../src/decompile/cpp/slghsymbol.hh           | 236 ++++----
 .../Decompiler/src/decompile/cpp/space.cc     |   2 +
 .../Decompiler/src/decompile/cpp/space.hh     |  44 +-
 .../src/decompile/cpp/string_ghidra.cc        |   2 +
 .../src/decompile/cpp/string_ghidra.hh        |   2 +-
 .../src/decompile/cpp/stringmanage.cc         |   2 +
 .../src/decompile/cpp/stringmanage.hh         |  12 +-
 .../Decompiler/src/decompile/cpp/subflow.cc   |   2 +
 .../Decompiler/src/decompile/cpp/subflow.hh   |  18 +-
 .../Decompiler/src/decompile/cpp/test.cc      |   2 +
 .../src/decompile/cpp/testfunction.cc         |   2 +
 .../src/decompile/cpp/testfunction.hh         |  34 +-
 .../Decompiler/src/decompile/cpp/transform.cc |   2 +
 .../Decompiler/src/decompile/cpp/transform.hh |  16 +-
 .../Decompiler/src/decompile/cpp/translate.cc |   2 +
 .../Decompiler/src/decompile/cpp/translate.hh |  46 +-
 .../Decompiler/src/decompile/cpp/type.cc      |   2 +
 .../Decompiler/src/decompile/cpp/type.hh      | 126 ++--
 .../src/decompile/cpp/typegrp_ghidra.cc       |   2 +
 .../src/decompile/cpp/typegrp_ghidra.hh       |   2 +-
 .../Decompiler/src/decompile/cpp/typeop.cc    |   2 +
 .../Decompiler/src/decompile/cpp/typeop.hh    |  82 +--
 .../Decompiler/src/decompile/cpp/unify.cc     |   2 +
 .../Decompiler/src/decompile/cpp/unify.hh     | 188 +++---
 .../src/decompile/cpp/unionresolve.cc         |   2 +
 .../src/decompile/cpp/unionresolve.hh         |  10 +-
 .../Decompiler/src/decompile/cpp/userop.cc    |   2 +
 .../Decompiler/src/decompile/cpp/userop.hh    |  48 +-
 .../Decompiler/src/decompile/cpp/variable.cc  |   2 +
 .../Decompiler/src/decompile/cpp/variable.hh  |   8 +-
 .../Decompiler/src/decompile/cpp/varmap.cc    |   2 +
 .../Decompiler/src/decompile/cpp/varmap.hh    |  38 +-
 .../Decompiler/src/decompile/cpp/varnode.cc   |   2 +
 .../Decompiler/src/decompile/cpp/varnode.hh   |  22 +-
 .../Decompiler/src/decompile/cpp/xml.cc       |   2 +
 .../Decompiler/src/decompile/cpp/xml.hh       | 148 +++--
 .../Decompiler/src/decompile/cpp/xml.y        |   2 +
 .../Decompiler/src/decompile/cpp/xml_arch.cc  |   2 +
 .../Decompiler/src/decompile/cpp/xml_arch.hh  |   6 +-
 .../decompile/unittests/testcirclerange.cc    |   2 +
 .../src/decompile/unittests/testfloatemu.cc   |   2 +
 .../src/decompile/unittests/testmarshal.cc    |   2 +
 .../src/decompile/unittests/testtypes.cc      |   2 +
 212 files changed, 2848 insertions(+), 2634 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
index 7b1b2062a..76fc27d72 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
@@ -18,6 +18,8 @@
 
 #include "coreaction.hh"
 
+using namespace std;
+
 /// Specify the name, group, and properties of the Action
 /// \param f is the collection of property flags
 /// \param nm is the Action name
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh
index 645c81119..c9369c025 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh
@@ -28,13 +28,13 @@
 /// together form a \b root Action.
 class ActionGroupList {
   friend class ActionDatabase;
-  set<string> list;		///< List of group names
+  std::set<std::string> list;		///< List of group names
 public:
   /// \brief Check if \b this ActionGroupList contains a given group
   ///
   /// \param nm is the given group to check for
   /// \return true if \b this contains the group
-  bool contains(const string &nm) const { return (list.find(nm)!=list.end()); }
+  bool contains(const std::string &nm) const { return (list.find(nm)!=list.end()); }
 };
 
 class Rule;
@@ -82,29 +82,29 @@ class Action {
   uint4 flags;			///< Behavior properties
   uint4 count_tests;		///< Number of times apply() has been called
   uint4 count_apply;		///< Number of times apply() made changes
-  string name;			///< Name of the action
-  string basegroup;		///< Base group this action belongs to
+  std::string name;			///< Name of the action
+  std::string basegroup;		///< Base group this action belongs to
   void issueWarning(Architecture *glb);	///< Warn that this Action has applied
   bool checkStartBreak(void);	///< Check start breakpoint
   bool checkActionBreak(void);	///< Check action breakpoint
   void turnOnWarnings(void) { flags |= rule_warnings_on; }	///< Enable warnings for this Action
   void turnOffWarnings(void) { flags &= ~rule_warnings_on; }	///< Disable warnings for this Action
 public:
-  Action(uint4 f,const string &nm,const string &g);		///< Base constructor for an Action
+  Action(uint4 f,const std::string &nm,const std::string &g);		///< Base constructor for an Action
   virtual ~Action(void) {}					///< Destructor
 #ifdef OPACTION_DEBUG
-  virtual bool turnOnDebug(const string &nm);			///< Turn on debugging
-  virtual bool turnOffDebug(const string &nm);			///< Turn off debugging
+  virtual bool turnOnDebug(const std::string &nm);			///< Turn on debugging
+  virtual bool turnOffDebug(const std::string &nm);			///< Turn off debugging
 #endif
-  virtual void printStatistics(ostream &s) const;		///< Dump statistics to stream
+  virtual void printStatistics(std::ostream &s) const;		///< Dump statistics to stream
   int4 perform(Funcdata &data); 				///< Perform this action (if necessary)
-  bool setBreakPoint(uint4 tp,const string &specify);		///< Set a breakpoint on this action
+  bool setBreakPoint(uint4 tp,const std::string &specify);		///< Set a breakpoint on this action
   virtual void clearBreakPoints(void);				///< Clear all breakpoints set on \b this Action
-  bool setWarning(bool val,const string &specify);		///< Set a warning on this action
-  bool disableRule(const string &specify);			///< Disable a specific Rule within \b this
-  bool enableRule(const string &specify);			///< Enable a specific Rule within \b this
-  const string &getName(void) const { return name; }		///< Get the Action's name
-  const string &getGroup(void) const { return basegroup; }	///< Get the Action's group
+  bool setWarning(bool val,const std::string &specify);		///< Set a warning on this action
+  bool disableRule(const std::string &specify);			///< Disable a specific Rule within \b this
+  bool enableRule(const std::string &specify);			///< Enable a specific Rule within \b this
+  const std::string &getName(void) const { return name; }		///< Get the Action's name
+  const std::string &getGroup(void) const { return basegroup; }	///< Get the Action's group
   uint4 getStatus(void) const { return status; }		///< Get the current status of \b this Action
   uint4 getNumTests(void) { return count_tests; }		///< Get the number of times apply() was invoked
   uint4 getNumApply(void) { return count_apply; }		///< Get the number of times apply() made changes
@@ -126,10 +126,10 @@ class Action {
   /// \param data is the function to inspect/modify
   /// \return 0 for a complete application, -1 for a partial completion (due to breakpoint)
   virtual int4 apply(Funcdata &data)=0;
-  virtual int4 print(ostream &s,int4 num,int4 depth) const;	///< Print a description of this Action to stream
-  virtual void printState(ostream &s) const;			///< Print status to stream
-  virtual Action *getSubAction(const string &specify);		///< Retrieve a specific sub-action by name
-  virtual Rule *getSubRule(const string &specify);		///< Retrieve a specific sub-rule by name
+  virtual int4 print(std::ostream &s,int4 num,int4 depth) const;	///< Print a description of this Action to stream
+  virtual void printState(std::ostream &s) const;			///< Print status to stream
+  virtual Action *getSubAction(const std::string &specify);		///< Retrieve a specific sub-action by name
+  virtual Rule *getSubRule(const std::string &specify);		///< Retrieve a specific sub-rule by name
 };
 
 /// \brief A group of actions (generally) applied in sequence
@@ -140,10 +140,10 @@ class Action {
 /// that also affect how the Actions are applied.
 class ActionGroup : public Action {
 protected:
-  vector<Action *> list;				///< List of actions to perform in the group
-  vector<Action *>::iterator state;			///< Current action being applied
+  std::vector<Action *> list;				///< List of actions to perform in the group
+  std::vector<Action *>::iterator state;			///< Current action being applied
 public:
-  ActionGroup(uint4 f,const string &nm) : Action(f,nm,"") {}	///< Construct given properties and a name
+  ActionGroup(uint4 f,const std::string &nm) : Action(f,nm,"") {}	///< Construct given properties and a name
   virtual ~ActionGroup(void);				///< Destructor
   void addAction(Action *ac);				///< Add an Action to the group
   virtual void clearBreakPoints(void);
@@ -151,15 +151,15 @@ class ActionGroup : public Action {
   virtual void reset(Funcdata &data);
   virtual void resetStats(void);
   virtual int4 apply(Funcdata &data);
-  virtual int4 print(ostream &s,int4 num,int4 depth) const;
-  virtual void printState(ostream &s) const;
-  virtual Action *getSubAction(const string &specify);
-  virtual Rule *getSubRule(const string &specify);
+  virtual int4 print(std::ostream &s,int4 num,int4 depth) const;
+  virtual void printState(std::ostream &s) const;
+  virtual Action *getSubAction(const std::string &specify);
+  virtual Rule *getSubRule(const std::string &specify);
 #ifdef OPACTION_DEBUG
-  virtual bool turnOnDebug(const string &nm);
-  virtual bool turnOffDebug(const string &nm);
+  virtual bool turnOnDebug(const std::string &nm);
+  virtual bool turnOffDebug(const std::string &nm);
 #endif
-  virtual void printStatistics(ostream &s) const;
+  virtual void printStatistics(std::ostream &s) const;
 };
 
 /// \brief Action which checks if restart (sub)actions have been generated
@@ -172,7 +172,7 @@ class ActionRestartGroup : public ActionGroup {
   int4 maxrestarts;			///< Maximum number of restarts allowed
   int4 curstart;			///< Current restart iteration
 public:
-  ActionRestartGroup(uint4 f,const string &nm,int4 max) :
+  ActionRestartGroup(uint4 f,const std::string &nm,int4 max) :
     ActionGroup(f,nm) { maxrestarts = max; }	///< Construct this providing maximum number of restarts
   virtual Action *clone(const ActionGroupList &grouplist) const;
   virtual void reset(Funcdata &data);
@@ -202,16 +202,16 @@ class Rule {
   friend class ActionPool;
   uint4 flags;			///< Properties enabled with \b this Rule
   uint4 breakpoint;		///< Breakpoint(s) enabled for \b this Rule
-  string name;			///< Name of the Rule
-  string basegroup;		///< Group to which \b this Rule belongs
+  std::string name;			///< Name of the Rule
+  std::string basegroup;		///< Group to which \b this Rule belongs
   uint4 count_tests;		///< Number of times \b this Rule has attempted to apply
   uint4 count_apply;		///< Number of times \b this Rule has successfully been applied
   void issueWarning(Architecture *glb);	///< If enabled, print a warning that this Rule has been applied
 public:
-  Rule(const string &g,uint4 fl,const string &nm);		///< Construct given group, properties name
+  Rule(const std::string &g,uint4 fl,const std::string &nm);		///< Construct given group, properties name
   virtual ~Rule(void) {}					///< Destructor
-  const string &getName(void) const { return name; }		///< Return the name of \b this Rule
-  const string &getGroup(void) const { return basegroup; }	///< Return the group \b this Rule belongs to
+  const std::string &getName(void) const { return name; }		///< Return the name of \b this Rule
+  const std::string &getGroup(void) const { return basegroup; }	///< Return the group \b this Rule belongs to
   uint4 getNumTests(void) { return count_tests; }		///< Get number of attempted applications
   uint4 getNumApply(void) { return count_apply; }		///< Get number of successful applications
   void setBreak(uint4 tp) { breakpoint |= tp; }			///< Set a breakpoint on \b this Rule
@@ -232,7 +232,7 @@ class Rule {
   /// \param grouplist is the list of groups being cloned
   /// \return the cloned Rule or NULL
   virtual Rule *clone(const ActionGroupList &grouplist) const=0;
-  virtual void getOpList(vector<uint4> &oplist) const;		///< List of op codes this rule operates on
+  virtual void getOpList(std::vector<uint4> &oplist) const;		///< List of op codes this rule operates on
 
   /// \brief Attempt to apply \b this Rule
   ///
@@ -244,10 +244,10 @@ class Rule {
   virtual int4 applyOp(PcodeOp *op,Funcdata &data) { return 0; }
   virtual void reset(Funcdata &data);				///< Reset \b this Rule
   virtual void resetStats(void);				///< Reset Rule statistics
-  virtual void printStatistics(ostream &s) const;		///< Print statistics for \b this Rule
+  virtual void printStatistics(std::ostream &s) const;		///< Print statistics for \b this Rule
 #ifdef OPACTION_DEBUG
-  virtual bool turnOnDebug(const string &nm);			///< Turn on debugging
-  virtual bool turnOffDebug(const string &nm);			///< Turn off debugging
+  virtual bool turnOnDebug(const std::string &nm);			///< Turn on debugging
+  virtual bool turnOffDebug(const std::string &nm);			///< Turn off debugging
 #endif
 };
 
@@ -258,13 +258,13 @@ class Rule {
 /// Usually rule_repeatapply is enabled for this action, which causes
 /// all Rules to apply repeatedly until no Rule can make an additional change.
 class ActionPool : public Action {
-  vector<Rule *> allrules;				///< The set of Rules in this ActionPool
-  vector<Rule *> perop[CPUI_MAX];			///< Rules associated with each OpCode
+  std::vector<Rule *> allrules;				///< The set of Rules in this ActionPool
+  std::vector<Rule *> perop[CPUI_MAX];			///< Rules associated with each OpCode
   PcodeOpTree::const_iterator op_state; 		///< Current PcodeOp up for rule application
   int4 rule_index;					///< Iterator over Rules for one OpCode
   int4 processOp(PcodeOp *op,Funcdata &data);		///< Apply the next possible Rule to a PcodeOp
 public:
-  ActionPool(uint4 f,const string &nm) : Action(f,nm,"") {}	///< Construct providing properties and name
+  ActionPool(uint4 f,const std::string &nm) : Action(f,nm,"") {}	///< Construct providing properties and name
   virtual ~ActionPool(void);				///< Destructor
   void addRule(Rule *rl);				///< Add a Rule to the pool
   virtual void clearBreakPoints(void);
@@ -272,13 +272,13 @@ class ActionPool : public Action {
   virtual void reset(Funcdata &data);
   virtual void resetStats(void);
   virtual int4 apply(Funcdata &data);
-  virtual int4 print(ostream &s,int4 num,int4 depth) const;
-  virtual void printState(ostream &s) const;
-  virtual Rule *getSubRule(const string &specify);
-  virtual void printStatistics(ostream &s) const;
+  virtual int4 print(std::ostream &s,int4 num,int4 depth) const;
+  virtual void printState(std::ostream &s) const;
+  virtual Rule *getSubRule(const std::string &specify);
+  virtual void printStatistics(std::ostream &s) const;
 #ifdef OPACTION_DEBUG
-  virtual bool turnOnDebug(const string &nm);
-  virtual bool turnOffDebug(const string &nm);
+  virtual bool turnOnDebug(const std::string &nm);
+  virtual bool turnOffDebug(const std::string &nm);
 #endif
 };
 
@@ -295,29 +295,29 @@ class ActionPool : public Action {
 /// the \e current root Action, which is the one that will be actively applied to functions.
 class ActionDatabase {
   Action *currentact;				///< This is the current root Action
-  string currentactname;			///< The name associated with the current root Action
-  map<string,ActionGroupList> groupmap;		///< Map from root Action name to the grouplist it uses
-  map<string,Action *> actionmap;		///< Map from name to root Action
+  std::string currentactname;			///< The name associated with the current root Action
+  std::map<std::string,ActionGroupList> groupmap;		///< Map from root Action name to the grouplist it uses
+  std::map<std::string,Action *> actionmap;		///< Map from name to root Action
   bool isDefaultGroups;				///< \b true if only the default groups are set
   static const char universalname[];		///< The name of the \e universal root Action
-  void registerAction(const string &nm,Action *act);	///< Register a \e root Action
+  void registerAction(const std::string &nm,Action *act);	///< Register a \e root Action
   void buildDefaultGroups(void);		///< Set up descriptions of preconfigured root Actions
-  Action *getAction(const string &nm) const;				///< Look up a \e root Action by name
-  Action *deriveAction(const string &baseaction,const string &grp);	///< Derive a \e root Action
+  Action *getAction(const std::string &nm) const;				///< Look up a \e root Action by name
+  Action *deriveAction(const std::string &baseaction,const std::string &grp);	///< Derive a \e root Action
 public:
   ActionDatabase(void) { currentact = (Action *)0; isDefaultGroups = false; }	///< Constructor
   ~ActionDatabase(void);				///< Destructor
   void resetDefaults(void);			///< (Re)set the default configuration
   Action *getCurrent(void) const { return currentact; }	///< Get the current \e root Action
-  const string &getCurrentName(void) const { return currentactname; }	///< Get the name of the current \e root Action
-  const ActionGroupList &getGroup(const string &grp) const;	///< Get a specific grouplist by name
-  Action *setCurrent(const string &actname);		///< Set the current \e root Action
-  Action *toggleAction(const string &grp,const string &basegrp,bool val);	///< Toggle a group of Actions with a \e root Action
+  const std::string &getCurrentName(void) const { return currentactname; }	///< Get the name of the current \e root Action
+  const ActionGroupList &getGroup(const std::string &grp) const;	///< Get a specific grouplist by name
+  Action *setCurrent(const std::string &actname);		///< Set the current \e root Action
+  Action *toggleAction(const std::string &grp,const std::string &basegrp,bool val);	///< Toggle a group of Actions with a \e root Action
 
-  void setGroup(const string &grp,const char **argv);			///< Establish a new \e root Action
-  void cloneGroup(const string &oldname,const string &newname);		///< Clone a \e root Action
-  bool addToGroup(const string &grp,const string &basegroup);		///< Add a group to a \e root Action
-  bool removeFromGroup(const string &grp,const string &basegroup);	///< Remove a group from a \e root Action
+  void setGroup(const std::string &grp,const char **argv);			///< Establish a new \e root Action
+  void cloneGroup(const std::string &oldname,const std::string &newname);		///< Clone a \e root Action
+  bool addToGroup(const std::string &grp,const std::string &basegroup);		///< Add a group to a \e root Action
+  bool removeFromGroup(const std::string &grp,const std::string &basegroup);	///< Remove a group from a \e root Action
   void universalAction(Architecture *glb);		///< Build the universal action
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
index 0b3bf04c8..9a58ea4ef 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
@@ -16,6 +16,8 @@
 #include "address.hh"
 #include "translate.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_FIRST = AttributeId("first",27);
 AttributeId ATTRIB_LAST = AttributeId("last",28);
 AttributeId ATTRIB_UNIQ = AttributeId("uniq",29);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/address.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/address.hh
index ace26f175..084a78b1b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/address.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/address.hh
@@ -72,8 +72,8 @@ class Address {
   bool isInvalid(void) const;  ///< Is the address invalid?
   int4 getAddrSize(void) const; ///< Get the number of bytes in the address
   bool isBigEndian(void) const;	///< Is data at this address big endian encoded
-  void printRaw(ostream &s) const; ///< Write a raw version of the address to a stream
-  int4 read(const string &s); ///< Read in the address from a string
+  void printRaw(std::ostream &s) const; ///< Write a raw version of the address to a stream
+  int4 read(const std::string &s); ///< Read in the address from a string
   AddrSpace *getSpace(void) const; ///< Get the address space
   uintb getOffset(void) const;  ///< Get the address offset
   char getShortcut(void) const;	///< Get the shortcut character for the address space
@@ -84,7 +84,7 @@ class Address {
   bool operator<=(const Address &op2) const; ///< Compare two addresses via their natural ordering
   Address operator+(int4 off) const; ///< Increment address by a number of bytes
   Address operator-(int4 off) const; ///< Decrement address by a number of bytes
-  friend ostream &operator<<(ostream &s,const Address &addr);  ///< Write out an address to stream
+  friend std::ostream &operator<<(std::ostream &s,const Address &addr);  ///< Write out an address to stream
   bool containedBy(int4 sz,const Address &op2,int4 sz2) const;	///< Determine if \e op2 range contains \b this range
   int4 justifiedContain(int4 sz,const Address &op2,int4 sz2,bool forceleft) const; ///< Determine if \e op2 is the least significant part of \e this.
   int4 overlap(int4 skip,const Address &op,int4 size) const; ///< Determine how two address ranges overlap
@@ -161,7 +161,7 @@ class SeqNum {
   static SeqNum decode(Decoder &decoder);
 
   /// Write out a SeqNum in human readable form to a stream
-  friend ostream &operator<<(ostream &s,const SeqNum &sq);
+  friend std::ostream &operator<<(std::ostream &s,const SeqNum &sq);
 };
 
 class RangeProperties;
@@ -200,7 +200,7 @@ class Range {
     if (spc->getIndex() != op2.spc->getIndex())
       return (spc->getIndex() < op2.spc->getIndex());
     return (first < op2.first); }
-  void printBounds(ostream &s) const;			///< Print \b this Range to a stream
+  void printBounds(std::ostream &s) const;			///< Print \b this Range to a stream
   void encode(Encoder &encoder) const;			///< Encode \b this Range to a stream
   void decode(Decoder &decoder);			///< Restore \b this from a stream
   void decodeFromAttributes(Decoder &decoder);		///< Read \b from attributes on another tag
@@ -211,7 +211,7 @@ class Range {
 /// Class that allows \<range> tags to be parsed, when the address space doesn't yet exist
 class RangeProperties {
   friend class Range;
-  string spaceName;		///< Name of the address space containing the range
+  std::string spaceName;		///< Name of the address space containing the range
   uintb first;			///< Offset of first byte in the Range
   uintb last;			///< Offset of last byte in the Range
   bool isRegister;		///< Range is specified a  register name
@@ -227,14 +227,14 @@ class RangeProperties {
 /// that cover all the addresses in the container.  Ranges can be inserted
 /// and removed, but overlapping/adjacent ranges will get merged.
 class RangeList {
-  set<Range> tree;			///< The sorted list of Range objects
+  std::set<Range> tree;			///< The sorted list of Range objects
 public:
   RangeList(const RangeList &op2) { tree = op2.tree; }		///< Copy constructor
   RangeList(void) {}						///< Construct an empty container
   void clear(void) { tree.clear(); }				///< Clear \b this container to empty
   bool empty(void) const { return tree.empty(); }		///< Return \b true if \b this is empty
-  set<Range>::const_iterator begin(void) const { return tree.begin(); }	///< Get iterator to beginning Range
-  set<Range>::const_iterator end(void) const { return tree.end(); }	///< Get iterator to ending Range
+  std::set<Range>::const_iterator begin(void) const { return tree.begin(); }	///< Get iterator to beginning Range
+  std::set<Range>::const_iterator end(void) const { return tree.end(); }	///< Get iterator to ending Range
   int4 numRanges(void) const { return tree.size(); }		///< Return the number of Range objects in container
   const Range *getFirstRange(void) const;			///< Get the first Range
   const Range *getLastRange(void) const;			///< Get the last Range
@@ -245,7 +245,7 @@ class RangeList {
   void merge(const RangeList &op2);				///< Merge another RangeList into \b this
   bool inRange(const Address &addr,int4 size) const;		///< Check containment an address range
   uintb longestFit(const Address &addr,uintb maxsize) const;	///< Find size of biggest Range containing given address
-  void printBounds(ostream &s) const;				///< Print a description of \b this RangeList to stream
+  void printBounds(std::ostream &s) const;				///< Print a description of \b this RangeList to stream
   void encode(Encoder &encoder) const;				///< Encode \b this RangeList to a stream
   void decode(Decoder &decoder);				///< Decode \b this RangeList from a \<rangelist> element
 };
@@ -299,7 +299,7 @@ inline bool Address::isBigEndian(void) const {
 /// Write a short-hand or debug version of this address to a
 /// stream.
 /// \param s is the stream being written
-inline void Address::printRaw(ostream &s) const {
+inline void Address::printRaw(std::ostream &s) const {
   if (base == (AddrSpace *)0) {
     s << "invalid_addr";
     return;
@@ -311,7 +311,7 @@ inline void Address::printRaw(ostream &s) const {
 /// tailored for the particular address space.
 /// \param s is the string to parse
 /// \return any size associated with the parsed string
-inline int4 Address::read(const string &s) {
+inline int4 Address::read(const std::string &s) {
   int4 sz; offset=base->read(s,sz); return sz;
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
index cb96bbbbc..18b379314 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.cc
@@ -24,6 +24,8 @@
 #include <cmath>
 #endif
 
+using namespace std;
+
 vector<ArchitectureCapability *> ArchitectureCapability::thelist;
 
 const uint4 ArchitectureCapability::majorversion = 5;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.hh
index 300721274..638445c03 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/architecture.hh
@@ -54,7 +54,7 @@ class Statistics {
   ~Statistics(void);		///< Destructor
   void countCast(void) { castcount += 1; }	///< Count a single cast
   void process(const Funcdata &fd);	///< Accumulate statistics for one function
-  void printResults(ostream &s);	///< Display accumulated statistics
+  void printResults(std::ostream &s);	///< Display accumulated statistics
 };
 
 #endif
@@ -114,11 +114,11 @@ extern ElementId ELEM_VOLATILE;			///< Marshaling element \<volatile>
 class ArchitectureCapability : public CapabilityPoint {
   static const uint4 majorversion;			///< Current major version of decompiler
   static const uint4 minorversion;			///< Current minor version of decompiler
-  static vector<ArchitectureCapability *> thelist;	///< The list of registered extensions
+  static std::vector<ArchitectureCapability *> thelist;	///< The list of registered extensions
 protected:
-  string name;						///< Identifier for this capability
+  std::string name;						///< Identifier for this capability
 public:
-  const string &getName(void) const { return name; }	///< Get the capability identifier
+  const std::string &getName(void) const { return name; }	///< Get the capability identifier
   virtual void initialize(void);			///< Do specialized initialization
 
   /// \brief Build an Architecture given a raw file or data
@@ -129,13 +129,13 @@ class ArchitectureCapability : public CapabilityPoint {
   /// \param filename is the path to the executable file to examine
   /// \param target if non-empty is a language id string
   /// \param estream is an output stream for error messages
-  virtual Architecture *buildArchitecture(const string &filename,const string &target,ostream *estream)=0;
+  virtual Architecture *buildArchitecture(const std::string &filename,const std::string &target,std::ostream *estream)=0;
 
   /// \brief Determine if this extension can handle this file
   ///
   /// \param filename is the name of the file to examine
   /// \return \b true is \b this extension is suitable for analyzing the file
-  virtual bool isFileMatch(const string &filename) const=0;
+  virtual bool isFileMatch(const std::string &filename) const=0;
 
   /// \brief Determine is this extension can handle this XML document
   ///
@@ -145,9 +145,9 @@ class ArchitectureCapability : public CapabilityPoint {
   /// \return \b true if \b this extension understands the XML
   virtual bool isXmlMatch(Document *doc) const=0;
 
-  static ArchitectureCapability *findCapability(const string &filename);	///< Find an extension to process a file
+  static ArchitectureCapability *findCapability(const std::string &filename);	///< Find an extension to process a file
   static ArchitectureCapability *findCapability(Document *doc);		///< Find an extension to process an XML document
-  static ArchitectureCapability *getCapability(const string &name);	///< Get a capability by name
+  static ArchitectureCapability *getCapability(const std::string &name);	///< Get a capability by name
   static void sortCapabilities(void);					///< Sort extensions
   static uint4 getMajorVersion(void) { return majorversion; }		///< Get \e major decompiler version
   static uint4 getMinorVersion(void) { return minorversion; }		///< Get \e minor decompiler version
@@ -161,7 +161,7 @@ class ArchitectureCapability : public CapabilityPoint {
 /// This class also holds numerous configuration parameters for the analysis process
 class Architecture : public AddrSpaceManager {
 public:
-  string archid;		///< ID string uniquely describing this architecture
+  std::string archid;		///< ID string uniquely describing this architecture
 
 				// Configuration data
   int4 trim_recurse_max;	///< How many levels to let parameter trims recurse
@@ -173,16 +173,16 @@ class Architecture : public AddrSpaceManager {
   bool readonlypropagate;	///< true if readonly values should be treated as constants
   bool infer_pointers;		///< True if we should infer pointers from constants that are likely addresses
   bool analyze_for_loops;	///< True if we should attempt conversion of \e whiledo loops to \e for loops
-  vector<AddrSpace *> inferPtrSpaces;	///< Set of address spaces in which a pointer constant is inferable
+  std::vector<AddrSpace *> inferPtrSpaces;	///< Set of address spaces in which a pointer constant is inferable
   int4 funcptr_align;		///< How many bits of alignment a function ptr has
   uint4 flowoptions;            ///< options passed to flow following engine
   uint4 max_instructions;	///< Maximum instructions that can be processed in one function
   int4 alias_block_level;	///< Aliases blocked by 0=none, 1=struct, 2=array, 3=all
-  vector<Rule *> extra_pool_rules; ///< Extra rules that go in the main pool (cpu specific, experimental)
+  std::vector<Rule *> extra_pool_rules; ///< Extra rules that go in the main pool (cpu specific, experimental)
 
   Database *symboltab;		///< Memory map of global variables and functions
   ContextDatabase *context;	///< Map from addresses to context settings
-  map<string,ProtoModel *> protoModels; ///< Parsed forms of possible prototypes
+  std::map<std::string,ProtoModel *> protoModels; ///< Parsed forms of possible prototypes
   ProtoModel *defaultfp;	///< Parsed form of default prototype
   VarnodeData defaultReturnAddr;	///< Default storage location of return address (for current function)
   ProtoModel *evalfp_current;	///< Function proto to use when evaluating current function
@@ -196,58 +196,58 @@ class Architecture : public AddrSpaceManager {
   StringManager *stringManager;	///< Manager of decoded strings
   ConstantPool *cpool;		///< Deferred constant values
   PrintLanguage *print;	        ///< Current high-level language printer
-  vector<PrintLanguage *> printlist;	///< List of high-level language printers supported
+  std::vector<PrintLanguage *> printlist;	///< List of high-level language printers supported
   OptionDatabase *options;	///< Options that can be configured
-  vector<TypeOp *> inst;	///< Registered p-code instructions
+  std::vector<TypeOp *> inst;	///< Registered p-code instructions
   UserOpManage userops;		///< Specifically registered user-defined p-code ops
-  vector<PreferSplitRecord> splitrecords; ///< registers that we would prefer to see split for this processor
-  vector<LanedRegister> lanerecords;	///< Vector registers that have preferred lane sizes
+  std::vector<PreferSplitRecord> splitrecords; ///< registers that we would prefer to see split for this processor
+  std::vector<LanedRegister> lanerecords;	///< Vector registers that have preferred lane sizes
   ActionDatabase allacts;	///< Actions that can be applied in this architecture
   bool loadersymbols_parsed;	///< True if loader symbols have been read
 #ifdef CPUI_STATISTICS
   Statistics *stats;		///< Statistics collector
 #endif
 #ifdef OPACTION_DEBUG
-  ostream *debugstream;		///< The error console
+  std::ostream *debugstream;		///< The error console
 #endif
   Architecture(void);		///< Construct an uninitialized Architecture
   void init(DocumentStorage &store); ///< Load the image and configure architecture
   void resetDefaultsInternal(void);	///< Reset default values for options specific to Architecture
   void resetDefaults(void);		///< Reset defaults values for options owned by \b this
-  ProtoModel *getModel(const string &nm) const;		///< Get a specific PrototypeModel
-  bool hasModel(const string &nm) const;		///< Does this Architecture have a specific PrototypeModel
-  ProtoModel *createUnknownModel(const string &modelName);	///< Create a model for an unrecognized name
+  ProtoModel *getModel(const std::string &nm) const;		///< Get a specific PrototypeModel
+  bool hasModel(const std::string &nm) const;		///< Does this Architecture have a specific PrototypeModel
+  ProtoModel *createUnknownModel(const std::string &modelName);	///< Create a model for an unrecognized name
   bool highPtrPossible(const Address &loc,int4 size) const; ///< Are pointers possible to the given location?
   AddrSpace *getSpaceBySpacebase(const Address &loc,int4 size) const; ///< Get space associated with a \e spacebase register
   const LanedRegister *getLanedRegister(const Address &loc,int4 size) const;	///< Get LanedRegister associated with storage
   int4 getMinimumLanedRegisterSize(void) const;		///< Get the minimum size of a laned register in bytes
   void setDefaultModel(ProtoModel *model);		///< Set the default PrototypeModel
   void clearAnalysis(Funcdata *fd);			///< Clear analysis specific to a function
-  void readLoaderSymbols(const string &delim);		 ///< Read any symbols from loader into database
-  void collectBehaviors(vector<OpBehavior *> &behave) const;	///< Provide a list of OpBehavior objects
+  void readLoaderSymbols(const std::string &delim);		 ///< Read any symbols from loader into database
+  void collectBehaviors(std::vector<OpBehavior *> &behave) const;	///< Provide a list of OpBehavior objects
   SegmentOp *getSegmentOp(AddrSpace *spc) const;	///< Retrieve the \e segment op for the given space if any
   void setPrototype(const PrototypePieces &pieces);	///< Set the prototype for a particular function
-  void setPrintLanguage(const string &nm);		///< Establish a particular output language
+  void setPrintLanguage(const std::string &nm);		///< Establish a particular output language
   void globalify(void);					///< Mark \e all spaces as global
   void decodeFlowOverride(Decoder &decoder);		///< Set flow overrides from XML
   virtual ~Architecture(void);				///< Destructor
 
-  virtual string getDescription(void) const { return archid; }	///< Get a string describing \b this architecture
+  virtual std::string getDescription(void) const { return archid; }	///< Get a string describing \b this architecture
 
   /// \brief Print an error message to console
   ///
   /// Write the given message to whatever the registered error stream is
   /// \param message is the error message
-  virtual void printMessage(const string &message) const=0;
+  virtual void printMessage(const std::string &message) const=0;
   virtual void encode(Encoder &encoder) const;		///< Encode \b this architecture to a stream
   virtual void restoreXml(DocumentStorage &store);	///< Restore the Architecture state from XML documents
-  virtual void nameFunction(const Address &addr,string &name) const;	///< Pick a default name for a function
+  virtual void nameFunction(const Address &addr,std::string &name) const;	///< Pick a default name for a function
 #ifdef OPACTION_DEBUG
-  void setDebugStream(ostream *s) { debugstream = s; }	///< Establish the debug console stream
-  void printDebug(const string &message) const { *debugstream << message << endl; }	///< Print message to the debug stream
+  void setDebugStream(std::ostream *s) { debugstream = s; }	///< Establish the debug console stream
+  void printDebug(const std::string &message) const { *debugstream << message << std::endl; }	///< Print message to the debug stream
 #endif
 protected:
-  void addSpacebase(AddrSpace *basespace,const string &nm,const VarnodeData &ptrdata,
+  void addSpacebase(AddrSpace *basespace,const std::string &nm,const VarnodeData &ptrdata,
 		    int4 truncSize,bool isreversejustified,bool stackGrowth,bool isFormal);
   void addNoHighPtr(const Range &rng); ///< Add a new region where pointers do not exist
 
@@ -302,7 +302,7 @@ class Architecture : public AddrSpaceManager {
   void fillinReadOnlyFromLoader(void);			///< Load info about read-only sections
   void initializeSegments();				///< Set up segment resolvers
   void cacheAddrSpaceProperties(void);			///< Calculate some frequently used space properties and cache them
-  void createModelAlias(const string &aliasName,const string &parentName);	///< Create name alias for a ProtoModel
+  void createModelAlias(const std::string &aliasName,const std::string &parentName);	///< Create name alias for a ProtoModel
 
   void parseProcessorConfig(DocumentStorage &store);	///< Apply processor specific configuration
   void parseCompilerConfig(DocumentStorage &store);	///< Apply compiler specific configuration
@@ -312,7 +312,7 @@ class Architecture : public AddrSpaceManager {
   ProtoModel *decodeProto(Decoder &decoder);		///< Parse a proto-type model from a stream
   void decodeProtoEval(Decoder &decoder);		///< Apply prototype evaluation configuration
   void decodeDefaultProto(Decoder &decoder);		///< Apply default prototype model configuration
-  void decodeGlobal(Decoder &decoder,vector<RangeProperties> &rangeProps);	///< Parse information about global ranges
+  void decodeGlobal(Decoder &decoder,std::vector<RangeProperties> &rangeProps);	///< Parse information about global ranges
   void addToGlobalScope(const RangeProperties &props);	///< Add a memory range to the set of addresses considered \e global
   void addOtherSpace(void);                         	///< Add OTHER space and all of its overlays to the symboltab
   void decodeReadOnly(Decoder &decoder);		///< Apply read-only region configuration
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
index b9a495500..a37960f9e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
@@ -16,6 +16,8 @@
  */
 #include "bfd_arch.hh"
 
+using namespace std;
+
 // Constructing this object registers capability
 BfdArchitectureCapability BfdArchitectureCapability::bfdArchitectureCapability;
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.hh
index 6ade01ecc..ed206737b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.hh
@@ -33,8 +33,8 @@ class BfdArchitectureCapability : public ArchitectureCapability {
   BfdArchitectureCapability &operator=(const BfdArchitectureCapability &op2);	///< Not implemented
 public:
   virtual ~BfdArchitectureCapability(void);
-  virtual Architecture *buildArchitecture(const string &filename,const string &target,ostream *estream);
-  virtual bool isFileMatch(const string &filename) const;
+  virtual Architecture *buildArchitecture(const std::string &filename,const std::string &target,std::ostream *estream);
+  virtual bool isFileMatch(const std::string &filename) const;
   virtual bool isXmlMatch(Document *doc) const;
 };
 
@@ -47,7 +47,7 @@ class BfdArchitecture : public SleighArchitecture {
 public:
   virtual void encode(Encoder &encoder) const;
   virtual void restoreXml(DocumentStorage &store);
-  BfdArchitecture(const string &fname,const string &targ,ostream *estream);	///< Constructor
+  BfdArchitecture(const std::string &fname,const std::string &targ,std::ostream *estream);	///< Constructor
   virtual ~BfdArchitecture(void) {}
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
index 5584dbf4d..96f141e5d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
@@ -17,6 +17,8 @@
 #include "block.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_ALTINDEX = AttributeId("altindex",75);
 AttributeId ATTRIB_DEPTH = AttributeId("depth",76);
 AttributeId ATTRIB_END = AttributeId("end",77);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/block.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/block.hh
index 556789694..9c49e4c51 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/block.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/block.hh
@@ -122,13 +122,13 @@ class FlowBlock {
   int4 index;			///< Reference index for this block (reverse post order)
   int4 visitcount;		///< A count of visits of this node for various algorithms
   int4 numdesc;			///< Number of descendants of this block in spanning tree (+1)
-  vector<BlockEdge> intothis;	///< Blocks which (can) fall into this block
-  vector<BlockEdge> outofthis;	///< Blocks into which this block (can) fall
+  std::vector<BlockEdge> intothis;	///< Blocks which (can) fall into this block
+  std::vector<BlockEdge> outofthis;	///< Blocks into which this block (can) fall
 				// If there are two possible outputs as the
 				// result of a conditional branch
 				// the first block in outofthis should be
 				// the result of the condition being false
-  static void replaceEdgeMap(vector<BlockEdge> &vec);	///< Update block references in edges with copy map
+  static void replaceEdgeMap(std::vector<BlockEdge> &vec);	///< Update block references in edges with copy map
   void addInEdge(FlowBlock *b,uint4 lab);	///< Add an edge coming into \b this
   void decodeNextInEdge(Decoder &decoder,BlockMap &resolver);	///< Restore the next input edge from XML
   void halfDeleteInEdge(int4 slot);		///< Delete the \e in half of an edge, correcting indices
@@ -143,7 +143,7 @@ class FlowBlock {
   void clearOutEdgeFlag(int4 i,uint4 lab);	///< Remove an \e out edge label
   void eliminateInDups(FlowBlock *bl);		///< Eliminate duplicate \e in edges from given block
   void eliminateOutDups(FlowBlock *bl);		///< Eliminate duplicate \e out edges to given block
-  static void findDups(const vector<BlockEdge> &ref,vector<FlowBlock *> &duplist);
+  static void findDups(const std::vector<BlockEdge> &ref,std::vector<FlowBlock *> &duplist);
   void dedup(void);				///< Eliminate duplicate edges
   void replaceUsingMap(void);			///< Update references to other blocks using getCopyMap()
 #ifdef BLOCKCONSISTENT_DEBUG
@@ -168,16 +168,16 @@ class FlowBlock {
   virtual void markUnstructured(void) {}			///< Mark target blocks of any unstructured edges
   virtual void markLabelBumpUp(bool bump);	///< Let hierarchical blocks steal labels of their (first) components
   virtual void scopeBreak(int4 curexit,int4 curloopexit) {}	///< Mark unstructured edges that should be \e breaks
-  virtual void printHeader(ostream &s) const;		///< Print a simple description of \b this to stream
-  virtual void printTree(ostream &s,int4 level) const;	///< Print tree structure of any blocks owned by \b this
-  virtual void printRaw(ostream &s) const {}		///< Print raw instructions contained in \b this FlowBlock
+  virtual void printHeader(std::ostream &s) const;		///< Print a simple description of \b this to stream
+  virtual void printTree(std::ostream &s,int4 level) const;	///< Print tree structure of any blocks owned by \b this
+  virtual void printRaw(std::ostream &s) const {}		///< Print raw instructions contained in \b this FlowBlock
   virtual void emit(PrintLanguage *lng) const;	///<Emit the instructions in \b this FlowBlock as structured code
   virtual const FlowBlock *getExitLeaf(void) const { return (const FlowBlock *)0; }	///< Get the FlowBlock to which \b this block exits
   virtual PcodeOp *lastOp(void) const { return (PcodeOp *)0; }		///< Get the last PcodeOp executed by \b this FlowBlock
   virtual bool negateCondition(bool toporbottom);	///< Flip the condition computed by \b this
   virtual bool preferComplement(Funcdata &data);	///< Rearrange \b this hierarchy to simplify boolean expressions
   virtual FlowBlock *getSplitPoint(void);		///< Get the leaf splitting block
-  virtual int4 flipInPlaceTest(vector<PcodeOp *> &fliplist) const;
+  virtual int4 flipInPlaceTest(std::vector<PcodeOp *> &fliplist) const;
   virtual void flipInPlaceExecute(void);
   virtual bool isComplex(void) const { return true; }	///< Is \b this too complex to be a condition (BlockCondition)
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
@@ -263,12 +263,12 @@ class FlowBlock {
   bool isGotoIn(int4 i) const { return ((intothis[i].label & (f_irreducible|f_goto_edge))!=0); }	///< Is the i-th incoming edge unstructured
   bool isGotoOut(int4 i) const { return ((outofthis[i].label & (f_irreducible|f_goto_edge))!=0); }	///< Is the i-th outgoing edge unstructured
   JumpTable *getJumptable(void) const;	///< Get the JumpTable associated \b this block
-  static block_type nameToType(const string &name);	///< Get the block_type associated with a name string
-  static string typeToName(block_type bt);		///< Get the name string associated with a block_type
+  static block_type nameToType(const std::string &name);	///< Get the block_type associated with a name string
+  static std::string typeToName(block_type bt);		///< Get the name string associated with a block_type
   static bool compareBlockIndex(const FlowBlock *bl1,const FlowBlock *bl2);	///< Compare FlowBlock by index
   static bool compareFinalOrder(const FlowBlock *bl1,const FlowBlock *bl2);	///< Final FlowBlock comparison
   static FlowBlock *findCommonBlock(FlowBlock *bl1,FlowBlock *bl2);	///< Find the common dominator of two FlowBlocks
-  static FlowBlock *findCommonBlock(const vector<FlowBlock *> &blockSet);	///< Find common dominator of multiple FlowBlocks
+  static FlowBlock *findCommonBlock(const std::vector<FlowBlock *> &blockSet);	///< Find common dominator of multiple FlowBlocks
 };
 
 /// \brief A control-flow block built out of sub-components
@@ -278,15 +278,15 @@ class FlowBlock {
 /// with its own input and output blocks.
 /// All the code structuring elements (BlockList, BlockIf, BlockWhileDo, etc.) derive from this.
 class BlockGraph : public FlowBlock {
-  vector<FlowBlock *> list;     	///< List of FlowBlock components within \b this super-block
+  std::vector<FlowBlock *> list;     	///< List of FlowBlock components within \b this super-block
   void addBlock(FlowBlock *bl);		///< Add a component FlowBlock
   void forceOutputNum(int4 i);		///< Force number of outputs
   void selfIdentify(void);		///< Inherit our edges from the edges of our components
-  void identifyInternal(BlockGraph *ident,const vector<FlowBlock *> &nodes);
+  void identifyInternal(BlockGraph *ident,const std::vector<FlowBlock *> &nodes);
   void clearEdgeFlags(uint4 fl);	///< Clear a set of properties from all edges in the graph
-  static FlowBlock *createVirtualRoot(const vector<FlowBlock *> &rootlist);
-  void findSpanningTree(vector<FlowBlock *> &preorder,vector<FlowBlock *> &rootlist);
-  bool findIrreducible(const vector<FlowBlock *> &preorder,int4 &irreduciblecount);
+  static FlowBlock *createVirtualRoot(const std::vector<FlowBlock *> &rootlist);
+  void findSpanningTree(std::vector<FlowBlock *> &preorder,std::vector<FlowBlock *> &rootlist);
+  bool findIrreducible(const std::vector<FlowBlock *> &preorder,int4 &irreduciblecount);
   void forceFalseEdge(const FlowBlock *out0);	///< Force the \e false out edge to go to the given FlowBlock
 protected:
   void swapBlocks(int4 i,int4 j);	///< Swap the positions two component FlowBlocks
@@ -294,7 +294,7 @@ class BlockGraph : public FlowBlock {
 public:
   void clear(void);					///< Clear all component FlowBlock objects
   virtual ~BlockGraph(void) { clear(); }		///< Destructor
-  const vector<FlowBlock *> &getList(void) const { return list; }	///< Get the list of component FlowBlock objects
+  const std::vector<FlowBlock *> &getList(void) const { return list; }	///< Get the list of component FlowBlock objects
   int4 getSize(void) const { return list.size(); }	///< Get the number of components
   FlowBlock *getBlock(int4 i) const { return list[i]; }	///< Get the i-th component
   virtual block_type getType(void) const { return t_graph; }
@@ -302,8 +302,8 @@ class BlockGraph : public FlowBlock {
   virtual void markUnstructured(void);
   virtual void markLabelBumpUp(bool bump);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printTree(ostream &s,int4 level) const;
-  virtual void printRaw(ostream &s) const;
+  virtual void printTree(std::ostream &s,int4 level) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockGraph(this); }
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
   virtual void finalTransform(Funcdata &data);
@@ -330,7 +330,7 @@ class BlockGraph : public FlowBlock {
   BlockCopy *newBlockCopy(FlowBlock *bl);					///< Build a new BlockCopy
   BlockGoto *newBlockGoto(FlowBlock *bl);					///< Build a new BlockGoto
   BlockMultiGoto *newBlockMultiGoto(FlowBlock *bl,int4 outedge);		///< Build a new BlockMultiGoto
-  BlockList *newBlockList(const vector<FlowBlock *> &nodes);			///< Build a new BlockList
+  BlockList *newBlockList(const std::vector<FlowBlock *> &nodes);			///< Build a new BlockList
   BlockCondition *newBlockCondition(FlowBlock *b1,FlowBlock *b2);		///< Build a new BlockCondition
   BlockIf *newBlockIfGoto(FlowBlock *cond);					///< Build a new BlockIfGoto
   BlockIf *newBlockIf(FlowBlock *cond,FlowBlock *tc);				///< Build a new BlockIf
@@ -338,19 +338,19 @@ class BlockGraph : public FlowBlock {
   BlockWhileDo *newBlockWhileDo(FlowBlock *cond,FlowBlock *cl);			///< Build a new BlockWhileDo
   BlockDoWhile *newBlockDoWhile(FlowBlock *condcl);				///< Build a new BlockDoWhile
   BlockInfLoop *newBlockInfLoop(FlowBlock *body);				///< Build a new BlockInfLoop
-  BlockSwitch *newBlockSwitch(const vector<FlowBlock *> &cs,bool hasExit);	///< Build a new BlockSwitch
+  BlockSwitch *newBlockSwitch(const std::vector<FlowBlock *> &cs,bool hasExit);	///< Build a new BlockSwitch
 
   void orderBlocks(void) {	///< Sort blocks using the final ordering
     if (list.size()!=1) sort(list.begin(),list.end(),compareFinalOrder); }
   void buildCopy(const BlockGraph &graph);					///< Build a copy of a BlockGraph
   void clearVisitCount(void);							///< Clear the visit count in all node FlowBlocks
-  void calcForwardDominator(const vector<FlowBlock *> &rootlist);		///< Calculate forward dominators
-  void buildDomTree(vector<vector<FlowBlock *> > &child) const;			///< Build the dominator tree
-  int4 buildDomDepth(vector<int4> &depth) const;				///< Calculate dominator depths
-  void buildDomSubTree(vector<FlowBlock *> &res,FlowBlock *root) const;		///< Collect nodes from a dominator sub-tree
+  void calcForwardDominator(const std::vector<FlowBlock *> &rootlist);		///< Calculate forward dominators
+  void buildDomTree(std::vector<std::vector<FlowBlock *> > &child) const;			///< Build the dominator tree
+  int4 buildDomDepth(std::vector<int4> &depth) const;				///< Calculate dominator depths
+  void buildDomSubTree(std::vector<FlowBlock *> &res,FlowBlock *root) const;		///< Collect nodes from a dominator sub-tree
   void calcLoop(void);								///< Calculate loop edges
-  void collectReachable(vector<FlowBlock *> &res,FlowBlock *bl,bool un) const;	///< Collect reachable/unreachable FlowBlocks from a given start FlowBlock
-  void structureLoops(vector<FlowBlock *> &rootlist);				///< Label loop edges
+  void collectReachable(std::vector<FlowBlock *> &res,FlowBlock *bl,bool un) const;	///< Collect reachable/unreachable FlowBlocks from a given start FlowBlock
+  void structureLoops(std::vector<FlowBlock *> &rootlist);				///< Label loop edges
 #ifdef BLOCKCONSISTENT_DEBUG
   bool isConsistent(void) const;						///< Check consistency of \b this BlockGraph
 #endif
@@ -373,10 +373,10 @@ class BlockGraph : public FlowBlock {
 /// PcodeOps my migrate away from this original range.
 class BlockBasic: public FlowBlock {
   friend class Funcdata;				// Only uses private functions
-  list<PcodeOp *> op;					///< The sequence of p-code operations
+  std::list<PcodeOp *> op;					///< The sequence of p-code operations
   Funcdata *data;					///< The function of which this block is a part
   RangeList cover;					///< Original range of addresses covered by this basic block
-  void insert(list<PcodeOp *>::iterator iter,PcodeOp *inst);	///< Insert p-code operation at a given position
+  void insert(std::list<PcodeOp *>::iterator iter,PcodeOp *inst);	///< Insert p-code operation at a given position
   void setInitialRange(const Address &beg,const Address &end);	///< Set the initial address range of the block
   void copyRange(const BlockBasic *bb) { cover = bb->cover; }	///< Copy address ranges from another basic block
   void mergeRange(const BlockBasic *bb) { cover.merge(bb->cover); }	///< Merge address ranges from another basic block
@@ -394,23 +394,23 @@ class BlockBasic: public FlowBlock {
   virtual FlowBlock *subBlock(int4 i) const { return (FlowBlock *)0; }
   virtual void encodeBody(Encoder &encoder) const;
   virtual void decodeBody(Decoder &decoder);
-  virtual void printHeader(ostream &s) const;
-  virtual void printRaw(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockBasic(this); }
   virtual const FlowBlock *getExitLeaf(void) const { return this; }
   virtual PcodeOp *lastOp(void) const;
   virtual bool negateCondition(bool toporbottom);
   virtual FlowBlock *getSplitPoint(void);
-  virtual int4 flipInPlaceTest(vector<PcodeOp *> &fliplist) const;
+  virtual int4 flipInPlaceTest(std::vector<PcodeOp *> &fliplist) const;
   virtual void flipInPlaceExecute(void);
   virtual bool isComplex(void) const;
   bool unblockedMulti(int4 outslot) const;		///< Check if \b this block can be removed without introducing inconsistencies
   bool hasOnlyMarkers(void) const;		///< Does \b this block contain only MULTIEQUAL and INDIRECT ops
   bool isDoNothing(void) const;			///< Should \b this block should be removed
-  list<PcodeOp *>::iterator beginOp(void) { return op.begin(); }	///< Return an iterator to the beginning of the PcodeOps
-  list<PcodeOp *>::iterator endOp(void) { return op.end(); }		///< Return an iterator to the end of the PcodeOps
-  list<PcodeOp *>::const_iterator beginOp(void) const { return op.begin(); }	///< Return an iterator to the beginning of the PcodeOps
-  list<PcodeOp *>::const_iterator endOp(void) const { return op.end(); }	///< Return an iterator to the end of the PcodeOps
+  std::list<PcodeOp *>::iterator beginOp(void) { return op.begin(); }	///< Return an iterator to the beginning of the PcodeOps
+  std::list<PcodeOp *>::iterator endOp(void) { return op.end(); }		///< Return an iterator to the end of the PcodeOps
+  std::list<PcodeOp *>::const_iterator beginOp(void) const { return op.begin(); }	///< Return an iterator to the beginning of the PcodeOps
+  std::list<PcodeOp *>::const_iterator endOp(void) const { return op.end(); }	///< Return an iterator to the end of the PcodeOps
   bool emptyOp(void) const { return op.empty(); }		///< Return \b true if \b block contains no operations
   static bool noInterveningStatement(PcodeOp *first,int4 path,PcodeOp *last);
 };
@@ -431,9 +431,9 @@ class BlockCopy : public FlowBlock {
   BlockCopy(FlowBlock *bl) { copy = bl; }	///< Construct given the block to copy
   virtual FlowBlock *subBlock(int4 i) const { return copy; }
   virtual block_type getType(void) const { return t_copy; }
-  virtual void printHeader(ostream &s) const;
-  virtual void printTree(ostream &s,int4 level) const;
-  virtual void printRaw(ostream &s) const { copy->printRaw(s); }
+  virtual void printHeader(std::ostream &s) const;
+  virtual void printTree(std::ostream &s,int4 level) const;
+  virtual void printRaw(std::ostream &s) const { copy->printRaw(s); }
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockCopy(this); }
   virtual const FlowBlock *getExitLeaf(void) const { return this; }
   virtual PcodeOp *lastOp(void) const { return copy->lastOp(); }
@@ -461,8 +461,8 @@ class BlockGoto : public BlockGraph {
   virtual block_type getType(void) const { return t_goto; }
   virtual void markUnstructured(void);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
-  virtual void printRaw(ostream &s) const { getBlock(0)->printRaw(s); }
+  virtual void printHeader(std::ostream &s) const;
+  virtual void printRaw(std::ostream &s) const { getBlock(0)->printRaw(s); }
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockGoto(this); }
   virtual const FlowBlock *getExitLeaf(void) const { return getBlock(0)->getExitLeaf(); }
   virtual PcodeOp *lastOp(void) const { return getBlock(0)->lastOp(); }
@@ -477,7 +477,7 @@ class BlockGoto : public BlockGraph {
 /// presents a view to the structuring algorithm as if the edge didn't exist.  If at a later point,
 /// more edges can't be structured, the one instance can hold this information as well.
 class BlockMultiGoto : public BlockGraph {
-  vector<FlowBlock *> gotoedges; 		///< List of goto targets from this block
+  std::vector<FlowBlock *> gotoedges; 		///< List of goto targets from this block
   bool defaultswitch;				///< True if one of the unstructured edges is the formal switch \e default edge
 public:
   BlockMultiGoto(FlowBlock *bl) { defaultswitch = false; }	///< Construct given the underlying multi-exit block
@@ -489,8 +489,8 @@ class BlockMultiGoto : public BlockGraph {
   
   virtual block_type getType(void) const { return t_multigoto; }
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
-  virtual void printRaw(ostream &s) const { getBlock(0)->printRaw(s); }
+  virtual void printHeader(std::ostream &s) const;
+  virtual void printRaw(std::ostream &s) const { getBlock(0)->printRaw(s); }
   virtual void emit(PrintLanguage *lng) const { getBlock(0)->emit(lng); }
   virtual const FlowBlock *getExitLeaf(void) const { return getBlock(0)->getExitLeaf(); }
   virtual PcodeOp *lastOp(void) const { return getBlock(0)->lastOp(); }
@@ -506,7 +506,7 @@ class BlockMultiGoto : public BlockGraph {
 class BlockList : public BlockGraph {
 public:
   virtual block_type getType(void) const { return t_ls; }
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockLs(this); }
   virtual const FlowBlock *getExitLeaf(void) const;
   virtual PcodeOp *lastOp(void) const;
@@ -531,11 +531,11 @@ class BlockCondition : public BlockGraph {
   OpCode getOpcode(void) const { return opc; }	///< Get the boolean operation
   virtual block_type getType(void) const { return t_condition; }
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockCondition(this); }
   virtual bool negateCondition(bool toporbottom);
   virtual FlowBlock *getSplitPoint(void) { return this; }
-  virtual int4 flipInPlaceTest(vector<PcodeOp *> &fliplist) const;
+  virtual int4 flipInPlaceTest(std::vector<PcodeOp *> &fliplist) const;
   virtual void flipInPlaceExecute(void);
   virtual PcodeOp *lastOp(void) const;
   virtual bool isComplex(void) const { return getBlock(0)->isComplex(); }
@@ -572,7 +572,7 @@ class BlockIf : public BlockGraph {
   virtual block_type getType(void) const { return t_if; }
   virtual void markUnstructured(void);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockIf(this); }
   virtual bool preferComplement(Funcdata &data);
   virtual const FlowBlock *getExitLeaf(void) const;
@@ -613,7 +613,7 @@ class BlockWhileDo : public BlockGraph {
   virtual block_type getType(void) const { return t_whiledo; }
   virtual void markLabelBumpUp(bool bump);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockWhileDo(this); }
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
   virtual void finalTransform(Funcdata &data);
@@ -629,7 +629,7 @@ class BlockDoWhile : public BlockGraph {
   virtual block_type getType(void) const { return t_dowhile; }
   virtual void markLabelBumpUp(bool bump);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockDoWhile(this); }
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
 };
@@ -643,7 +643,7 @@ class BlockInfLoop : public BlockGraph {
   virtual block_type getType(void) const { return t_infloop; }
   virtual void markLabelBumpUp(bool bump);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockInfLoop(this); }
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
 };
@@ -670,11 +670,11 @@ class BlockSwitch : public BlockGraph {
     bool isdefault;		///< True if this is formal \e default case for the switch
     static bool compare(const CaseOrder &a,const CaseOrder &b);	///< Compare two cases
   };
-  mutable vector<CaseOrder> caseblocks; ///< Blocks associated with switch cases
+  mutable std::vector<CaseOrder> caseblocks; ///< Blocks associated with switch cases
   void addCase(FlowBlock *switchbl,FlowBlock *bl,uint4 gt);	///< Add a new \e case to this switch
 public:
   BlockSwitch(FlowBlock *ind);		///< Construct given the multi-exit root block
-  void grabCaseBasic(FlowBlock *switchbl,const vector<FlowBlock *> &cs);	///< Build annotated CaseOrder objects
+  void grabCaseBasic(FlowBlock *switchbl,const std::vector<FlowBlock *> &cs);	///< Build annotated CaseOrder objects
   FlowBlock *getSwitchBlock(void) const { return getBlock(0); }		///< Get the root switch component
   int4 getNumCaseBlocks(void) const { return caseblocks.size(); }	///< Get the number of cases
   FlowBlock *getCaseBlock(int4 i) const { return caseblocks[i].block; }	///< Get the i-th \e case FlowBlock
@@ -699,7 +699,7 @@ class BlockSwitch : public BlockGraph {
   virtual block_type getType(void) const { return t_switch; }
   virtual void markUnstructured(void);
   virtual void scopeBreak(int4 curexit,int4 curloopexit);
-  virtual void printHeader(ostream &s) const;
+  virtual void printHeader(std::ostream &s) const;
   virtual void emit(PrintLanguage *lng) const { lng->emitBlockSwitch(this); }
   virtual FlowBlock *nextFlowAfter(const FlowBlock *bl) const;
   virtual void finalizePrinting(Funcdata &data) const;
@@ -712,9 +712,9 @@ class BlockSwitch : public BlockGraph {
 /// list of FlowBlock objects sorted by index and then looks up the FlowBlock matching a given
 /// index as edges specify them.
 class BlockMap {
-  vector<FlowBlock *> sortlist;		///< The list of deserialized FlowBlock objects
+  std::vector<FlowBlock *> sortlist;		///< The list of deserialized FlowBlock objects
   FlowBlock *resolveBlock(FlowBlock::block_type bt);	///< Construct a FlowBlock of the given type
-  static FlowBlock *findBlock(const vector<FlowBlock *> &list,int4 ind);	///< Locate a FlowBlock with a given index
+  static FlowBlock *findBlock(const std::vector<FlowBlock *> &list,int4 ind);	///< Locate a FlowBlock with a given index
 public:
   void sortList(void);					///< Sort the list of FlowBlock objects
 
@@ -723,7 +723,7 @@ class BlockMap {
   /// \param index is the given index
   /// \return the FlowBlock matching the index
   FlowBlock *findLevelBlock(int4 index) const { return findBlock(sortlist,index); }
-  FlowBlock *createBlock(const string &name);		///< Create a FlowBlock of the named type
+  FlowBlock *createBlock(const std::string &name);		///< Create a FlowBlock of the named type
 };
 
 /// This is the main entry point, at the control-flow level, for printing structured code.
@@ -764,7 +764,7 @@ inline FlowBlock *FlowBlock::getSplitPoint(void)
 ///   - 2 if the flip produces an unnormalized condition
 /// \param fliplist will contain the PcodeOps that need to be adjusted
 /// \return 0 if the condition will be normalized, 1 or 2 otherwise
-inline int4 FlowBlock::flipInPlaceTest(vector<PcodeOp *> &fliplist) const
+inline int4 FlowBlock::flipInPlaceTest(std::vector<PcodeOp *> &fliplist) const
 
 {
   return 2;	// By default a block will not normalize
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
index 80265a458..9c9906f8f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
@@ -16,6 +16,8 @@
 #include "blockaction.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 /// Retrieve the current edge (as a \e top FlowBlock and the index of the outgoing edge).
 /// If the end-points have been collapsed together, this returns NULL.
 /// The top and bottom nodes of the edge are updated to FlowBlocks in the current collapsed graph.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.hh
index 09b1779dc..0ae2b6234 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.hh
@@ -43,34 +43,34 @@ class FloatingEdge {
 /// the head.
 class LoopBody {
   FlowBlock *head;		///< head of the loop
-  vector<FlowBlock *> tails;	///< (Possibly multiple) nodes with back edge returning to the head
+  std::vector<FlowBlock *> tails;	///< (Possibly multiple) nodes with back edge returning to the head
   int4 depth;			///< Nested depth of this loop
   int4 uniquecount;		///< Total number of unique head and tail nodes
   FlowBlock *exitblock;		///< Official exit block from loop, or NULL
-  list<FloatingEdge> exitedges;	///< Edges that exit to the formal exit block
+  std::list<FloatingEdge> exitedges;	///< Edges that exit to the formal exit block
   LoopBody *immed_container;	///< Immediately containing loop body, or NULL
-  void extendToContainer(const LoopBody &container,vector<FlowBlock *> &body) const;
+  void extendToContainer(const LoopBody &container,std::vector<FlowBlock *> &body) const;
 public:
   LoopBody(FlowBlock *h) { head=h; immed_container = (LoopBody *)0; depth=0; }	///< Construct with a loop head
   FlowBlock *getHead(void) const { return head; }			///< Return the head FlowBlock of the loop
   FlowBlock *getCurrentBounds(FlowBlock **top,FlowBlock *graph);	///< Return current loop bounds (\b head and \b bottom).
   void addTail(FlowBlock *bl) { tails.push_back(bl); }			///< Add a \e tail to the loop
   FlowBlock *getExitBlock(void) const { return exitblock; }		///< Get the exit FlowBlock or NULL
-  void findBase(vector<FlowBlock *> &body);				///< Mark the body FlowBlocks of \b this loop
-  void extend(vector<FlowBlock *> &body) const;				///< Extend body (to blocks that never exit)
-  void findExit(const vector<FlowBlock *> &body);			///< Choose the exit block for \b this loop
+  void findBase(std::vector<FlowBlock *> &body);				///< Mark the body FlowBlocks of \b this loop
+  void extend(std::vector<FlowBlock *> &body) const;				///< Extend body (to blocks that never exit)
+  void findExit(const std::vector<FlowBlock *> &body);			///< Choose the exit block for \b this loop
   void orderTails(void);						///< Find preferred \b tail
-  void labelExitEdges(const vector<FlowBlock *> &body);			///< Label edges that exit the loop
-  void labelContainments(const vector<FlowBlock *> &body,const vector<LoopBody *> &looporder);
-  void emitLikelyEdges(list<FloatingEdge> &likely,FlowBlock *graph);	///< Collect likely \e unstructured edges
+  void labelExitEdges(const std::vector<FlowBlock *> &body);			///< Label edges that exit the loop
+  void labelContainments(const std::vector<FlowBlock *> &body,const std::vector<LoopBody *> &looporder);
+  void emitLikelyEdges(std::list<FloatingEdge> &likely,FlowBlock *graph);	///< Collect likely \e unstructured edges
   void setExitMarks(FlowBlock *graph);					///< Mark all the exits to this loop
   void clearExitMarks(FlowBlock *graph);				///< Clear the mark on all the exits to this loop
   bool operator<(const LoopBody &op2) const { return (depth > op2.depth); }	///< Order loop bodies by depth
-  static void mergeIdenticalHeads(vector<LoopBody *> &looporder);	///< Merge loop bodies that share the same \e head
+  static void mergeIdenticalHeads(std::vector<LoopBody *> &looporder);	///< Merge loop bodies that share the same \e head
   static bool compare_ends(LoopBody *a,LoopBody *b);			///< Compare the \b head then \b tail
   static int4 compare_head(LoopBody *a,FlowBlock *looptop);		///< Compare just the \b head
-  static LoopBody *find(FlowBlock *looptop,const vector<LoopBody *> &looporder);	///< Find a LoopBody
-  static void clearMarks(vector<FlowBlock *> &body);			///< Clear the body marks
+  static LoopBody *find(FlowBlock *looptop,const std::vector<LoopBody *> &looporder);	///< Find a LoopBody
+  static void clearMarks(std::vector<FlowBlock *> &body);			///< Clear the body marks
 };
 
 /// \brief Algorithm for selecting unstructured edges based an Directed Acyclic Graphs (DAG)
@@ -101,7 +101,7 @@ class TraceDAG {
     BranchPoint *parent;	///< The parent BranchPoint along which \b this is only one path
     int4 pathout;		///< Index (of the out edge from the parent) of the path along which \b this lies
     FlowBlock *top;		///< FlowBlock that embodies the branch point
-    vector<BlockTrace *> paths;	///< BlockTrace for each possible path out of \b this BlockPoint
+    std::vector<BlockTrace *> paths;	///< BlockTrace for each possible path out of \b this BlockPoint
     int4 depth;			///< Depth of BranchPoints from the root
     bool ismark;		///< Possible mark
     void createTraces(void);	///< Given the BlockTrace objects, given a new BranchPoint
@@ -129,7 +129,7 @@ class TraceDAG {
     FlowBlock *bottom;		///< Current node being traversed along 1 path from decision point
     FlowBlock *destnode;	///< Next FlowBlock node \b this BlockTrace will try to push into
     int4 edgelump;		///< If >1, edge to \b destnode is "virtual" representing multiple edges coming together
-    list<BlockTrace *>::iterator activeiter; ///< Position of \b this in the active trace list
+    std::list<BlockTrace *>::iterator activeiter; ///< Position of \b this in the active trace list
     BranchPoint *derivedbp;	///< BranchPoint blocker \b this traces into
   public:
     BlockTrace(BranchPoint *t,int4 po,int4 eo);		///< Construct given a parent BranchPoint and path index
@@ -151,26 +151,26 @@ class TraceDAG {
     bool operator<(const BadEdgeScore &op2) const;	///< Compare for grouping
   };
 
-  list<FloatingEdge> &likelygoto;	///< A reference to the list of likely goto edges being produced
-  vector<FlowBlock *> rootlist;		///< List of root FlowBlocks to trace from
-  vector<BranchPoint *> branchlist;	///< Current set of BranchPoints that have been traced
+  std::list<FloatingEdge> &likelygoto;	///< A reference to the list of likely goto edges being produced
+  std::vector<FlowBlock *> rootlist;		///< List of root FlowBlocks to trace from
+  std::vector<BranchPoint *> branchlist;	///< Current set of BranchPoints that have been traced
   int4 activecount;			///< Number of active BlockTrace objects
   int4 missedactivecount;		///< Current number of active BlockTraces that can't be pushed further
-  list<BlockTrace *> activetrace;	///< The list of \e active BlockTrace objects
-  list<BlockTrace *>::iterator current_activeiter;	///< The current \e active BlockTrace being pushed
+  std::list<BlockTrace *> activetrace;	///< The list of \e active BlockTrace objects
+  std::list<BlockTrace *>::iterator current_activeiter;	///< The current \e active BlockTrace being pushed
   FlowBlock *finishblock;		///< Designated exit block for the DAG (or null)
   void removeTrace(BlockTrace *trace);	///< Remove the indicated BlockTrace
-  void processExitConflict(list<BadEdgeScore>::iterator start,list<BadEdgeScore>::iterator end);
+  void processExitConflict(std::list<BadEdgeScore>::iterator start,std::list<BadEdgeScore>::iterator end);
   BlockTrace *selectBadEdge(void);	///< Select the the most likely unstructured edge from active BlockTraces
   void insertActive(BlockTrace *trace);	///< Move a BlockTrace into the \e active category
   void removeActive(BlockTrace *trace);	///< Remove a BlockTrace from the \e active category
   bool checkOpen(BlockTrace *trace);	///< Check if we can push the given BlockTrace into its next node
-  list<BlockTrace *>::iterator openBranch(BlockTrace *parent);	///< Open a new BranchPoint along a given BlockTrace
+  std::list<BlockTrace *>::iterator openBranch(BlockTrace *parent);	///< Open a new BranchPoint along a given BlockTrace
   bool checkRetirement(BlockTrace *trace,FlowBlock *&exitblock);	///< Check if a given BlockTrace can be retired
-  list<BlockTrace *>::iterator retireBranch(BranchPoint *bp,FlowBlock *exitblock);
+  std::list<BlockTrace *>::iterator retireBranch(BranchPoint *bp,FlowBlock *exitblock);
   void clearVisitCount(void);		/// Clear the \b visitcount field of any FlowBlock we have modified
 public:
-  TraceDAG(list<FloatingEdge> &lg);	///< Construct given the container for likely unstructured edges
+  TraceDAG(std::list<FloatingEdge> &lg);	///< Construct given the container for likely unstructured edges
   ~TraceDAG(void);			///< Destructor
   void addRoot(FlowBlock *root) { rootlist.push_back(root); }	///< Add a root FlowBlock to the trace
   void initialize(void);		///< Create the initial BranchPoint and BlockTrace objects
@@ -190,17 +190,17 @@ class TraceDAG {
 class CollapseStructure {
   bool finaltrace;				///< Have we a made search for unstructured edges in the final DAG
   bool likelylistfull;				///< Have we generated a \e likely \e goto list for the current innermost loop
-  list<FloatingEdge> likelygoto;		///< The current \e likely \e goto list
-  list<FloatingEdge>::iterator likelyiter;	///< Iterator to the next most \e likely \e goto edge
-  list<LoopBody> loopbody;			///< The list of loop bodies for this control-flow graph
-  list<LoopBody>::iterator loopbodyiter;	///< Current (innermost) loop being structured
+  std::list<FloatingEdge> likelygoto;		///< The current \e likely \e goto list
+  std::list<FloatingEdge>::iterator likelyiter;	///< Iterator to the next most \e likely \e goto edge
+  std::list<LoopBody> loopbody;			///< The list of loop bodies for this control-flow graph
+  std::list<LoopBody>::iterator loopbodyiter;	///< Current (innermost) loop being structured
   BlockGraph &graph;				///< The control-flow graph
   int4 dataflow_changecount;			///< Number of data-flow changes made during structuring
   bool checkSwitchSkips(FlowBlock *switchbl,FlowBlock *exitblock);
-  void onlyReachableFromRoot(FlowBlock *root,vector<FlowBlock *> &body);
-  int4 markExitsAsGotos(vector<FlowBlock *> &body);	///< Mark edges exiting the body as \e unstructured gotos
+  void onlyReachableFromRoot(FlowBlock *root,std::vector<FlowBlock *> &body);
+  int4 markExitsAsGotos(std::vector<FlowBlock *> &body);	///< Mark edges exiting the body as \e unstructured gotos
   bool clipExtraRoots(void);			///< Mark edges between root components as \e unstructured gotos
-  void labelLoops(vector<LoopBody *> &looporder);	///< Identify all the loops in this graph
+  void labelLoops(std::vector<LoopBody *> &looporder);	///< Identify all the loops in this graph
   void orderLoopBodies(void);			///< Identify and label all loop structure for this graph
   bool updateLoopBody(void);			///< Find likely \e unstructured edges within the innermost loop body
   FlowBlock *selectGoto(void);			///< Select an edge to mark as  \e unstructured
@@ -249,7 +249,7 @@ class ConditionalJoin {
   PcodeOp *cbranch1;			///< CBRANCH at bottom of \b block1
   PcodeOp *cbranch2;			///< CBRANCH at bottom of \b block2
   BlockBasic *joinblock;		///< The new joined condition block
-  map<MergePair,Varnode *> mergeneed;	///< Map from the MergePair of Varnodes to the merged Varnode
+  std::map<MergePair,Varnode *> mergeneed;	///< Map from the MergePair of Varnodes to the merged Varnode
   bool findDups(void);			///< Search for duplicate conditional expressions
   void checkExitBlock(BlockBasic *exit,int4 in1,int4 in2);
   void cutDownMultiequals(BlockBasic *exit,int4 in1,int4 in2);
@@ -267,7 +267,7 @@ class ConditionalJoin {
 /// This is currently used to set up \e for loops via BlockWhileDo
 class ActionStructureTransform : public Action {
 public:
-  ActionStructureTransform(const string &g) : Action(0,"structuretransform",g) {}	///< Constructor
+  ActionStructureTransform(const std::string &g) : Action(0,"structuretransform",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionStructureTransform(getGroup());
@@ -281,7 +281,7 @@ class ActionStructureTransform : public Action {
 /// normalization of the data-flow is important but structured source code doesn't need to be emitted.
 class ActionNormalizeBranches : public Action {
 public:
-  ActionNormalizeBranches(const string &g) : Action(0,"normalizebranches",g) {}	///< Constructor
+  ActionNormalizeBranches(const std::string &g) : Action(0,"normalizebranches",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionNormalizeBranches(getGroup());
@@ -297,7 +297,7 @@ class ActionNormalizeBranches : public Action {
 /// structurings, such as an if/else where the \b true and \b false blocks can be swapped.
 class ActionPreferComplement : public Action {
 public:
-  ActionPreferComplement(const string &g) : Action(0,"prefercomplement",g) {}	///< Constructor
+  ActionPreferComplement(const std::string &g) : Action(0,"prefercomplement",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionPreferComplement(getGroup());
@@ -308,7 +308,7 @@ class ActionPreferComplement : public Action {
 /// \brief Structure control-flow using standard high-level code constructs.
 class ActionBlockStructure : public Action {
 public:
-  ActionBlockStructure(const string &g) : Action(0,"blockstructure",g) {}	///< Constructor
+  ActionBlockStructure(const std::string &g) : Action(0,"blockstructure",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionBlockStructure(getGroup());
@@ -321,7 +321,7 @@ class ActionBlockStructure : public Action {
 /// Label unstructured edges, order switch cases, and order disjoint components of the control-flow
 class ActionFinalStructure : public Action {
 public:
-  ActionFinalStructure(const string &g) : Action(0,"finalstructure",g) {}	///< Constructor
+  ActionFinalStructure(const std::string &g) : Action(0,"finalstructure",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionFinalStructure(getGroup());
@@ -333,10 +333,10 @@ class ActionFinalStructure : public Action {
 ///
 /// Introduce RETURN operations corresponding to individual branches flowing to the epilog.
 class ActionReturnSplit : public Action {
-  static void gatherReturnGotos(FlowBlock *parent,vector<FlowBlock *> &vec);
+  static void gatherReturnGotos(FlowBlock *parent,std::vector<FlowBlock *> &vec);
   static bool isSplittable(BlockBasic *b);		///< Determine if a RETURN block can be split
 public:
-  ActionReturnSplit(const string &g) : Action(0,"returnsplit",g) {}		///< Constructor
+  ActionReturnSplit(const std::string &g) : Action(0,"returnsplit",g) {}		///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionReturnSplit(getGroup());
@@ -347,7 +347,7 @@ class ActionReturnSplit : public Action {
 /// \brief  Look for conditional branch expressions that have been split and rejoin them
 class ActionNodeJoin : public Action {
 public:
-  ActionNodeJoin(const string &g) : Action(0,"nodejoin",g) {}			///< Constructor
+  ActionNodeJoin(const std::string &g) : Action(0,"nodejoin",g) {}			///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionNodeJoin(getGroup());
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
index 26406c288..6b6a8d34b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
@@ -16,6 +16,8 @@
 #include "callgraph.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 ElementId ELEM_CALLGRAPH = ElementId("callgraph",226);
 ElementId ELEM_NODE = ElementId("node",227);
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.hh
index f8419f15a..5ad32b66f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.hh
@@ -60,10 +60,10 @@ class CallGraphNode {
 private:
   friend class CallGraph;
   Address entryaddr;		// Starting address of function
-  string name;			// Name of the function if available
+  std::string name;			// Name of the function if available
   Funcdata *fd;			// Pointer to funcdata if we have it
-  vector<CallGraphEdge> inedge;
-  vector<CallGraphEdge> outedge;
+  std::vector<CallGraphEdge> inedge;
+  std::vector<CallGraphEdge> outedge;
   int4 parentedge;		// Incoming edge for spanning tree
   mutable uint4 flags;
 public:
@@ -71,7 +71,7 @@ class CallGraphNode {
   void clearMark(void) const { flags &= ~((uint4)mark); }
   bool isMark(void) const { return ((flags&mark)!=0); }
   const Address getAddr(void) const { return entryaddr; }
-  const string &getName(void) const { return name; }
+  const std::string &getName(void) const { return name; }
   Funcdata *getFuncdata(void) const { return fd; }
   int4 numInEdge(void) const { return inedge.size(); }
   const CallGraphEdge &getInEdge(int4 i) const { return inedge[i]; }
@@ -93,9 +93,9 @@ struct LeafIterator {
 class Scope;		// forward declaration
 class CallGraph {
   Architecture *glb;
-  map<Address,CallGraphNode> graph; // Nodes in the graph sorted by address
-  vector<CallGraphNode *> seeds;
-  bool findNoEntry(vector<CallGraphNode *> &seeds);
+  std::map<Address,CallGraphNode> graph; // Nodes in the graph sorted by address
+  std::vector<CallGraphNode *> seeds;
+  bool findNoEntry(std::vector<CallGraphNode *> &seeds);
   void snipCycles(CallGraphNode *node);
   void snipEdge(CallGraphNode *node,int4 i);
   void clearMarks(void);
@@ -108,14 +108,14 @@ class CallGraph {
 public:
   CallGraph(Architecture *g) { glb = g; }
   CallGraphNode *addNode(Funcdata *f);
-  CallGraphNode *addNode(const Address &addr,const string &nm);
+  CallGraphNode *addNode(const Address &addr,const std::string &nm);
   CallGraphNode *findNode(const Address &addr);
   void addEdge(CallGraphNode *from,CallGraphNode *to,const Address &addr);
   void deleteInEdge(CallGraphNode *node,int4 i);
   CallGraphNode * initLeafWalk(void);
   CallGraphNode *nextLeaf(CallGraphNode *node);
-  map<Address,CallGraphNode>::iterator begin(void) { return graph.begin(); }
-  map<Address,CallGraphNode>::iterator end(void) { return graph.end(); }
+  std::map<Address,CallGraphNode>::iterator begin(void) { return graph.begin(); }
+  std::map<Address,CallGraphNode>::iterator end(void) { return graph.end(); }
   void buildAllNodes(void);
   void buildEdges(Funcdata *fd);
   void encode(Encoder &encoder) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/capability.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/capability.cc
index 87e40dbbf..481cf3378 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/capability.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/capability.cc
@@ -15,6 +15,8 @@
  */
 #include "capability.hh"
 
+using namespace std;
+
 /// Access static vector of CapabilityPoint objects that are registered during static initialization
 /// The list itself is created once on the first call to this method
 /// \e after all the static initializers have run
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/capability.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/capability.hh
index 9ed07195d..4cbbf6aec 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/capability.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/capability.hh
@@ -22,8 +22,6 @@
 #include <vector>
 #include <string>
 
-using namespace std;
-
 /// \brief Class for automatically registering extension points to the decompiler
 ///
 /// This uses the C++ static initializer feature to automatically \e discover
@@ -34,7 +32,7 @@ using namespace std;
 /// will ensure that the initialize() method is called on each extension, allowing it
 /// to complete its integration.
 class CapabilityPoint {
-  static vector<CapabilityPoint *> &getList(void);	///< Retrieve the list of extension point singletons
+  static std::vector<CapabilityPoint *> &getList(void);	///< Retrieve the list of extension point singletons
 protected:
   CapabilityPoint(void);		///< Construct extension capability exactly once
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cast.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/cast.cc
index dc8baa764..0899dc5de 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cast.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cast.cc
@@ -16,6 +16,8 @@
 #include "cast.hh"
 #include "op.hh"
 
+using namespace std;
+
 /// Sets the TypeFactory used to produce data-types for the arithmeticOutputStandard() method
 /// \param t is the TypeFactory
 void CastStrategy::setTypeFactory(TypeFactory *t)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.cc
index 92690f422..1ba834bd6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.cc
@@ -17,6 +17,8 @@
 #include "codedata.hh"
 #include "loadimage_bfd.hh"
 
+using namespace std;
+
 // Constructing this registers the capability
 IfaceCodeDataCapability IfaceCodeDataCapability::ifaceCodeDataCapability;
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.hh
index 3b5a4b031..87db1807b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/codedata.hh
@@ -58,8 +58,8 @@ struct DisassemblyResult {
 
 class DisassemblyEngine : public PcodeEmit {
   const Translate *trans;
-  vector<Address> jumpaddr;
-  set<uintb> targetoffsets;
+  std::vector<Address> jumpaddr;
+  std::set<uintb> targetoffsets;
   OpCode lastop;
   bool hascall;
   bool hitsaddress;
@@ -83,7 +83,7 @@ class TargetHit {
 };
 
 struct TargetFeature {
-  string name;			// Name of the target function
+  std::string name;			// Name of the target function
   uint4 featuremask;		// id of this target for ORing into a mask
 };
 
@@ -104,22 +104,22 @@ class CodeDataAnalysis : public IfaceData {
   Architecture *glb;
   DisassemblyEngine disengine;
   RangeList modelhits;
-  map<Address,CodeUnit> codeunit;
-  map<AddrLink,uint4> fromto_crossref;
-  map<AddrLink,uint4> tofrom_crossref;
-  list<map<Address,CodeUnit>::iterator> taintlist;
-  list<Address> unlinkedstarts;
-  list<TargetHit> targethits;
-  map<Address,TargetFeature> targets;
+  std::map<Address,CodeUnit> codeunit;
+  std::map<AddrLink,uint4> fromto_crossref;
+  std::map<AddrLink,uint4> tofrom_crossref;
+  std::list<std::map<Address,CodeUnit>::iterator> taintlist;
+  std::list<Address> unlinkedstarts;
+  std::list<TargetHit> targethits;
+  std::map<Address,TargetFeature> targets;
   virtual ~CodeDataAnalysis(void) {}
   void init(Architecture *g);
   void pushTaintAddress(const Address &addr);
   void processTaint(void);
-  Address commitCodeVec(const Address &addr,vector<CodeUnit> &codevec,map<AddrLink,uint4> &fromto_vec);
+  Address commitCodeVec(const Address &addr,std::vector<CodeUnit> &codevec,std::map<AddrLink,uint4> &fromto_vec);
   void clearHitBy(void);
   void clearCrossRefs(const Address &addr,const Address &endaddr);
   void clearCodeUnits(const Address &addr,const Address &endaddr);
-  void addTarget(const string &nm,const Address &addr,uint4 mask);
+  void addTarget(const std::string &nm,const Address &addr,uint4 mask);
   int4 getNumTargets(void) const { return targets.size(); }
   Address disassembleBlock(const Address &addr,const Address &endaddr);
   void disassembleRange(const Range &range);
@@ -130,16 +130,16 @@ class CodeDataAnalysis : public IfaceData {
   void addTargetHit(const Address &codeaddr,uintb targethit);
   void resolveThunkHit(const Address &codeaddr,uintb targethit);
   void findUnlinked(void);
-  bool checkErrantStart(map<Address,CodeUnit>::iterator iter);
+  bool checkErrantStart(std::map<Address,CodeUnit>::iterator iter);
   bool repairJump(const Address &addr,int4 max);
   void findOffCut(void);
   Address findFunctionStart(const Address &addr) const;
-  const list<TargetHit> &getTargetHits(void) const { return targethits; }
-  void dumpModelHits(ostream &s) const;
-  void dumpCrossRefs(ostream &s) const;
-  void dumpFunctionStarts(ostream &s) const;
-  void dumpUnlinked(ostream &s) const;
-  void dumpTargetHits(ostream &s) const;
+  const std::list<TargetHit> &getTargetHits(void) const { return targethits; }
+  void dumpModelHits(std::ostream &s) const;
+  void dumpCrossRefs(std::ostream &s) const;
+  void dumpFunctionStarts(std::ostream &s) const;
+  void dumpUnlinked(std::ostream &s) const;
+  void dumpTargetHits(std::ostream &s) const;
   void runModel(void);
 };
 
@@ -150,48 +150,48 @@ class IfaceCodeDataCommand : public IfaceCommand {
   CodeDataAnalysis *codedata;
 public:
   virtual void setData(IfaceStatus *root,IfaceData *data);
-  virtual string getModule(void) const { return "codedata"; }
+  virtual std::string getModule(void) const { return "codedata"; }
   virtual IfaceData *createData(void) { return new CodeDataAnalysis(); }
 };
 
 class IfcCodeDataInit : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataTarget : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataRun : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataDumpModelHits : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataDumpCrossRefs : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataDumpStarts : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataDumpUnlinked : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCodeDataDumpTargetHits : public IfaceCodeDataCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
index b5bc0a16d..e495b734e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.cc
@@ -16,6 +16,8 @@
 #include "comment.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 ElementId ELEM_COMMENT = ElementId("comment",86);
 ElementId ELEM_COMMENTDB = ElementId("commentdb",87);
 ElementId ELEM_TEXT = ElementId("text",88);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.hh
index b2be60f0f..49d4e1950 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/comment.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/comment.hh
@@ -44,7 +44,7 @@ class Comment {
   int4 uniq;			///< Sub-identifier for uniqueness
   Address funcaddr;		///< Address of the function containing the comment
   Address addr;			///< Address associated with the comment
-  string text;			///< The body of the comment
+  std::string text;			///< The body of the comment
   mutable bool emitted;		///< \b true if this comment has already been emitted
 public:
   /// \brief Possible properties associated with a comment
@@ -56,7 +56,7 @@ class Comment {
     warning = 16,		///< The comment is auto-generated to alert the user
     warningheader = 32		///< The comment is auto-generated and should be in the header
   };
-  Comment(uint4 tp,const Address &fad,const Address &ad,int4 uq,const string &txt);	///< Constructor
+  Comment(uint4 tp,const Address &fad,const Address &ad,int4 uq,const std::string &txt);	///< Constructor
   Comment(void) {} 	///< Constructor for use with decode
   void setEmitted(bool val) const { emitted = val; }		///< Mark that \b this comment has been emitted
   bool isEmitted(void) const { return emitted; }		///< Return \b true if \b this comment is already emitted
@@ -64,11 +64,11 @@ class Comment {
   const Address &getFuncAddr(void) const { return funcaddr; }	///< Get the address of the function containing the comment
   const Address &getAddr(void) const { return addr; }		///< Get the address to which the instruction is attached
   int4 getUniq(void) const { return uniq; }			///< Get the sub-sorting index
-  const string &getText(void) const { return text; }		///< Get the body of the comment
+  const std::string &getText(void) const { return text; }		///< Get the body of the comment
   void encode(Encoder &encoder) const;				///< Encode the comment to a stream
   void decode(Decoder &decoder);				///< Restore the comment from XML
-  static uint4 encodeCommentType(const string &name);		///< Convert name string to comment property
-  static string decodeCommentType(uint4 val);			///< Convert comment property to string
+  static uint4 encodeCommentType(const std::string &name);		///< Convert name string to comment property
+  static std::string decodeCommentType(uint4 val);			///< Convert comment property to string
 };
 
 /// \brief Compare two Comment pointers
@@ -79,7 +79,7 @@ struct CommentOrder {
   bool operator()(const Comment *a,const Comment *b) const;	///< Comparison operator
 };
 
-typedef set<Comment *,CommentOrder> CommentSet;		///< A set of comments sorted by function and address
+typedef std::set<Comment *,CommentOrder> CommentSet;		///< A set of comments sorted by function and address
 
 /// \brief An interface to a container of comments
 ///
@@ -108,7 +108,7 @@ class CommentDatabase {
   /// \param ad is the address to which the comment is attached
   /// \param txt is the body of the comment
   virtual void addComment(uint4 tp,const Address &fad,
-			  const Address &ad,const string &txt)=0;
+			  const Address &ad,const std::string &txt)=0;
 
   /// \brief Add a new comment to the container, making sure there is no duplicate
   ///
@@ -119,7 +119,7 @@ class CommentDatabase {
   /// \param ad is the address to which the comment is attached
   /// \param txt is the body of the comment
   /// \return \b true if a new Comment was created, \b false if there was a duplicate
-  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const string &txt)=0;
+  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const std::string &txt)=0;
 
   /// \brief Remove the given Comment object from the container
   ///
@@ -164,8 +164,8 @@ class CommentDatabaseInternal : public CommentDatabase {
   virtual void clear(void);
   virtual void clearType(const Address &fad,uint4 tp);
   virtual void addComment(uint4 tp,const Address &fad,
-			  const Address &ad,const string &txt);
-  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const string &txt);
+			  const Address &ad,const std::string &txt);
+  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const std::string &txt);
   virtual void deleteComment(Comment *com);
   virtual CommentSet::const_iterator beginComment(const Address &fad) const;
   virtual CommentSet::const_iterator endComment(const Address &fad) const;
@@ -233,10 +233,10 @@ class CommentSorter {
       order = ord;
     }
   };
-  map<Subsort,Comment *> commmap;			///< Comments for the current function, sorted by block
-  mutable map<Subsort,Comment *>::const_iterator start;	///< Iterator to current comment being walked
-  map<Subsort,Comment *>::const_iterator stop;		///< Last comment in current set being walked
-  map<Subsort,Comment *>::const_iterator opstop;	///< Statement landmark within current set of comments
+  std::map<Subsort,Comment *> commmap;			///< Comments for the current function, sorted by block
+  mutable std::map<Subsort,Comment *>::const_iterator start;	///< Iterator to current comment being walked
+  std::map<Subsort,Comment *>::const_iterator stop;		///< Last comment in current set being walked
+  std::map<Subsort,Comment *>::const_iterator opstop;	///< Statement landmark within current set of comments
   bool displayUnplacedComments;				///< True if unplaced comments should be displayed (in the header)
   bool findPosition(Subsort &subsort,Comment *comm,const Funcdata *fd);	///< Establish sorting key for a Comment
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.cc
index 04a4c2cf0..2ba980fc0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "comment_ghidra.hh"
 
+using namespace std;
+
 CommentDatabaseGhidra::CommentDatabaseGhidra(ArchitectureGhidra *g)
   : CommentDatabase()
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.hh
index c0dc59c89..0ed0def99 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/comment_ghidra.hh
@@ -39,8 +39,8 @@ class CommentDatabaseGhidra : public CommentDatabase {
     cache.clearType(fad,tp);
   }
   virtual void addComment(uint4 tp,const Address &fad,
-			  const Address &ad,const string &txt);
-  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const string &txt);
+			  const Address &ad,const std::string &txt);
+  virtual bool addCommentNoDuplicate(uint4 tp,const Address &fad,const Address &ad,const std::string &txt);
   virtual void deleteComment(Comment *com) {
     throw LowlevelError("deleteComment unimplemented"); }
   virtual CommentSet::const_iterator beginComment(const Address &fad) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
index 962f35d5d..0c41bb363 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
@@ -15,6 +15,8 @@
  */
 #include "condexe.hh"
 
+using namespace std;
+
 ConditionMarker::ConditionMarker(void)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.hh
index bf2e54615..8d479c3ed 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.hh
@@ -141,9 +141,9 @@ class ConditionalExecution {
   BlockBasic *posta_block;	///< First block in posta path
   BlockBasic *postb_block;	///< First block in postb path
   bool directsplit;		///< True if this the \e direct \e split variation
-  map<int4,Varnode *> replacement;	///< Map from block to replacement Varnode for (current) Varnode
-  vector<PcodeOp *> returnop;	///< RETURN ops that have flow coming out of the iblock
-  vector<bool> heritageyes;	///< Boolean array indexed by address space indicating whether the space is heritaged
+  std::map<int4,Varnode *> replacement;	///< Map from block to replacement Varnode for (current) Varnode
+  std::vector<PcodeOp *> returnop;	///< RETURN ops that have flow coming out of the iblock
+  std::vector<bool> heritageyes;	///< Boolean array indexed by address space indicating whether the space is heritaged
 
   void buildHeritageArray(void);
   bool testIBlock(void);
@@ -171,7 +171,7 @@ class ConditionalExecution {
 /// that repeatedly branches on the same (or slightly modified) boolean expression.
 class ActionConditionalExe : public Action {
 public:
-  ActionConditionalExe(const string &g) : Action(0,"conditionalexe",g) {}	///< Constructor
+  ActionConditionalExe(const std::string &g) : Action(0,"conditionalexe",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionConditionalExe(getGroup());
@@ -225,12 +225,12 @@ class RuleOrPredicate : public Rule {
   };
   int4 checkSingle(Varnode *vn,MultiPredicate &branch,PcodeOp *op,Funcdata &data);
 public:
-  RuleOrPredicate(const string &g) : Rule(g, 0, "orpredicate") {}	///< Constructor
+  RuleOrPredicate(const std::string &g) : Rule(g, 0, "orpredicate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleOrPredicate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/consolemain.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/consolemain.cc
index f40f3dd66..c4a628228 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/consolemain.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/consolemain.cc
@@ -18,6 +18,8 @@
 
 #include "libdecomp.hh"
 
+using namespace std;
+
 class IfcLoadFile : public IfaceDecompCommand {
 public:
   virtual void execute(istream &s);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/context.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/context.cc
index 51157f3a7..19ab8ddfa 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/context.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/context.cc
@@ -17,6 +17,8 @@
 #include "slghsymbol.hh"
 #include "translate.hh"
 
+using namespace std;
+
 ParserContext::ParserContext(ContextCache *ccache,Translate *trans)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
index 8ae7012a6..5f00991fc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/context.hh
@@ -20,16 +20,16 @@
 #include "opcodes.hh"
 
 class Token {			// A multiple-byte sized chunk of pattern in a bitstream
-  string name;
+  std::string name;
   int4 size;			// Number of bytes in token;
   int4 index;			// Index of this token, for resolving offsets
   bool bigendian;
 public:
-  Token(const string &nm,int4 sz,bool be,int4 ind) : name(nm) { size = sz; bigendian=be; index = ind; }
+  Token(const std::string &nm,int4 sz,bool be,int4 ind) : name(nm) { size = sz; bigendian=be; index = ind; }
   int4 getSize(void) const { return size; }
   bool isBigEndian(void) const { return bigendian; }
   int4 getIndex(void) const { return index; }
-  const string &getName(void) const { return name; }
+  const std::string &getName(void) const { return name; }
 };
 
 struct FixedHandle {		// A handle that is fully resolved
@@ -46,7 +46,7 @@ class Constructor;
 struct ConstructState {
   Constructor *ct;
   FixedHandle hand;
-  vector<ConstructState *> resolve;
+  std::vector<ConstructState *> resolve;
   ConstructState *parent;
   int4 length;			// Length of this instantiation of the constructor
   uint4 offset;			// Absolute offset (from start of instruction)
@@ -83,12 +83,12 @@ class ParserContext {
   uintm *context;		// Pointer to local context
   int4 contextsize;		// Number of entries in context array
   ContextCache *contcache;   // Interface for getting/setting context
-  vector<ContextSet> contextcommit;
+  std::vector<ContextSet> contextcommit;
   Address addr;		// Address of start of instruction
   Address naddr;		// Address of next instruction
   mutable Address n2addr;	// Address of instruction after the next
   Address calladdr;		// For injections, this is the address of the call being overridden
-  vector<ConstructState> state; // Current resolved instruction
+  std::vector<ConstructState> state; // Current resolved instruction
   ConstructState *base_state;
   int4 alloc;			// Number of ConstructState's allocated
   int4 delayslot;		// delayslot depth
@@ -179,7 +179,7 @@ class ParserWalkerChange : public ParserWalker { // Extension to walker that all
 };
 
 struct SleighError : public LowlevelError {
-  SleighError(const string &s) : LowlevelError(s) {}
+  SleighError(const std::string &s) : LowlevelError(s) {}
 };
 
 inline void ParserContext::deallocateState(ParserWalkerChange &walker) {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
index a4c6b71fc..dfe23cf03 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
@@ -18,6 +18,8 @@
 #include "double.hh"
 #include "subflow.hh"
 
+using namespace std;
+
 /// \brief A stack equation
 struct StackEqn {
   int4 var1;			///< Variable with 1 coefficient
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
index 2f4c94921..7ef1e69ff 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.hh
@@ -31,7 +31,7 @@
 /// \brief Gather raw p-code for a function.
 class ActionStart : public Action {
 public:
-  ActionStart(const string &g) : Action(0,"start",g) {}		///< Constructor
+  ActionStart(const std::string &g) : Action(0,"start",g) {}		///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionStart(getGroup());
@@ -43,7 +43,7 @@ class ActionStart : public Action {
 /// \brief Do any post-processing after decompilation
 class ActionStop : public Action {
 public:
-  ActionStop(const string &g) : Action(0,"stop",g) {}		///< Constructor
+  ActionStop(const std::string &g) : Action(0,"stop",g) {}		///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionStop(getGroup());
@@ -55,7 +55,7 @@ class ActionStop : public Action {
 /// \brief Start clean up after main transform phase
 class ActionStartCleanUp : public Action {
 public:
-  ActionStartCleanUp(const string &g) : Action(0,"startcleanup",g) {}	///< Constructor
+  ActionStartCleanUp(const std::string &g) : Action(0,"startcleanup",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionStartCleanUp(getGroup());
@@ -71,7 +71,7 @@ class ActionStartCleanUp : public Action {
 /// that data-type analysis has started.
 class ActionStartTypes : public Action {
 public:
-  ActionStartTypes(const string &g) : Action(0,"starttypes",g) {}	///< Constructor
+  ActionStartTypes(const std::string &g) : Action(0,"starttypes",g) {}	///< Constructor
   virtual void reset(Funcdata &data) { data.setTypeRecovery(true); }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -93,7 +93,7 @@ class ActionStackPtrFlow : public Action {
   static int4 repair(Funcdata &data,AddrSpace *id,Varnode *spcbasein,PcodeOp *loadop,uintb constz);
   static int4 checkClog(Funcdata &data,AddrSpace *id,int4 spcbase);
 public:
-  ActionStackPtrFlow(const string &g,AddrSpace *ss) : Action(0,"stackptrflow",g) { stackspace = ss; }	///<Constructor
+  ActionStackPtrFlow(const std::string &g,AddrSpace *ss) : Action(0,"stackptrflow",g) { stackspace = ss; }	///<Constructor
   virtual void reset(Funcdata &data) { analysis_finished = false; }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -112,7 +112,7 @@ class ActionLaneDivide : public Action {
   void collectLaneSizes(Varnode *vn,const LanedRegister &allowedLanes,LanedRegister &checkLanes);
   bool processVarnode(Funcdata &data,Varnode *vn,const LanedRegister &lanedRegister,int4 mode);
 public:
-  ActionLaneDivide(const string &g) : Action(rule_onceperfunc,"lanedivide",g) {}	///< Constructor
+  ActionLaneDivide(const std::string &g) : Action(rule_onceperfunc,"lanedivide",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionLaneDivide(getGroup());
@@ -126,7 +126,7 @@ class ActionLaneDivide : public Action {
 class ActionSegmentize : public Action {
   int4 localcount;			///< Number of times this Action has been performed on the function
 public:
-  ActionSegmentize(const string &g) : Action(0,"segmentize",g) {}	///< Constructor
+  ActionSegmentize(const std::string &g) : Action(0,"segmentize",g) {}	///< Constructor
   virtual void reset(Funcdata &data) { localcount = 0; }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -138,7 +138,7 @@ class ActionSegmentize : public Action {
 /// \brief Apply any overridden forced gotos
 class ActionForceGoto : public Action {
 public:
-  ActionForceGoto(const string &g) : Action(0,"forcegoto",g) {}		///< Constructor
+  ActionForceGoto(const std::string &g) : Action(0,"forcegoto",g) {}		///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionForceGoto(getGroup());
@@ -149,7 +149,7 @@ class ActionForceGoto : public Action {
 // \brief Perform common subexpression elimination
 // class ActionCse : public Action {
 // public:
-//   ActionCse(const string &g) : Action(0,"cse",g) {}			///< Constructor
+//   ActionCse(const std::string &g) : Action(0,"cse",g) {}			///< Constructor
 //   virtual Action *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Action *)0;
 //     return new ActionCse(getGroup());
@@ -163,7 +163,7 @@ class ActionMultiCse : public Action {
   static PcodeOp *findMatch(BlockBasic *bl,PcodeOp *target,Varnode *in);	///< Find match to CPUI_MULTIEQUAL
   bool processBlock(Funcdata &data,BlockBasic *bl);		///< Search a block for equivalent CPUI_MULTIEQUAL
 public:
-  ActionMultiCse(const string &g) : Action(0,"multicse",g) {}	///< Constructor
+  ActionMultiCse(const std::string &g) : Action(0,"multicse",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMultiCse(getGroup());
@@ -174,7 +174,7 @@ class ActionMultiCse : public Action {
 /// \brief Check for one CPUI_MULTIEQUAL input set defining more than one Varnode
 class ActionShadowVar : public Action {
 public:
-  ActionShadowVar(const string &g) : Action(0,"shadowvar",g) {}	///< Constructor
+  ActionShadowVar(const std::string &g) : Action(0,"shadowvar",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionShadowVar(getGroup());
@@ -186,11 +186,11 @@ class ActionShadowVar : public Action {
 class ActionConstantPtr : public Action {
   int4 localcount;		///< Number of passes made for this function
   static AddrSpace *searchForSpaceAttribute(Varnode *vn,PcodeOp *op);
-  static AddrSpace *selectInferSpace(Varnode *vn,PcodeOp *op,const vector<AddrSpace *> &spaceList);
+  static AddrSpace *selectInferSpace(Varnode *vn,PcodeOp *op,const std::vector<AddrSpace *> &spaceList);
   static SymbolEntry *isPointer(AddrSpace *spc,Varnode *vn,PcodeOp *op,int4 slot,
 				Address &rampoint,uintb &fullEncoding,Funcdata &data);
 public:
-  ActionConstantPtr(const string &g) : Action(0,"constantptr",g) {}	///< Constructor
+  ActionConstantPtr(const std::string &g) : Action(0,"constantptr",g) {}	///< Constructor
   virtual void reset(Funcdata &data) { localcount = 0; }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -202,7 +202,7 @@ class ActionConstantPtr : public Action {
 /// \brief Eliminate locally constant indirect calls
 class ActionDeindirect : public Action {
 public:
-  ActionDeindirect(const string &g) : Action(0,"deindirect",g) {}	///< Constructor
+  ActionDeindirect(const std::string &g) : Action(0,"deindirect",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDeindirect(getGroup());
@@ -218,7 +218,7 @@ class ActionDeindirect : public Action {
 ///   - Varnodes whose values are not consumed are replaced with constant 0 Varnodes
 class ActionVarnodeProps : public Action {
 public:
-  ActionVarnodeProps(const string &g) : Action(0,"varnodeprops",g) {}	///< Constructor
+  ActionVarnodeProps(const std::string &g) : Action(0,"varnodeprops",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionVarnodeProps(getGroup());
@@ -240,7 +240,7 @@ class ActionVarnodeProps : public Action {
 class ActionDirectWrite : public Action {
   bool propagateIndirect;			///< Propagate thru CPUI_INDIRECT ops
 public:
-  ActionDirectWrite(const string &g,bool prop) : Action(0,"directwrite",g) { propagateIndirect=prop; }	///< Constructor
+  ActionDirectWrite(const std::string &g,bool prop) : Action(0,"directwrite",g) { propagateIndirect=prop; }	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDirectWrite(getGroup(),propagateIndirect);
@@ -255,7 +255,7 @@ class ActionDirectWrite : public Action {
 /// user has provided a constant value for.
 class ActionConstbase : public Action {
 public:
-  ActionConstbase(const string &g) : Action(0,"constbase",g) {}	///< Constructor
+  ActionConstbase(const std::string &g) : Action(0,"constbase",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionConstbase(getGroup());
@@ -266,7 +266,7 @@ class ActionConstbase : public Action {
 /// \brief Mark Varnode objects that hold stack-pointer values and set-up special data-type
 class ActionSpacebase : public Action {
 public:
-  ActionSpacebase(const string &g) : Action(0,"spacebase",g) {}	///< Constructor
+  ActionSpacebase(const std::string &g) : Action(0,"spacebase",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionSpacebase(getGroup());
@@ -278,7 +278,7 @@ class ActionSpacebase : public Action {
 /// \brief Build Static Single Assignment (SSA) representation for function
 class ActionHeritage : public Action {
 public:
-  ActionHeritage(const string &g) : Action(0,"heritage",g) {}	///< Constructor
+  ActionHeritage(const std::string &g) : Action(0,"heritage",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionHeritage(getGroup());
@@ -289,7 +289,7 @@ class ActionHeritage : public Action {
 /// \brief Calculate the non-zero mask property on all Varnode objects.
 class ActionNonzeroMask : public Action {
 public:
-  ActionNonzeroMask(const string &g) : Action(0,"nonzeromask",g) {}	///< Constructor
+  ActionNonzeroMask(const std::string &g) : Action(0,"nonzeromask",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionNonzeroMask(getGroup());
@@ -324,7 +324,7 @@ class ActionSetCasts : public Action {
   static int4 castInput(PcodeOp *op,int4 slot,Funcdata &data,CastStrategy *castStrategy);
   static PcodeOp *insertPtrsubZero(PcodeOp *op,int4 slot,Datatype *ct,Funcdata &data);
 public:
-  ActionSetCasts(const string &g) : Action(rule_onceperfunc,"setcasts",g) {}	///< Constructor
+  ActionSetCasts(const std::string &g) : Action(rule_onceperfunc,"setcasts",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionSetCasts(getGroup());
@@ -335,7 +335,7 @@ class ActionSetCasts : public Action {
 /// \brief Assign initial high-level HighVariable objects to each Varnode
 class ActionAssignHigh : public Action {
 public:
-  ActionAssignHigh(const string &g) : Action(rule_onceperfunc,"assignhigh",g) {}	///< Constructor
+  ActionAssignHigh(const std::string &g) : Action(rule_onceperfunc,"assignhigh",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionAssignHigh(getGroup());
@@ -346,7 +346,7 @@ class ActionAssignHigh : public Action {
 /// \brief Mark illegal Varnode inputs used only in CPUI_INDIRECT ops
 class ActionMarkIndirectOnly : public Action {
 public:
-  ActionMarkIndirectOnly(const string &g) : Action(rule_onceperfunc, "markindirectonly",g) {}	///< Constructor
+  ActionMarkIndirectOnly(const std::string &g) : Action(rule_onceperfunc, "markindirectonly",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMarkIndirectOnly(getGroup());
@@ -358,7 +358,7 @@ class ActionMarkIndirectOnly : public Action {
 /// \brief Make \e required Varnode merges as dictated by CPUI_MULTIEQUAL, CPUI_INDIRECT, and \e addrtied property
 class ActionMergeRequired : public Action {
 public:
-  ActionMergeRequired(const string &g) : Action(rule_onceperfunc,"mergerequired",g) {}	///< Constructor
+  ActionMergeRequired(const std::string &g) : Action(rule_onceperfunc,"mergerequired",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMergeRequired(getGroup());
@@ -370,7 +370,7 @@ class ActionMergeRequired : public Action {
 /// \brief Try to merge an op's input Varnode to its output, if they are at the same storage location.
 class ActionMergeAdjacent : public Action {
 public:
-  ActionMergeAdjacent(const string &g) : Action(rule_onceperfunc,"mergeadjacent",g) {}	///< Constructor
+  ActionMergeAdjacent(const std::string &g) : Action(rule_onceperfunc,"mergeadjacent",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMergeAdjacent(getGroup());
@@ -381,7 +381,7 @@ class ActionMergeAdjacent : public Action {
 /// \brief Try to merge the input and output Varnodes of a CPUI_COPY op
 class ActionMergeCopy : public Action {
 public:
-  ActionMergeCopy(const string &g) : Action(rule_onceperfunc,"mergecopy",g) {}	///< Constructor
+  ActionMergeCopy(const std::string &g) : Action(rule_onceperfunc,"mergecopy",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMergeCopy(getGroup());
@@ -392,7 +392,7 @@ class ActionMergeCopy : public Action {
 /// \brief Try to merge Varnodes specified by Symbols with multiple SymbolEntrys
 class ActionMergeMultiEntry : public Action {
 public:
-  ActionMergeMultiEntry(const string &g) : Action(rule_onceperfunc,"mergemultientry",g) {}	///< Constructor
+  ActionMergeMultiEntry(const std::string &g) : Action(rule_onceperfunc,"mergemultientry",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMergeMultiEntry(getGroup());
@@ -403,7 +403,7 @@ class ActionMergeMultiEntry : public Action {
 /// \brief Try to merge Varnodes of the same type (if they don't hold different values at the same time)
 class ActionMergeType : public Action {
 public:
-  ActionMergeType(const string &g) : Action(rule_onceperfunc,"mergetype",g) {}	///< Constructor
+  ActionMergeType(const std::string &g) : Action(rule_onceperfunc,"mergetype",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMergeType(getGroup());
@@ -430,11 +430,11 @@ class ActionMarkExplicit : public Action {
     OpStackElement(Varnode *v);	///< Constructor
   };
   static int4 baseExplicit(Varnode *vn,int4 maxref);	///< Make initial determination if a Varnode should be \e explicit
-  static int4 multipleInteraction(vector<Varnode *> &multlist);	///< Find multiple descendant chains
+  static int4 multipleInteraction(std::vector<Varnode *> &multlist);	///< Find multiple descendant chains
   static void processMultiplier(Varnode *vn,int4 max);	///< For a given multi-descendant Varnode, decide if it should be explicit
   static void checkNewToConstructor(Funcdata &data,Varnode *vn);	///< Set special properties on output of CPUI_NEW
 public:
-  ActionMarkExplicit(const string &g) : Action(rule_onceperfunc,"markexplicit",g) {}	///< Constructor
+  ActionMarkExplicit(const std::string &g) : Action(rule_onceperfunc,"markexplicit",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMarkExplicit(getGroup());
@@ -447,7 +447,7 @@ class ActionMarkImplied : public Action {
   /// This class holds a single entry in a stack used to forward traverse Varnode expressions
   struct DescTreeElement {
     Varnode *vn;				///< The Varnode at this particular point in the path
-    list<PcodeOp *>::const_iterator desciter;	///< The current edge being traversed
+    std::list<PcodeOp *>::const_iterator desciter;	///< The current edge being traversed
     DescTreeElement(Varnode *v) {
       vn = v; desciter = v->beginDescend(); }	///< Constructor
   };
@@ -455,7 +455,7 @@ class ActionMarkImplied : public Action {
   static bool isPossibleAlias(Varnode *vn1,Varnode *vn2,int4 depth);	///< Check for possible duplicate value
   static bool checkImpliedCover(Funcdata &data,Varnode *vn);	///< Check for cover violation if Varnode is implied
 public:
-  ActionMarkImplied(const string &g) : Action(rule_onceperfunc,"markimplied",g) {}	///< Constructor
+  ActionMarkImplied(const std::string &g) : Action(rule_onceperfunc,"markimplied",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMarkImplied(getGroup());
@@ -468,15 +468,15 @@ class ActionNameVars : public Action {
   /// This class is a record in a database used to store and lookup potential names
   struct OpRecommend {
     Datatype *ct;		///< The data-type associated with a name
-    string namerec;		///< A possible name for a variable
+    std::string namerec;		///< A possible name for a variable
   };
-  static void makeRec(ProtoParameter *param,Varnode *vn,map<HighVariable *,OpRecommend> &recmap);
+  static void makeRec(ProtoParameter *param,Varnode *vn,std::map<HighVariable *,OpRecommend> &recmap);
   static void lookForBadJumpTables(Funcdata &data);	///< Mark the switch variable for bad jump-tables
-  static void lookForFuncParamNames(Funcdata &data,const vector<Varnode *> &varlist);
-  static void linkSpacebaseSymbol(Varnode *vn,Funcdata &data,vector<Varnode *> &namerec);
-  static void linkSymbols(Funcdata &data,vector<Varnode *> &namerec);
+  static void lookForFuncParamNames(Funcdata &data,const std::vector<Varnode *> &varlist);
+  static void linkSpacebaseSymbol(Varnode *vn,Funcdata &data,std::vector<Varnode *> &namerec);
+  static void linkSymbols(Funcdata &data,std::vector<Varnode *> &namerec);
 public:
-  ActionNameVars(const string &g) : Action(rule_onceperfunc,"namevars",g) {}	///< Constructor
+  ActionNameVars(const std::string &g) : Action(rule_onceperfunc,"namevars",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionNameVars(getGroup());
@@ -487,7 +487,7 @@ class ActionNameVars : public Action {
 /// \brief Remove unreachable blocks
 class ActionUnreachable : public Action {
 public:
-  ActionUnreachable(const string &g) : Action(0,"unreachable",g) {}	///< Constructor
+  ActionUnreachable(const std::string &g) : Action(0,"unreachable",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionUnreachable(getGroup());
@@ -498,7 +498,7 @@ class ActionUnreachable : public Action {
 /// \brief Remove blocks that do nothing
 class ActionDoNothing : public Action {
 public:
-  ActionDoNothing(const string &g) : Action(rule_repeatapply,"donothing",g) {}	///< Constructor
+  ActionDoNothing(const std::string &g) : Action(rule_repeatapply,"donothing",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDoNothing(getGroup());
@@ -509,7 +509,7 @@ class ActionDoNothing : public Action {
 /// \brief Get rid of \b redundant branches: duplicate edges between the same input and output block
 class ActionRedundBranch : public Action {
 public:
-  ActionRedundBranch(const string &g) : Action(0,"redundbranch",g) {}	///< Constructor
+  ActionRedundBranch(const std::string &g) : Action(0,"redundbranch",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionRedundBranch(getGroup());
@@ -520,7 +520,7 @@ class ActionRedundBranch : public Action {
 /// \brief Remove conditional branches if the condition is constant
 class ActionDeterminedBranch : public Action {
 public:
-  ActionDeterminedBranch(const string &g) : Action(0,"determinedbranch",g) {}	///< Constructor
+  ActionDeterminedBranch(const std::string &g) : Action(0,"determinedbranch",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDeterminedBranch(getGroup());
@@ -547,15 +547,15 @@ class ActionDeterminedBranch : public Action {
 /// the particular op being passed through can transform the
 /// "bit usage" vector of the output to obtain the input.
 class ActionDeadCode : public Action {
-  static void pushConsumed(uintb val,Varnode *vn,vector<Varnode *> &worklist);
-  static void propagateConsumed(vector<Varnode *> &worklist);
+  static void pushConsumed(uintb val,Varnode *vn,std::vector<Varnode *> &worklist);
+  static void propagateConsumed(std::vector<Varnode *> &worklist);
   static bool neverConsumed(Varnode *vn,Funcdata &data);
-  static void markConsumedParameters(FuncCallSpecs *fc,vector<Varnode *> &worklist);
+  static void markConsumedParameters(FuncCallSpecs *fc,std::vector<Varnode *> &worklist);
   static uintb gatherConsumedReturn(Funcdata &data);
   static bool isEventualConstant(Varnode *vn,int4 addCount,int4 loadCount);
-  static bool lastChanceLoad(Funcdata &data,vector<Varnode *> &worklist);
+  static bool lastChanceLoad(Funcdata &data,std::vector<Varnode *> &worklist);
 public:
-  ActionDeadCode(const string &g) : Action(0,"deadcode",g) {}	///< Constructor
+  ActionDeadCode(const std::string &g) : Action(0,"deadcode",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDeadCode(getGroup());
@@ -566,7 +566,7 @@ class ActionDeadCode : public Action {
 /// \brief Propagate conditional constants
 class ActionConditionalConst : public Action {
 public:
-  ActionConditionalConst(const string &g) : Action(0,"condconst",g) {}	///< Constructor
+  ActionConditionalConst(const std::string &g) : Action(0,"condconst",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionConditionalConst(getGroup());
@@ -581,7 +581,7 @@ class ActionConditionalConst : public Action {
 /// the \b switch action. The case labels are also calculated based on the normalization.
 class ActionSwitchNorm : public Action {
 public:
-  ActionSwitchNorm(const string &g) : Action(0,"switchnorm",g) {}	///< Constructor
+  ActionSwitchNorm(const std::string &g) : Action(0,"switchnorm",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionSwitchNorm(getGroup());
@@ -602,7 +602,7 @@ class ActionSwitchNorm : public Action {
 /// Similarly there should be no lock on the output and no lock on the prototype model
 class ActionNormalizeSetup : public Action {
 public:
-  ActionNormalizeSetup(const string &g) : Action(rule_onceperfunc,"normalizesetup",g) {}	///< Constructor
+  ActionNormalizeSetup(const std::string &g) : Action(rule_onceperfunc,"normalizesetup",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionNormalizeSetup(getGroup());
@@ -618,7 +618,7 @@ class ActionNormalizeSetup : public Action {
 class ActionPrototypeTypes: public Action {
 public:
   void extendInput(Funcdata &data,Varnode *invn,ProtoParameter *param,BlockBasic *topbl);
-  ActionPrototypeTypes(const string &g) : Action(rule_onceperfunc,"prototypetypes",g) {}	///< Constructor
+  ActionPrototypeTypes(const std::string &g) : Action(rule_onceperfunc,"prototypetypes",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionPrototypeTypes(getGroup());
@@ -633,7 +633,7 @@ class ActionPrototypeTypes: public Action {
 /// \e uponreturn injection, the p-code is injected at this time.
 class ActionDefaultParams : public Action {
 public:
-  ActionDefaultParams(const string &g) : Action(rule_onceperfunc,"defaultparams",g) {}	///< Constructor
+  ActionDefaultParams(const std::string &g) : Action(rule_onceperfunc,"defaultparams",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDefaultParams(getGroup());
@@ -651,7 +651,7 @@ class ActionDefaultParams : public Action {
 class ActionExtraPopSetup : public Action {
   AddrSpace *stackspace;		///< The stack space to analyze
 public:
-  ActionExtraPopSetup(const string &g,AddrSpace *ss) : Action(rule_onceperfunc,"extrapopsetup",g) { stackspace = ss; }	///< Constructor
+  ActionExtraPopSetup(const std::string &g,AddrSpace *ss) : Action(rule_onceperfunc,"extrapopsetup",g) { stackspace = ss; }	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionExtraPopSetup(getGroup(),stackspace);
@@ -669,7 +669,7 @@ class ActionFuncLink : public Action {
   static void funcLinkInput(FuncCallSpecs *fc,Funcdata &data);
   static void funcLinkOutput(FuncCallSpecs *fc,Funcdata &data);
 public:
-  ActionFuncLink(const string &g) : Action(rule_onceperfunc,"funclink",g) {}	///< Constructor
+  ActionFuncLink(const std::string &g) : Action(rule_onceperfunc,"funclink",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionFuncLink(getGroup());
@@ -687,7 +687,7 @@ class ActionFuncLink : public Action {
 /// don't care about the function inputs.
 class ActionFuncLinkOutOnly : public Action {
 public:
-  ActionFuncLinkOutOnly(const string &g) : Action(rule_onceperfunc,"funclink_outonly",g) {}	///< Constructor
+  ActionFuncLinkOutOnly(const std::string &g) : Action(rule_onceperfunc,"funclink_outonly",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionFuncLinkOutOnly(getGroup());
@@ -704,7 +704,7 @@ class ActionFuncLinkOutOnly : public Action {
 ///         sure the pieces are properly labeled.
 class ActionParamDouble : public Action {
 public:
-  ActionParamDouble(const string &g) : Action(0, "paramdouble",g) {}	///< Constructor
+  ActionParamDouble(const std::string &g) : Action(0, "paramdouble",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionParamDouble(getGroup());
@@ -722,7 +722,7 @@ class ActionParamDouble : public Action {
 /// but \b before any simplification or copy propagation has been performed.
 class ActionActiveParam : public Action {
 public:
-  ActionActiveParam(const string &g) : Action( 0, "activeparam",g) {}	///< Constructor
+  ActionActiveParam(const std::string &g) : Action( 0, "activeparam",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionActiveParam(getGroup());
@@ -735,7 +735,7 @@ class ActionActiveParam : public Action {
 /// This is analogous to ActionActiveParam but for sub-function return values.
 class ActionActiveReturn : public Action {
 public:
-  ActionActiveReturn(const string &g) : Action( 0, "activereturn",g) {}	///< Constructor
+  ActionActiveReturn(const std::string &g) : Action( 0, "activereturn",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionActiveReturn(getGroup());
@@ -746,7 +746,7 @@ class ActionActiveReturn : public Action {
 // \brief If there are any sub-function calls with \e paramshifts, add the shifted parameters.
 // class ActionParamShiftStart : public Action {
 // public:
-//   ActionParamShiftStart(const string &g) : Action( rule_onceperfunc, "paramshiftstart",g) {}	///< Constructor
+//   ActionParamShiftStart(const std::string &g) : Action( rule_onceperfunc, "paramshiftstart",g) {}	///< Constructor
 //   virtual Action *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Action *)0;
 //     return new ActionParamShiftStart(getGroup());
@@ -758,7 +758,7 @@ class ActionActiveReturn : public Action {
 // class ActionParamShiftStop : public Action {
 //   bool paramshiftsleft;
 // public:
-//   ActionParamShiftStop(const string &g) : Action( 0, "paramshiftstop",g) {}	///< Constructor
+//   ActionParamShiftStop(const std::string &g) : Action( 0, "paramshiftstop",g) {}	///< Constructor
 //   virtual void reset(Funcdata &data) { paramshiftsleft = true; }
 //   virtual Action *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -771,7 +771,7 @@ class ActionActiveReturn : public Action {
 class ActionReturnRecovery : public Action {
   static void buildReturnOutput(ParamActive *active,PcodeOp *retop,Funcdata &data);
 public:
-  ActionReturnRecovery(const string &g) : Action( 0, "returnrecovery",g) {}	///< Constructor
+  ActionReturnRecovery(const std::string &g) : Action( 0, "returnrecovery",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionReturnRecovery(getGroup());
@@ -785,7 +785,7 @@ class ActionReturnRecovery : public Action {
 /// so that they cannot be treated as local variables.
 class ActionRestrictLocal : public Action {
 public:
-  ActionRestrictLocal(const string &g) : Action(0,"restrictlocal",g) {}	///< Constructor
+  ActionRestrictLocal(const std::string &g) : Action(0,"restrictlocal",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionRestrictLocal(getGroup());
@@ -807,9 +807,9 @@ class ActionRestrictLocal : public Action {
 /// allows the spurious references to the register to be removed.
 class ActionLikelyTrash : public Action {
   static uint4 countMarks(PcodeOp *op);
-  static bool traceTrash(Varnode *vn,vector<PcodeOp *> &indlist);
+  static bool traceTrash(Varnode *vn,std::vector<PcodeOp *> &indlist);
 public:
-  ActionLikelyTrash(const string &g) : Action(0,"likelytrash",g) {}	///< Constructor
+  ActionLikelyTrash(const std::string &g) : Action(0,"likelytrash",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionLikelyTrash(getGroup());
@@ -823,7 +823,7 @@ class ActionLikelyTrash : public Action {
 class ActionRestructureVarnode : public Action {
   int4 numpass;			///< Number of passes performed for this function
 public:
-  ActionRestructureVarnode(const string &g) : Action(0,"restructure_varnode",g) {}	///< Constructor
+  ActionRestructureVarnode(const std::string &g) : Action(0,"restructure_varnode",g) {}	///< Constructor
   virtual void reset(Funcdata &data) { numpass = 0; }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -837,7 +837,7 @@ class ActionRestructureVarnode : public Action {
 /// This produces the final set of symbols on the stack.
 class ActionRestructureHigh : public Action {
 public:
-  ActionRestructureHigh(const string &g) : Action(0,"restructure_high",g) {}	///< Constructor
+  ActionRestructureHigh(const std::string &g) : Action(0,"restructure_high",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionRestructureHigh(getGroup());
@@ -848,7 +848,7 @@ class ActionRestructureHigh : public Action {
 /// \brief Create symbols for any discovered global variables in the function.
 class ActionMapGlobals : public Action {
 public:
-  ActionMapGlobals(const string &g) : Action(rule_onceperfunc,"mapglobals",g) {}	///< Constructor
+  ActionMapGlobals(const std::string &g) : Action(rule_onceperfunc,"mapglobals",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionMapGlobals(getGroup());
@@ -862,7 +862,7 @@ class ActionMapGlobals : public Action {
 /// to determine a prototype based on the prototype model.
 class ActionInputPrototype : public Action {
 public:
-  ActionInputPrototype(const string &g) : Action(rule_onceperfunc,"inputprototype",g) {}	///< Constructor
+  ActionInputPrototype(const std::string &g) : Action(rule_onceperfunc,"inputprototype",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionInputPrototype(getGroup());
@@ -873,7 +873,7 @@ class ActionInputPrototype : public Action {
 /// \brief Set the (already) recovered output data-type as a formal part of the prototype
 class ActionOutputPrototype : public Action {
 public:
-  ActionOutputPrototype(const string &g) : Action(rule_onceperfunc,"outputprototype",g) {}	///< Constructor
+  ActionOutputPrototype(const std::string &g) : Action(rule_onceperfunc,"outputprototype",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionOutputPrototype(getGroup());
@@ -888,7 +888,7 @@ class ActionOutputPrototype : public Action {
 /// full input
 class ActionUnjustifiedParams : public Action {
 public:
-  ActionUnjustifiedParams(const string &g) : Action(0,"unjustparams",g) {}	///< Constructor
+  ActionUnjustifiedParams(const std::string &g) : Action(0,"unjustparams",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionUnjustifiedParams(getGroup());
@@ -942,7 +942,7 @@ class ActionInferTypes : public Action {
   static PcodeOp *canonicalReturnOp(Funcdata &data);
   static void propagateAcrossReturns(Funcdata &data);
 public:
-  ActionInferTypes(const string &g) : Action(0,"infertypes",g) {}	///< Constructor
+  ActionInferTypes(const std::string &g) : Action(0,"infertypes",g) {}	///< Constructor
   virtual void reset(Funcdata &data) { localcount = 0; }
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
@@ -960,7 +960,7 @@ class ActionInferTypes : public Action {
 /// alters the defining op of the shadow so that the duplicate statement doesn't print.
 class ActionHideShadow : public Action {
 public:
-  ActionHideShadow(const string &g) : Action(rule_onceperfunc,"hideshadow",g) {}	///< Constructor
+  ActionHideShadow(const std::string &g) : Action(rule_onceperfunc,"hideshadow",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionHideShadow(getGroup());
@@ -971,7 +971,7 @@ class ActionHideShadow : public Action {
 /// \brief Replace COPYs from the same source with a single dominant COPY
 class ActionDominantCopy : public Action {
 public:
-  ActionDominantCopy(const string &g) : Action(rule_onceperfunc,"dominantcopy",g) {}	///< Constructor
+  ActionDominantCopy(const std::string &g) : Action(rule_onceperfunc,"dominantcopy",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDominantCopy(getGroup());
@@ -982,7 +982,7 @@ class ActionDominantCopy : public Action {
 /// \brief Mark COPY operations between Varnodes representing the object as \e non-printing
 class ActionCopyMarker : public Action {
 public:
-  ActionCopyMarker(const string &g) : Action(rule_onceperfunc,"copymarker",g) {}	///< Constructor
+  ActionCopyMarker(const std::string &g) : Action(rule_onceperfunc,"copymarker",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionCopyMarker(getGroup());
@@ -993,7 +993,7 @@ class ActionCopyMarker : public Action {
 /// \brief Attach \e dynamically mapped symbols to Varnodes in time for data-type propagation
 class ActionDynamicMapping : public Action {
 public:
-  ActionDynamicMapping(const string &g) : Action(0,"dynamicmapping",g) {}	///< Constructor
+  ActionDynamicMapping(const std::string &g) : Action(0,"dynamicmapping",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDynamicMapping(getGroup());
@@ -1004,7 +1004,7 @@ class ActionDynamicMapping : public Action {
 /// \brief Make final attachments of \e dynamically mapped symbols to Varnodes
 class ActionDynamicSymbols : public Action {
 public:
-  ActionDynamicSymbols(const string &g) : Action(rule_onceperfunc,"dynamicsymbols",g) {}	///< Constructor
+  ActionDynamicSymbols(const std::string &g) : Action(rule_onceperfunc,"dynamicsymbols",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionDynamicSymbols(getGroup());
@@ -1015,7 +1015,7 @@ class ActionDynamicSymbols : public Action {
 /// \brief Add warnings for prototypes that aren't modeled properly
 class ActionPrototypeWarnings : public Action {
 public:
-  ActionPrototypeWarnings(const string &g) : Action(rule_onceperfunc,"prototypewarnings",g) {}	///< Constructor
+  ActionPrototypeWarnings(const std::string &g) : Action(rule_onceperfunc,"prototypewarnings",g) {}	///< Constructor
   virtual Action *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Action *)0;
     return new ActionPrototypeWarnings(getGroup());
@@ -1030,7 +1030,7 @@ class ActionPrototypeWarnings : public Action {
 class PropagationState {
 public:
   Varnode *vn;					///< The root Varnode
-  list<PcodeOp *>::const_iterator iter;		///< Iterator to current descendant being enumerated
+  std::list<PcodeOp *>::const_iterator iter;		///< Iterator to current descendant being enumerated
   PcodeOp *op;					///< The current descendant or the defining PcodeOp
   int4 inslot;					///< Slot holding Varnode for descendant PcodeOp
   int4 slot;					///< Current edge relative to current PcodeOp
@@ -1060,15 +1060,15 @@ class AdditiveEdge {
 /// sorting of the terms to facilitate constant collapse and factoring simplifications.
 class TermOrder {
   PcodeOp *root;			///< The final PcodeOp in the expression
-  vector<AdditiveEdge> terms;		///< Collected terms
-  vector<AdditiveEdge *> sorter;		///< An array of references to terms for quick sorting
+  std::vector<AdditiveEdge> terms;		///< Collected terms
+  std::vector<AdditiveEdge *> sorter;		///< An array of references to terms for quick sorting
   static bool additiveCompare(const AdditiveEdge *op1,const AdditiveEdge *op2);
 public:
   TermOrder(PcodeOp *rt) { root = rt; }	///< Construct given root PcodeOp
   int4 getSize(void) const { return terms.size(); }	///< Get the number of terms in the expression
   void collect(void);			///< Collect all the terms in the expression
   void sortTerms(void);			///< Sort the terms using additiveCompare()
-  const vector<AdditiveEdge *> &getSort(void) { return sorter; }	///< Get the sorted list of references
+  const std::vector<AdditiveEdge *> &getSort(void) { return sorter; }	///< Get the sorted list of references
 };
 
 /// \brief A comparison operator for ordering terms in a sum
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cover.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/cover.cc
index 6e2b88a06..f41a8f745 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cover.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cover.cc
@@ -16,6 +16,8 @@
 #include "cover.hh"
 #include "block.hh"
 
+using namespace std;
+
 const CoverBlock Cover::emptyBlock;
 
 /// PcodeOp objects and a CoverBlock start/stop boundaries have
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cover.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/cover.hh
index 4d874ff9f..4cc0bdaaa 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cover.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cover.hh
@@ -52,7 +52,7 @@ class CoverBlock {
   bool contain(const PcodeOp *point) const;					///< Check containment of given point
   int4 boundary(const PcodeOp *point) const;					///< Characterize given point as boundary
   void merge(const CoverBlock &op2);					///< Merge another CoverBlock into \b this
-  void print(ostream &s) const;						///< Dump a description to stream
+  void print(std::ostream &s) const;						///< Dump a description to stream
 };
 
 /// \brief A description of the topological scope of a single variable object
@@ -66,7 +66,7 @@ class CoverBlock {
 ///
 /// Internally this is implemented as a map from basic block to their non-empty CoverBlock
 class Cover {
-  map<int4,CoverBlock> cover; 			///< block index -> CoverBlock
+  std::map<int4,CoverBlock> cover; 			///< block index -> CoverBlock
   static const CoverBlock emptyBlock;		///< Global empty CoverBlock for blocks not covered by \b this
   void addRefRecurse(const FlowBlock *bl);	///< Fill-in \b this recursively from the given block
 public:
@@ -75,7 +75,7 @@ class Cover {
   const CoverBlock &getCoverBlock(int4 i) const;	///< Get the CoverBlock corresponding to the i-th block
   int4 intersect(const Cover &op2) const;	///< Characterize the intersection between \b this and another Cover.
   int4 intersectByBlock(int4 blk,const Cover &op2) const;	///< Characterize the intersection on a specific block
-  void intersectList(vector<int4> &listout,const Cover &op2,int4 level) const;
+  void intersectList(std::vector<int4> &listout,const Cover &op2,int4 level) const;
   bool contain(const PcodeOp *op,int4 max) const;
   int4 containVarnodeDef(const Varnode *vn) const;
   void merge(const Cover &op2);			///< Merge \b this with another Cover block by block
@@ -84,9 +84,9 @@ class Cover {
   void addRefPoint(const PcodeOp *ref,const Varnode *vn);	///< Add a variable read to \b this Cover
   //  void remove_refpoint(const PcodeOp *ref,const Varnode *vn) {
   //    rebuild(vn); }		// Cheap but inefficient
-  void print(ostream &s) const;			///< Dump a description of \b this cover to stream
-  map<int4,CoverBlock>::const_iterator begin(void) const { return cover.begin(); }	///< Get beginning of CoverBlocks
-  map<int4,CoverBlock>::const_iterator end(void) const { return cover.end(); }		///< Get end of CoverBlocks
+  void print(std::ostream &s) const;			///< Dump a description of \b this cover to stream
+  std::map<int4,CoverBlock>::const_iterator begin(void) const { return cover.begin(); }	///< Get beginning of CoverBlocks
+  std::map<int4,CoverBlock>::const_iterator end(void) const { return cover.end(); }		///< Get end of CoverBlocks
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.cc
index 42b1531ad..8e1fd1150 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.cc
@@ -15,6 +15,8 @@
  */
 #include "cpool.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_A = AttributeId("a",80);
 AttributeId ATTRIB_B = AttributeId("b",81);
 AttributeId ATTRIB_LENGTH = AttributeId("length",82);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
index ce9b9809a..76a83fd9b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool.hh
@@ -72,7 +72,7 @@ class CPoolRecord {
   friend class ConstantPool;
   uint4 tag;		///< Descriptor of type of the object
   uint4 flags;		///< Additional boolean properties on the record
-  string token;		///< Name or token associated with the object
+  std::string token;		///< Name or token associated with the object
   uintb value;		///< Constant value of the object (if known)
   Datatype *type;	///< Data-type associated with the object
   uint1 *byteData;	///< For string literals, the raw byte data of the string
@@ -81,7 +81,7 @@ class CPoolRecord {
   CPoolRecord(void) { type = (Datatype *)0; byteData = (uint1 *)0; }		///< Construct an empty record
   ~CPoolRecord(void) { if (byteData != (uint1 *)0) delete [] byteData; }	///< Destructor
   uint4 getTag(void) const { return tag; }					///< Get the type of record
-  const string &getToken(void) const { return token; }				///< Get name of method or data-type
+  const std::string &getToken(void) const { return token; }				///< Get name of method or data-type
   const uint1 *getByteData(void) const { return byteData; }			///< Get pointer to string literal data
   int4 getByteDataLength(void) const { return byteDataLen; }			///< Number of bytes of string literal data
   Datatype *getType(void) const { return type; }				///< Get the data-type associated with \b this
@@ -106,7 +106,7 @@ class ConstantPool {
   /// Any issue with allocation (like a dupicate reference) causes an exception.
   /// \param refs is the \e reference of 1 or more identifying integers
   /// \return the new CPoolRecord
-  virtual CPoolRecord *createRecord(const vector<uintb> &refs)=0;
+  virtual CPoolRecord *createRecord(const std::vector<uintb> &refs)=0;
 public:
   virtual ~ConstantPool() {}	///< Destructor
 
@@ -114,7 +114,7 @@ class ConstantPool {
   ///
   /// \param refs is the \e reference (made up of 1 or more identifying integers)
   /// \return the matching CPoolRecord or NULL if none matches the reference
-  virtual const CPoolRecord *getRecord(const vector<uintb> &refs) const=0;
+  virtual const CPoolRecord *getRecord(const std::vector<uintb> &refs) const=0;
 
   /// \brief A a new constant pool record to \b this database
   ///
@@ -124,7 +124,7 @@ class ConstantPool {
   /// \param tag is the type of record to create
   /// \param tok is the name associated with the object
   /// \param ct is the data-type associated with the object
-  void putRecord(const vector<uintb> &refs,uint4 tag,const string &tok,Datatype *ct);
+  void putRecord(const std::vector<uintb> &refs,uint4 tag,const std::string &tok,Datatype *ct);
 
   /// \brief Restore a CPoolRecord given a \e reference and a stream decoder
   ///
@@ -134,7 +134,7 @@ class ConstantPool {
   /// \param decoder is the given stream decoder
   /// \param typegrp is the TypeFactory used to resolve data-type references in XML
   /// \return the newly allocated and initialized CPoolRecord
-  const CPoolRecord *decodeRecord(const vector<uintb> &refs,Decoder &decoder,TypeFactory &typegrp);
+  const CPoolRecord *decodeRecord(const std::vector<uintb> &refs,Decoder &decoder,TypeFactory &typegrp);
 
   virtual bool empty(void) const=0;		///< Is the container empty of records
   virtual void clear(void)=0;			///< Release any (local) resources
@@ -176,7 +176,7 @@ class ConstantPoolInternal : public ConstantPool {
     uintb b;			///< The second integer in a \e reference (or zero)
     CheapSorter(void) { a = 0; b = 0; }	///< Construct a zero reference
     CheapSorter(const CheapSorter &op2) { a = op2.a; b = op2.b; }	///< Copy constructor
-    CheapSorter(const vector<uintb> &refs) { a = refs[0]; b = (refs.size() > 1) ? refs[1] : 0; } ///< Construct from an array of integers
+    CheapSorter(const std::vector<uintb> &refs) { a = refs[0]; b = (refs.size() > 1) ? refs[1] : 0; } ///< Construct from an array of integers
 
     /// \brief Lexicographic comparison
     ///
@@ -190,15 +190,15 @@ class ConstantPoolInternal : public ConstantPool {
     /// \brief Convert the reference back to a formal array of integers
     ///
     /// \param refs is the provided container of integers
-    void apply(vector<uintb> &refs) const { refs.push_back(a); refs.push_back(b); }
+    void apply(std::vector<uintb> &refs) const { refs.push_back(a); refs.push_back(b); }
 
     void encode(Encoder &encoder) const;	///< Encode the \e reference to a stream
     void decode(Decoder &decoder);		///< Decode the \e reference from a stream
   };
-  map<CheapSorter,CPoolRecord> cpoolMap;	///< A map from \e reference to constant pool record
-  virtual CPoolRecord *createRecord(const vector<uintb> &refs);
+  std::map<CheapSorter,CPoolRecord> cpoolMap;	///< A map from \e reference to constant pool record
+  virtual CPoolRecord *createRecord(const std::vector<uintb> &refs);
 public:
-  virtual const CPoolRecord *getRecord(const vector<uintb> &refs) const;
+  virtual const CPoolRecord *getRecord(const std::vector<uintb> &refs) const;
   virtual bool empty(void) const { return cpoolMap.empty(); }
   virtual void clear(void) { cpoolMap.clear(); }
   virtual void encode(Encoder &encoder) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.cc
index e8dee8256..1da445915 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "cpool_ghidra.hh"
 
+using namespace std;
+
 ConstantPoolGhidra::ConstantPoolGhidra(ArchitectureGhidra *g)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.hh
index af65a8d2b..5efe96766 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/cpool_ghidra.hh
@@ -31,10 +31,10 @@
 class ConstantPoolGhidra : public ConstantPool {
   ArchitectureGhidra *ghidra;			///< The connection with the Ghidra client
   mutable ConstantPoolInternal cache;		///< The local cache of previouly queried CPoolRecord objects
-  virtual CPoolRecord *createRecord(const vector<uintb> &refs);
+  virtual CPoolRecord *createRecord(const std::vector<uintb> &refs);
 public:
   ConstantPoolGhidra(ArchitectureGhidra *g);	///< Constructor
-  virtual const CPoolRecord *getRecord(const vector<uintb> &refs) const;
+  virtual const CPoolRecord *getRecord(const std::vector<uintb> &refs) const;
   virtual bool empty(void) const { return false; }
   virtual void clear(void) { cache.clear(); }
   virtual void encode(Encoder &encoder) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/crc32.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/crc32.cc
index 2881ab711..3c68cb3ba 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/crc32.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/crc32.cc
@@ -16,6 +16,8 @@
  */
 #include "crc32.hh"
 
+using namespace std;
+
 // Table for bytewise calculation of a 32-bit Cyclic Redundancy Check
 uint4 crc32tab[] = {
   0x0,0x77073096,0xee0e612c,0x990951ba,0x76dc419,0x706af48f,
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
index 4704eb1d3..2e0b74fb0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc
@@ -18,6 +18,8 @@
 #include "crc32.hh"
 #include <ctype.h>
 
+using namespace std;
+
 AttributeId ATTRIB_CAT = AttributeId("cat",61);
 AttributeId ATTRIB_FIELD = AttributeId("field",62);
 AttributeId ATTRIB_MERGE = AttributeId("merge",63);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/database.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/database.hh
index 8da3a41fa..787b1ca8b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/database.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/database.hh
@@ -155,7 +155,7 @@ class SymbolEntry {
   bool isAddrTied(void) const;						///< Is \b this storage address tied
   bool updateType(Varnode *vn) const;					///< Update a Varnode data-type from \b this
   Datatype *getSizedType(const Address &addr,int4 sz) const;		///< Get the data-type associated with (a piece of) \b this
-  void printEntry(ostream &s) const;					///< Dump a description of \b this to a stream
+  void printEntry(std::ostream &s) const;					///< Dump a description of \b this to a stream
   void encode(Encoder &encoder) const;					///< Encode \b this to a stream
   void decode(Decoder &decoder);					///< Decode \b this from a stream
 };
@@ -173,7 +173,7 @@ class Symbol {
   friend class SymbolCompareName;
 protected:
   Scope *scope;			///< The scope that owns this symbol
-  string name;			///< The local name of the symbol
+  std::string name;			///< The local name of the symbol
   Datatype *type;		///< The symbol's data-type
   uint4 nameDedup;		///< id to distinguish symbols with the same name
   uint4 flags;			///< Varnode-like properties of the symbol
@@ -183,7 +183,7 @@ class Symbol {
   int2 category;		///< Special category (\b function_parameter, \b equate, etc.)
   uint2 catindex;		///< Index within category
   uint8 symbolId;		///< Unique id, 0=unassigned
-  vector<list<SymbolEntry>::iterator> mapentry;	///< List of storage locations labeled with \b this Symbol
+  std::vector<std::list<SymbolEntry>::iterator> mapentry;	///< List of storage locations labeled with \b this Symbol
   mutable const Scope *depthScope;	///< Scope associated with current depth resolution
   mutable int4 depthResolution;	///< Number of namespace elements required to resolve symbol in current scope
   uint4 wholeCount;		///< Number of SymbolEntries that map to the whole Symbol
@@ -213,9 +213,9 @@ class Symbol {
     union_facet = 2		///< Symbol holding read or write facing union field information
   };
 
-  Symbol(Scope *sc,const string &nm,Datatype *ct);	///< Construct given a name and data-type
+  Symbol(Scope *sc,const std::string &nm,Datatype *ct);	///< Construct given a name and data-type
   Symbol(Scope *sc);		  			///< Construct for use with decode()
-  const string &getName(void) const { return name; }		///< Get the local name of the symbol
+  const std::string &getName(void) const { return name; }		///< Get the local name of the symbol
   Datatype *getType(void) const { return type; }		///< Get the data-type
   uint8 getId(void) const { return symbolId; }			///< Get a unique id for the symbol
   uint4 getFlags(void) const { return flags; }			///< Get the boolean properties of the Symbol
@@ -281,7 +281,7 @@ class FunctionSymbol : public Symbol {
   virtual ~FunctionSymbol(void);
   void buildType(void);			///< Build the data-type associated with \b this Symbol
 public:
-  FunctionSymbol(Scope *sc,const string &nm,int4 size);	///< Construct given the name
+  FunctionSymbol(Scope *sc,const std::string &nm,int4 size);	///< Construct given the name
   FunctionSymbol(Scope *sc,int4 size);			///< Constructor for use with decode
   Funcdata *getFunction(void);				///< Get the underlying Funcdata object
   virtual void encode(Encoder &encoder) const;
@@ -297,7 +297,7 @@ class FunctionSymbol : public Symbol {
 class EquateSymbol : public Symbol {
   uintb value;				///< Value of the constant being equated
 public:
-  EquateSymbol(Scope *sc,const string &nm,uint4 format,uintb val);	///< Constructor
+  EquateSymbol(Scope *sc,const std::string &nm,uint4 format,uintb val);	///< Constructor
   EquateSymbol(Scope *sc) : Symbol(sc) { value = 0; category = equate; }	///< Constructor for use with decode
   uintb getValue(void) const { return value; }				///< Get the constant value
   bool isValueClose(uintb op2Value,int4 size) const;			///< Is the given value similar to \b this equate
@@ -308,7 +308,7 @@ class EquateSymbol : public Symbol {
 class UnionFacetSymbol : public Symbol {
   int4 fieldNum;			///< Particular field to associate with Symbol access
 public:
-  UnionFacetSymbol(Scope *sc,const string &nm,Datatype *unionDt,int4 fldNum);	///< Constructor from components
+  UnionFacetSymbol(Scope *sc,const std::string &nm,Datatype *unionDt,int4 fldNum);	///< Constructor from components
   UnionFacetSymbol(Scope *sc) : Symbol(sc) { fieldNum = -1; category = union_facet; }	///< Constructor for decode
   int4 getFieldNumber(void) const { return fieldNum; }		///< Get the particular field associate with \b this
   virtual void encode(Encoder &encoder) const;
@@ -319,7 +319,7 @@ class UnionFacetSymbol : public Symbol {
 class LabSymbol : public Symbol {
   void buildType(void);		///< Build placeholder data-type
 public:
-  LabSymbol(Scope *sc,const string &nm);	///< Construct given name
+  LabSymbol(Scope *sc,const std::string &nm);	///< Construct given name
   LabSymbol(Scope *sc);				///< Constructor for use with decode
   virtual void encode(Encoder &encoder) const;
   virtual void decode(Decoder &decoder);
@@ -336,7 +336,7 @@ class ExternRefSymbol : public Symbol {
   void buildNameType(void);		///< Create a name and data-type for the Symbol
   virtual ~ExternRefSymbol(void) {}
 public:
-  ExternRefSymbol(Scope *sc,const Address &ref,const string &nm);	///< Construct given a \e placeholder address
+  ExternRefSymbol(Scope *sc,const Address &ref,const std::string &nm);	///< Construct given a \e placeholder address
   ExternRefSymbol(Scope *sc) : Symbol(sc) {} 				///< For use with decode
   const Address &getRefAddr(void) const { return refaddr; }		///< Return the \e placeholder address
   virtual void encode(Encoder &encoder) const;
@@ -359,27 +359,27 @@ class SymbolCompareName {
     return (sym1->nameDedup < sym2->nameDedup);
   }
 };
-typedef set<Symbol *,SymbolCompareName> SymbolNameTree;		///< A set of Symbol objects sorted by name
+typedef std::set<Symbol *,SymbolCompareName> SymbolNameTree;		///< A set of Symbol objects sorted by name
 
 /// \brief An iterator over SymbolEntry objects in multiple address spaces
 ///
 /// Given an EntryMap (a rangemap of SymbolEntry objects in a single address space)
 /// for each address space, iterator over all the SymbolEntry objects
 class MapIterator {
-  const vector<EntryMap *> *map;		///< The list of EntryMaps, one per address space
-  vector<EntryMap *>::const_iterator curmap;	///< Current EntryMap being iterated
-  list<SymbolEntry>::const_iterator curiter;	///< Current SymbolEntry being iterated
+  const std::vector<EntryMap *> *map;		///< The list of EntryMaps, one per address space
+  std::vector<EntryMap *>::const_iterator curmap;	///< Current EntryMap being iterated
+  std::list<SymbolEntry>::const_iterator curiter;	///< Current SymbolEntry being iterated
 public:
-  MapIterator(void) { map = (const vector<EntryMap *> *)0; }	///< Construct an uninitialized iterator
+  MapIterator(void) { map = (const std::vector<EntryMap *> *)0; }	///< Construct an uninitialized iterator
 
   /// \brief Construct iterator at a specific position
   ///
   /// \param m is the list of EntryMaps
   /// \param cm is the position of the iterator within the EntryMap list
   /// \param ci is the position of the iterator within the specific EntryMap
-  MapIterator(const vector<EntryMap *> *m,
-	       vector<EntryMap *>::const_iterator cm,
-	       list<SymbolEntry>::const_iterator ci) {
+  MapIterator(const std::vector<EntryMap *> *m,
+	       std::vector<EntryMap *>::const_iterator cm,
+	       std::list<SymbolEntry>::const_iterator ci) {
     map = m; curmap = cm; curiter = ci;
   }
 
@@ -420,12 +420,12 @@ class MapIterator {
 /// and pick up the original symbol.
 struct DuplicateFunctionError : public RecovError {
   Address address;		///< Address of function causing the error
-  string functionName;		///< Name of the function
-  DuplicateFunctionError(const Address &addr,const string &nm) : RecovError("Duplicate Function") {
+  std::string functionName;		///< Name of the function
+  DuplicateFunctionError(const Address &addr,const std::string &nm) : RecovError("Duplicate Function") {
     address = addr; functionName = nm; }	///< Constructor
 };
 
-typedef map<uint8,Scope *> ScopeMap;		///< A map from id to Scope
+typedef std::map<uint8,Scope *> ScopeMap;		///< A map from id to Scope
 
 /// \brief A collection of Symbol objects within a single (namespace or functional) scope
 ///
@@ -457,10 +457,10 @@ class Scope {
   ScopeMap children;				///< Sorted list of child scopes
   void attachScope(Scope *child);		///< Attach a new child Scope to \b this
   void detachScope(ScopeMap::iterator iter);	///< Detach a child Scope from \b this
-  static uint8 hashScopeName(uint8 baseId,const string &nm);
+  static uint8 hashScopeName(uint8 baseId,const std::string &nm);
 protected:
   Architecture *glb;				///< Architecture of \b this scope
-  string name;					///< Name of \b this scope
+  std::string name;					///< Name of \b this scope
   Funcdata *fd;					///< (If non-null) the function which \b this is the local Scope for
   uint8 uniqueId;				///< Unique id for the scope, for deduping scope names, assigning symbol ids
   static const Scope *stackAddr(const Scope *scope1,
@@ -500,7 +500,7 @@ class Scope {
   /// \param id is the globally unique id associated with the scope
   /// \param nm is the name of the new scope
   /// \return the new Scope object
-  virtual Scope *buildSubScope(uint8 id,const string &nm)=0;
+  virtual Scope *buildSubScope(uint8 id,const std::string &nm)=0;
 
   virtual void restrictScope(Funcdata *f);				///< Convert \b this to a local Scope
 
@@ -550,7 +550,7 @@ class Scope {
   void turnOffDebug(void) const { debugon = false; }
 #endif
   /// \brief Construct an empty scope, given a name and Architecture
-  Scope(uint8 id,const string &nm,Architecture *g,Scope *own) {
+  Scope(uint8 id,const std::string &nm,Architecture *g,Scope *own) {
     uniqueId = id; name = nm; glb = g; parent = (Scope *)0; fd = (Funcdata *)0; owner=own;
 #ifdef OPACTION_DEBUG
     debugon = false;
@@ -559,10 +559,10 @@ class Scope {
   virtual ~Scope(void);						///< Destructor
   virtual MapIterator begin(void) const=0;			///< Beginning iterator to mapped SymbolEntrys
   virtual MapIterator end(void) const=0;			///< Ending iterator to mapped SymbolEntrys
-  virtual list<SymbolEntry>::const_iterator beginDynamic(void) const=0;	///< Beginning iterator to dynamic SymbolEntrys
-  virtual list<SymbolEntry>::const_iterator endDynamic(void) const=0;	///< Ending iterator to dynamic SymbolEntrys
-  virtual list<SymbolEntry>::iterator beginDynamic(void)=0;	///< Beginning iterator to dynamic SymbolEntrys
-  virtual list<SymbolEntry>::iterator endDynamic(void)=0;	///< Ending iterator to dynamic SymbolEntrys
+  virtual std::list<SymbolEntry>::const_iterator beginDynamic(void) const=0;	///< Beginning iterator to dynamic SymbolEntrys
+  virtual std::list<SymbolEntry>::const_iterator endDynamic(void) const=0;	///< Ending iterator to dynamic SymbolEntrys
+  virtual std::list<SymbolEntry>::iterator beginDynamic(void)=0;	///< Beginning iterator to dynamic SymbolEntrys
+  virtual std::list<SymbolEntry>::iterator endDynamic(void)=0;	///< Ending iterator to dynamic SymbolEntrys
   virtual void clear(void)=0;					///< Clear all symbols from \b this scope
   virtual void clearCategory(int4 cat)=0;			///< Clear all symbols of the given category from \b this scope
   virtual void clearUnlocked(void)=0;				///< Clear all unlocked symbols from \b this scope
@@ -586,7 +586,7 @@ class Scope {
 
   virtual void removeSymbolMappings(Symbol *symbol)=0;	///< Remove all SymbolEntrys from the given Symbol
   virtual void removeSymbol(Symbol *symbol)=0;		///< Remove the given Symbol from \b this Scope
-  virtual void renameSymbol(Symbol *sym,const string &newname)=0;	///< Rename a Symbol within \b this Scope
+  virtual void renameSymbol(Symbol *sym,const std::string &newname)=0;	///< Rename a Symbol within \b this Scope
 
   /// \brief Change the data-type of a Symbol within \b this Scope
   ///
@@ -655,7 +655,7 @@ class Scope {
   /// If there are multiple Symbols with the same name, all are passed back.
   /// \param nm is the name to search for
   /// \param res will contain any matching Symbols
-  virtual void findByName(const string &nm,vector<Symbol *> &res) const=0;
+  virtual void findByName(const std::string &nm,std::vector<Symbol *> &res) const=0;
 
   /// \brief Check if the given name is occurs within the given scope path.
   ///
@@ -664,7 +664,7 @@ class Scope {
   /// If the name is used \b true is returned.
   /// \param nm is the given name to test
   /// \param op2 is the terminating ancestor scope (or null)
-  virtual bool isNameUsed(const string &nm,const Scope *op2) const=0;
+  virtual bool isNameUsed(const std::string &nm,const Scope *op2) const=0;
 
   /// \brief Convert an \e external \e reference to the referenced function
   ///
@@ -680,25 +680,25 @@ class Scope {
   /// \param index is a reference to an index used to make the name unique, which will be updated
   /// \param flags are boolean properties of the variable we need the name for
   /// \return the new variable name
-  virtual string buildVariableName(const Address &addr,
+  virtual std::string buildVariableName(const Address &addr,
 				   const Address &pc,
 				   Datatype *ct,int4 &index,uint4 flags) const=0;
 
   /// \brief Build a formal \b undefined name, used internally when a Symbol is not given a name
   ///
   /// \return a special internal name that won't collide with other names in \b this Scope
-  virtual string buildUndefinedName(void) const=0;
+  virtual std::string buildUndefinedName(void) const=0;
 
   /// \brief Produce a version of the given symbol name that won't collide with other names in \b this Scope
   ///
   /// \param nm is the given name
   /// \return return a unique version of the name
-  virtual string makeNameUnique(const string &nm) const=0;
+  virtual std::string makeNameUnique(const std::string &nm) const=0;
 
   virtual void encode(Encoder &encoder) const=0;	///< Encode \b this as a \<scope> element
   virtual void decode(Decoder &decoder)=0;		///< Decode \b this Scope from a \<scope> element
   virtual void decodeWrappingAttributes(Decoder &decoder) {}	///< Restore attributes for \b this Scope from wrapping element
-  virtual void printEntries(ostream &s) const=0;	///< Dump a description of all SymbolEntry objects to a stream
+  virtual void printEntries(std::ostream &s) const=0;	///< Dump a description of all SymbolEntry objects to a stream
 
   /// \brief Get the number of Symbols in the given category
   ///
@@ -720,16 +720,16 @@ class Scope {
   /// \param ind is the index position to set (within the category)
   virtual void setCategory(Symbol *sym,int4 cat,int4 ind)=0;
 
-  virtual SymbolEntry *addSymbol(const string &nm,Datatype *ct,
+  virtual SymbolEntry *addSymbol(const std::string &nm,Datatype *ct,
 				 const Address &addr,const Address &usepoint);
 
-  const string &getName(void) const { return name; }		///< Get the name of the Scope
+  const std::string &getName(void) const { return name; }		///< Get the name of the Scope
   uint8 getId(void) const { return uniqueId; }			///< Get the globally unique id
   bool isGlobal(void) const { return (fd == (Funcdata *)0); }	///< Return \b true if \b this scope is global
 
   // The main global querying routines
-  void queryByName(const string &nm,vector<Symbol *> &res) const;	///< Look-up symbols by name
-  Funcdata *queryFunction(const string &nm) const;			///< Look-up a function by name
+  void queryByName(const std::string &nm,std::vector<Symbol *> &res) const;	///< Look-up symbols by name
+  Funcdata *queryFunction(const std::string &nm) const;			///< Look-up a function by name
   SymbolEntry *queryByAddr(const Address &addr,
 			   const Address &usepoint) const;	  	///< Get Symbol with matching address
   SymbolEntry *queryContainer(const Address &addr,int4 size,
@@ -740,7 +740,7 @@ class Scope {
   Funcdata *queryExternalRefFunction(const Address &addr) const;	///< Look-up a function thru an \e external \e reference
   LabSymbol *queryCodeLabel(const Address &addr) const;			///< Look-up a code label by address
 
-  Scope *resolveScope(const string &nm, bool strategy) const;		///< Find a child Scope of \b this
+  Scope *resolveScope(const std::string &nm, bool strategy) const;		///< Find a child Scope of \b this
   Scope *discoverScope(const Address &addr,int4 sz,const Address &usepoint);	///< Find the owning Scope of a given memory range
   ScopeMap::const_iterator childrenBegin() const { return children.begin(); }	///< Beginning iterator of child scopes
   ScopeMap::const_iterator childrenEnd() const { return children.end(); }	///< Ending iterator of child scopes
@@ -749,24 +749,24 @@ class Scope {
   void resetSizeLockType(Symbol *sym);				///< Clear a Symbol's \e size-locked data-type
   void setThisPointer(Symbol *sym,bool val) { sym->setThisPointer(val); }	///< Toggle the given Symbol as the "this" pointer
   bool isSubScope(const Scope *scp) const;			///< Is this a sub-scope of the given Scope
-  string getFullName(void) const;				///< Get the full name of \b this Scope
-  void getScopePath(vector<const Scope *> &vec) const;		///< Get the ordered list of scopes up to \b this
+  std::string getFullName(void) const;				///< Get the full name of \b this Scope
+  void getScopePath(std::vector<const Scope *> &vec) const;		///< Get the ordered list of scopes up to \b this
   const Scope *findDistinguishingScope(const Scope *op2) const;	///< Find first ancestor of \b this not shared by given scope
   Architecture *getArch(void) const { return glb; }		///< Get the Architecture associated with \b this
   Scope *getParent(void) const { return parent; }		///< Get the parent Scope (or NULL if \b this is the global Scope)
-  Symbol *addSymbol(const string &nm,Datatype *ct);		///< Add a new Symbol \e without mapping it to an address
+  Symbol *addSymbol(const std::string &nm,Datatype *ct);		///< Add a new Symbol \e without mapping it to an address
   SymbolEntry *addMapPoint(Symbol *sym,const Address &addr,
 			   const Address &usepoint);		///< Map a Symbol to a specific address
   Symbol *addMapSym(Decoder &decoder);				///< Parse a mapped Symbol from a \<mapsym> element
-  FunctionSymbol *addFunction(const Address &addr,const string &nm);
-  ExternRefSymbol *addExternalRef(const Address &addr,const Address &refaddr,const string &nm);
-  LabSymbol *addCodeLabel(const Address &addr,const string &nm);
-  Symbol *addDynamicSymbol(const string &nm,Datatype *ct,const Address &caddr,uint8 hash);
-  Symbol *addEquateSymbol(const string &nm,uint4 format,uintb value,const Address &addr,uint8 hash);
-  Symbol *addUnionFacetSymbol(const string &nm,Datatype *dt,int4 fieldNum,const Address &addr,uint8 hash);
-  string buildDefaultName(Symbol *sym,int4 &base,Varnode *vn) const;	///< Create a default name for the given Symbol
+  FunctionSymbol *addFunction(const Address &addr,const std::string &nm);
+  ExternRefSymbol *addExternalRef(const Address &addr,const Address &refaddr,const std::string &nm);
+  LabSymbol *addCodeLabel(const Address &addr,const std::string &nm);
+  Symbol *addDynamicSymbol(const std::string &nm,Datatype *ct,const Address &caddr,uint8 hash);
+  Symbol *addEquateSymbol(const std::string &nm,uint4 format,uintb value,const Address &addr,uint8 hash);
+  Symbol *addUnionFacetSymbol(const std::string &nm,Datatype *dt,int4 fieldNum,const Address &addr,uint8 hash);
+  std::string buildDefaultName(Symbol *sym,int4 &base,Varnode *vn) const;	///< Create a default name for the given Symbol
   bool isReadOnly(const Address &addr,int4 size,const Address &usepoint) const;
-  void printBounds(ostream &s) const { rangetree.printBounds(s); }	///< Print a description of \b this Scope's \e owned memory ranges
+  void printBounds(std::ostream &s) const { rangetree.printBounds(s); }	///< Print a description of \b this Scope's \e owned memory ranges
 };
 
 /// \brief An in-memory implementation of the Scope interface.
@@ -779,22 +779,22 @@ class ScopeInternal : public Scope {
   void decodeHole(Decoder &decoder);
   void decodeCollision(Decoder &decoder);
   void insertNameTree(Symbol *sym);
-  SymbolNameTree::const_iterator findFirstByName(const string &nm) const;
+  SymbolNameTree::const_iterator findFirstByName(const std::string &nm) const;
 protected:
-  virtual Scope *buildSubScope(uint8 id,const string &nm);	///< Build an unattached Scope to be associated as a sub-scope of \b this
+  virtual Scope *buildSubScope(uint8 id,const std::string &nm);	///< Build an unattached Scope to be associated as a sub-scope of \b this
   virtual void addSymbolInternal(Symbol *sym);
   virtual SymbolEntry *addMapInternal(Symbol *sym,uint4 exfl,const Address &addr,int4 off,int4 sz,const RangeList &uselim);
   virtual SymbolEntry *addDynamicMapInternal(Symbol *sym,uint4 exfl,uint8 hash,int4 off,int4 sz,
 					     const RangeList &uselim);
   SymbolNameTree nametree;			///< The set of Symbol objects, sorted by name
-  vector<EntryMap *> maptable;			///< Rangemaps of SymbolEntry, one map for each address space
-  vector<vector<Symbol *> > category;		///< References to Symbol objects organized by category
-  list<SymbolEntry> dynamicentry;		///< Dynamic symbol entries
+  std::vector<EntryMap *> maptable;			///< Rangemaps of SymbolEntry, one map for each address space
+  std::vector<std::vector<Symbol *> > category;		///< References to Symbol objects organized by category
+  std::list<SymbolEntry> dynamicentry;		///< Dynamic symbol entries
   SymbolNameTree multiEntrySet;			///< Set of symbols with multiple entries
   uint8 nextUniqueId;				///< Next available symbol id
 public:
-  ScopeInternal(uint8 id,const string &nm,Architecture *g);	///< Construct the Scope
-  ScopeInternal(uint8 id,const string &nm,Architecture *g, Scope *own);	///< Construct as a cache
+  ScopeInternal(uint8 id,const std::string &nm,Architecture *g);	///< Construct the Scope
+  ScopeInternal(uint8 id,const std::string &nm,Architecture *g, Scope *own);	///< Construct as a cache
   virtual void clear(void);
   virtual void categorySanity(void);			///< Make sure Symbol categories are sane
   virtual void clearCategory(int4 cat);
@@ -804,13 +804,13 @@ class ScopeInternal : public Scope {
   virtual ~ScopeInternal(void);
   virtual MapIterator begin(void) const;
   virtual MapIterator end(void) const;
-  virtual list<SymbolEntry>::const_iterator beginDynamic(void) const;
-  virtual list<SymbolEntry>::const_iterator endDynamic(void) const;
-  virtual list<SymbolEntry>::iterator beginDynamic(void);
-  virtual list<SymbolEntry>::iterator endDynamic(void);
+  virtual std::list<SymbolEntry>::const_iterator beginDynamic(void) const;
+  virtual std::list<SymbolEntry>::const_iterator endDynamic(void) const;
+  virtual std::list<SymbolEntry>::iterator beginDynamic(void);
+  virtual std::list<SymbolEntry>::iterator endDynamic(void);
   virtual void removeSymbolMappings(Symbol *symbol);
   virtual void removeSymbol(Symbol *symbol);
-  virtual void renameSymbol(Symbol *sym,const string &newname);
+  virtual void renameSymbol(Symbol *sym,const std::string &newname);
   virtual void retypeSymbol(Symbol *sym,Datatype *ct);
   virtual void setAttribute(Symbol *sym,uint4 attr);
   virtual void clearAttribute(Symbol *sym,uint4 attr);
@@ -826,24 +826,24 @@ class ScopeInternal : public Scope {
   virtual LabSymbol *findCodeLabel(const Address &addr) const;
   virtual SymbolEntry *findOverlap(const Address &addr,int4 size) const;
 
-  virtual void findByName(const string &nm,vector<Symbol *> &res) const;
-  virtual bool isNameUsed(const string &nm,const Scope *op2) const;
+  virtual void findByName(const std::string &nm,std::vector<Symbol *> &res) const;
+  virtual bool isNameUsed(const std::string &nm,const Scope *op2) const;
   virtual Funcdata *resolveExternalRefFunction(ExternRefSymbol *sym) const;
 
-  virtual string buildVariableName(const Address &addr,
+  virtual std::string buildVariableName(const Address &addr,
 				   const Address &pc,
 				   Datatype *ct,int4 &index,uint4 flags) const;
-  virtual string buildUndefinedName(void) const;
-  virtual string makeNameUnique(const string &nm) const;
+  virtual std::string buildUndefinedName(void) const;
+  virtual std::string makeNameUnique(const std::string &nm) const;
   virtual void encode(Encoder &encoder) const;
   virtual void decode(Decoder &decoder);
-  virtual void printEntries(ostream &s) const;
+  virtual void printEntries(std::ostream &s) const;
   virtual int4 getCategorySize(int4 cat) const;
   virtual Symbol *getCategorySymbol(int4 cat,int4 ind) const;
   virtual void setCategory(Symbol *sym,int4 cat,int4 ind);
   void assignDefaultNames(int4 &base);		///< Assign a default name (via buildVariableName) to any unnamed symbol
-  set<Symbol *>::const_iterator beginMultiEntry(void) const { return multiEntrySet.begin(); }	///< Start of symbols with more than one entry
-  set<Symbol *>::const_iterator endMultiEntry(void) const { return multiEntrySet.end(); }	///< End of symbols with more than one entry
+  std::set<Symbol *>::const_iterator beginMultiEntry(void) const { return multiEntrySet.begin(); }	///< Start of symbols with more than one entry
+  std::set<Symbol *>::const_iterator endMultiEntry(void) const { return multiEntrySet.end(); }	///< End of symbols with more than one entry
 };
 
 /// \brief An Address range associated with the symbol Scope that owns it
@@ -918,9 +918,9 @@ class Database {
   void removeRange(Scope *scope,AddrSpace *spc,uintb first,uintb last);	///< Remove an address range from \e ownership of a Scope
   Scope *getGlobalScope(void) const { return globalscope; }	///< Get the global Scope
   Scope *resolveScope(uint8 id) const;				///< Look-up a Scope by id
-  Scope *resolveScopeFromSymbolName(const string &fullname,const string &delim,string &basename,Scope *start) const;
-  Scope *findCreateScope(uint8,const string &nm,Scope *parent);	/// Find (and if not found create) a specific subscope
-  Scope *findCreateScopeFromSymbolName(const string &fullname,const string &delim,string &basename,Scope *start);
+  Scope *resolveScopeFromSymbolName(const std::string &fullname,const std::string &delim,std::string &basename,Scope *start) const;
+  Scope *findCreateScope(uint8,const std::string &nm,Scope *parent);	/// Find (and if not found create) a specific subscope
+  Scope *findCreateScopeFromSymbolName(const std::string &fullname,const std::string &delim,std::string &basename,Scope *start);
   const Scope *mapScope(const Scope *qpoint,const Address &addr,const Address &usepoint) const;
   Scope *mapScope(Scope *qpoint,const Address &addr,const Address &usepoint);
   uint4 getProperty(const Address &addr) const { return flagbase.getValue(addr); }	///< Get boolean properties at the given address
@@ -935,7 +935,7 @@ class Database {
 /// \param sc is the scope containing the new symbol
 /// \param nm is the local name of the symbol
 /// \param ct is the data-type of the symbol
-inline Symbol::Symbol(Scope *sc,const string &nm,Datatype *ct)
+inline Symbol::Symbol(Scope *sc,const std::string &nm,Datatype *ct)
 
 {
   scope=sc;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.cc
index 35030ffe0..93d390f97 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.cc
@@ -16,6 +16,8 @@
 #include "database_ghidra.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 Scope *ScopeGhidra::buildSubScope(uint8 id,const string &nm)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.hh
index 304bd2914..09a6b6af3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/database_ghidra.hh
@@ -36,7 +36,7 @@ class ScopeGhidra : public Scope {
   ArchitectureGhidra *ghidra;		///< Architecture and connection to the Ghidra client
   mutable ScopeInternal *cache;		///< An internal cache of previously fetched Symbol objects
   mutable RangeList holes;		///< List of (queried) memory ranges with no Symbol in them
-  vector<int4> spacerange;		///< List of address spaces that are in the global range
+  std::vector<int4> spacerange;		///< List of address spaces that are in the global range
   partmap<Address,uint4> flagbaseDefault;	///< Default boolean properties on memory
   mutable bool cacheDirty;		///< Is flagbaseDefault different from cache
   Symbol *dump2Cache(Decoder &decoder) const;			///< Parse a response into the cache
@@ -47,7 +47,7 @@ class ScopeGhidra : public Scope {
   virtual void removeRange(AddrSpace *spc,uintb first,uintb last) {
     throw LowlevelError("remove_range should not be performed on ghidra scope");
   }
-  virtual Scope *buildSubScope(uint8 id,const string &nm);
+  virtual Scope *buildSubScope(uint8 id,const std::string &nm);
   virtual void addSymbolInternal(Symbol *sym) { throw LowlevelError("add_symbol_internal unimplemented"); }
   virtual SymbolEntry *addMapInternal(Symbol *sym,uint4 exfl,const Address &addr,int4 off,int4 sz,
 				      const RangeList &uselim) { throw LowlevelError("addMap unimplemented"); }
@@ -65,13 +65,13 @@ class ScopeGhidra : public Scope {
   void lockDefaultProperties(void) { flagbaseDefault = ghidra->symboltab->getProperties(); cacheDirty = false; }
   virtual ~ScopeGhidra(void);
   virtual void clear(void);
-  virtual SymbolEntry *addSymbol(const string &nm,Datatype *ct,
+  virtual SymbolEntry *addSymbol(const std::string &nm,Datatype *ct,
 				 const Address &addr,const Address &usepoint);
-  virtual string buildVariableName(const Address &addr,
+  virtual std::string buildVariableName(const Address &addr,
 				   const Address &pc,
 				   Datatype *ct,int4 &index,uint4 flags) const {
     return cache->buildVariableName(addr,pc,ct,index,flags); }
-  virtual string buildUndefinedName(void) const { return cache->buildUndefinedName(); }
+  virtual std::string buildUndefinedName(void) const { return cache->buildUndefinedName(); }
   virtual void setAttribute(Symbol *sym,uint4 attr) { cache->setAttribute(sym,attr); }
   virtual void clearAttribute(Symbol *sym,uint4 attr) { cache->clearAttribute(sym,attr); }
   virtual void setDisplayFormat(Symbol *sym,uint4 attr) { cache->setDisplayFormat(sym,attr); }
@@ -89,27 +89,27 @@ class ScopeGhidra : public Scope {
   virtual Funcdata *resolveExternalRefFunction(ExternRefSymbol *sym) const;
 
   virtual SymbolEntry *findOverlap(const Address &addr,int4 size) const { throw LowlevelError("findOverlap unimplemented"); }
-  virtual void findByName(const string &nm,vector<Symbol *> &res) const { throw LowlevelError("findByName unimplemented"); }
-  virtual bool isNameUsed(const string &nm,const Scope *op2) const { throw LowlevelError("isNameUsed unimplemented"); }
+  virtual void findByName(const std::string &nm,std::vector<Symbol *> &res) const { throw LowlevelError("findByName unimplemented"); }
+  virtual bool isNameUsed(const std::string &nm,const Scope *op2) const { throw LowlevelError("isNameUsed unimplemented"); }
 
   virtual MapIterator begin(void) const { throw LowlevelError("begin unimplemented"); }
   virtual MapIterator end(void) const { throw LowlevelError("end unimplemented"); }
-  virtual list<SymbolEntry>::const_iterator beginDynamic(void) const { throw LowlevelError("beginDynamic unimplemented"); }
-  virtual list<SymbolEntry>::const_iterator endDynamic(void) const { throw LowlevelError("endDynamic unimplemented"); }
-  virtual list<SymbolEntry>::iterator beginDynamic(void) { throw LowlevelError("beginDynamic unimplemented"); }
-  virtual list<SymbolEntry>::iterator endDynamic(void) { throw LowlevelError("endDynamic unimplemented"); }
+  virtual std::list<SymbolEntry>::const_iterator beginDynamic(void) const { throw LowlevelError("beginDynamic unimplemented"); }
+  virtual std::list<SymbolEntry>::const_iterator endDynamic(void) const { throw LowlevelError("endDynamic unimplemented"); }
+  virtual std::list<SymbolEntry>::iterator beginDynamic(void) { throw LowlevelError("beginDynamic unimplemented"); }
+  virtual std::list<SymbolEntry>::iterator endDynamic(void) { throw LowlevelError("endDynamic unimplemented"); }
   virtual void clearCategory(int4 cat) { throw LowlevelError("clearCategory unimplemented"); }
   virtual void clearUnlockedCategory(int4 cat) { throw LowlevelError("clearUnlockedCategory unimplemented"); }
   virtual void clearUnlocked(void) { throw LowlevelError("clearUnlocked unimplemented"); }
   virtual void restrictScope(Funcdata *f) { throw LowlevelError("restrictScope unimplemented"); }
   virtual void removeSymbolMappings(Symbol *symbol) { throw LowlevelError("removeSymbolMappings unimplemented"); }
   virtual void removeSymbol(Symbol *symbol) { throw LowlevelError("removeSymbol unimplemented"); }
-  virtual void renameSymbol(Symbol *sym,const string &newname) { throw LowlevelError("renameSymbol unimplemented"); }
+  virtual void renameSymbol(Symbol *sym,const std::string &newname) { throw LowlevelError("renameSymbol unimplemented"); }
   virtual void retypeSymbol(Symbol *sym,Datatype *ct) { throw LowlevelError("retypeSymbol unimplemented"); }
-  virtual string makeNameUnique(const string &nm) const { throw LowlevelError("makeNameUnique unimplemented"); }
+  virtual std::string makeNameUnique(const std::string &nm) const { throw LowlevelError("makeNameUnique unimplemented"); }
   virtual void encode(Encoder &encoder) const { throw LowlevelError("encode unimplemented"); }
   virtual void decode(Decoder &decoder) { throw LowlevelError("decode unimplemented"); }
-  virtual void printEntries(ostream &s) const { throw LowlevelError("printEntries unimplemented"); }
+  virtual void printEntries(std::ostream &s) const { throw LowlevelError("printEntries unimplemented"); }
   virtual int4 getCategorySize(int4 cat) const { throw LowlevelError("getCategorySize unimplemented"); }
   virtual Symbol *getCategorySymbol(int4 cat,int4 ind) const { throw LowlevelError("getCategorySymbol unimplemented"); }
   virtual void setCategory(Symbol *sym,int4 cat,int4 ind) { throw LowlevelError("setCategory unimplemented"); }
@@ -131,10 +131,10 @@ class ScopeGhidraNamespace : public ScopeInternal {
   virtual SymbolEntry *addMapInternal(Symbol *sym,uint4 exfl,const Address &addr,int4 off,int4 sz,
 				      const RangeList &uselim);
 public:
-  ScopeGhidraNamespace(uint8 id,const string &nm,ArchitectureGhidra *g)
+  ScopeGhidraNamespace(uint8 id,const std::string &nm,ArchitectureGhidra *g)
     : ScopeInternal(id,nm,g) { ghidra = g; }		///< Constructor
 
-  virtual bool isNameUsed(const string &nm,const Scope *op2) const;
+  virtual bool isNameUsed(const std::string &nm,const Scope *op2) const;
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
index ce5706bcd..14ad6929e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
@@ -15,6 +15,8 @@
  */
 #include "double.hh"
 
+using namespace std;
+
 /// Internally, the \b lo and \b hi Varnodes are set to null, and the \b val field
 /// holds the constant value.
 /// \param sz is the size in bytes of the constant
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/double.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/double.hh
index 418d1f85e..09640b9d5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/double.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/double.hh
@@ -71,8 +71,8 @@ class SplitVarnode {
   static bool adjacentOffsets(Varnode *vn1,Varnode *vn2,uintb size1);
   static bool testContiguousPointers(PcodeOp *most,PcodeOp *least,PcodeOp *&first,PcodeOp *&second,AddrSpace *&spc);
   static bool isAddrTiedContiguous(Varnode *lo,Varnode *hi,Address &res);
-  static void wholeList(Varnode *w,vector<SplitVarnode> &splitvec);
-  static void findCopies(const SplitVarnode &in,vector<SplitVarnode> &splitvec);
+  static void wholeList(Varnode *w,std::vector<SplitVarnode> &splitvec);
+  static void findCopies(const SplitVarnode &in,std::vector<SplitVarnode> &splitvec);
   static void getTrueFalse(PcodeOp *boolop,bool flip,BlockBasic *&trueout,BlockBasic *&falseout);
   static bool otherwiseEmpty(PcodeOp *branchop);
   static bool verifyMultNegOne(PcodeOp *op);
@@ -87,8 +87,8 @@ class SplitVarnode {
   static bool prepareBoolOp(SplitVarnode &in1,SplitVarnode &in2,PcodeOp *testop);
   static void createBoolOp(Funcdata &data,PcodeOp *cbranch,SplitVarnode &in1,SplitVarnode &in2,
 			   OpCode opc);
-  static PcodeOp *preparePhiOp(SplitVarnode &out,vector<SplitVarnode> &inlist);
-  static void createPhiOp(Funcdata &data,SplitVarnode &out,vector<SplitVarnode> &inlist,
+  static PcodeOp *preparePhiOp(SplitVarnode &out,std::vector<SplitVarnode> &inlist);
+  static void createPhiOp(Funcdata &data,SplitVarnode &out,std::vector<SplitVarnode> &inlist,
 			  PcodeOp *existop);
   static bool prepareIndirectOp(SplitVarnode &in,PcodeOp *affector);
   static void replaceIndirectOp(Funcdata &data,SplitVarnode &out,SplitVarnode &in,PcodeOp *affector);
@@ -305,38 +305,38 @@ class IndirectForm {
 class RuleDoubleIn : public Rule {
   int4 attemptMarking(Funcdata &data,Varnode *vn,PcodeOp *subpieceOp);
 public:
-  RuleDoubleIn(const string &g) : Rule(g, 0, "doublein") {}	///< Constructor
+  RuleDoubleIn(const std::string &g) : Rule(g, 0, "doublein") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleIn(getGroup());
   }
   virtual void reset(Funcdata &data);
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleDoubleLoad : public Rule {
 public:
-  RuleDoubleLoad(const string &g) : Rule( g, 0, "doubleload") {}
+  RuleDoubleLoad(const std::string &g) : Rule( g, 0, "doubleload") {}
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleLoad(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
-  static PcodeOp *noWriteConflict(PcodeOp *op1,PcodeOp *op2,AddrSpace *spc,vector<PcodeOp *> *indirects);
+  static PcodeOp *noWriteConflict(PcodeOp *op1,PcodeOp *op2,AddrSpace *spc,std::vector<PcodeOp *> *indirects);
 };
 
 class RuleDoubleStore : public Rule {
 public:
-  RuleDoubleStore(const string &g) : Rule( g, 0, "doublestore") {}
+  RuleDoubleStore(const std::string &g) : Rule( g, 0, "doublestore") {}
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleStore(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
-  static bool testIndirectUse(PcodeOp *op1,PcodeOp *op2,const vector<PcodeOp *> &indirects);
-  static void reassignIndirects(Funcdata &data,PcodeOp *newStore,const vector<PcodeOp *> &indirects);
+  static bool testIndirectUse(PcodeOp *op1,PcodeOp *op2,const std::vector<PcodeOp *> &indirects);
+  static void reassignIndirects(Funcdata &data,PcodeOp *newStore,const std::vector<PcodeOp *> &indirects);
 };
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.cc
index 9d8b08053..6c5fb790d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.cc
@@ -17,6 +17,8 @@
 #include "funcdata.hh"
 #include "crc32.hh"
 
+using namespace std;
+
 // Table for how to hash opcodes, lumps certain operators (i.e. ADD SUB PTRADD PTRSUB) into one hash
 // zero indicates the operator should be skipped
 const uint4 DynamicHash::transtable[] = {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.hh
index 2a500d56b..0973a626f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/dynamic.hh
@@ -62,10 +62,10 @@ class DynamicHash {
   uint4 opproc;			///< Number of PcodeOps processed in the \b markop list so far
   uint4 opedgeproc;		///< Number of edges processed in the \b opedge list
 
-  vector<const PcodeOp *> markop;	///< List of PcodeOps in the sub-graph being hashed
-  vector<const Varnode *> markvn;	///< List of Varnodes is the sub-graph being hashed
-  vector<const Varnode *> vnedge;	///< A staging area for Varnodes before formally adding to the sub-graph
-  vector<ToOpEdge> opedge;		///< The edges in the sub-graph
+  std::vector<const PcodeOp *> markop;	///< List of PcodeOps in the sub-graph being hashed
+  std::vector<const Varnode *> markvn;	///< List of Varnodes is the sub-graph being hashed
+  std::vector<const Varnode *> vnedge;	///< A staging area for Varnodes before formally adding to the sub-graph
+  std::vector<ToOpEdge> opedge;		///< The edges in the sub-graph
 
   Address addrresult;			///< Address most closely associated with variable
   uint8 hash;				///< The calculated hash value
@@ -88,8 +88,8 @@ class DynamicHash {
   uint8 getHash(void) const { return hash; }		///< Get the (current) hash
   
   const Address &getAddress(void) const { return addrresult; }	///< Get the (current) address
-  static void gatherFirstLevelVars(vector<Varnode *> &varlist,const Funcdata *fd,const Address &addr,uint8 h);
-  static void gatherOpsAtAddress(vector<PcodeOp *> &opList,const Funcdata *fd,const Address &addr);
+  static void gatherFirstLevelVars(std::vector<Varnode *> &varlist,const Funcdata *fd,const Address &addr,uint8 h);
+  static void gatherOpsAtAddress(std::vector<PcodeOp *> &opList,const Funcdata *fd,const Address &addr);
   static int4 getSlotFromHash(uint8 h);			///< Retrieve the encoded slot from a hash
   static uint4 getMethodFromHash(uint8 h);		///< Retrieve the encoded method from a hash
   static OpCode getOpCodeFromHash(uint8 h);		///< Retrieve the encoded op-code from a hash
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
index 88936cedd..5025d952d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.cc
@@ -15,6 +15,8 @@
  */
 #include "emulate.hh"
 
+using namespace std;
+
 /// Any time the emulator is about to execute a user-defined pcode op with the given name,
 /// the indicated breakpoint is invoked first. The break table does \e not assume responsibility
 /// for freeing the breakpoint object.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.hh
index bfe874751..d7d33a980 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulate.hh
@@ -137,11 +137,11 @@ inline void BreakCallBack::setEmulate(Emulate *emu)
 class BreakTableCallBack : public BreakTable {
   Emulate *emulate;		///< The emulator associated with this table
   Translate *trans;		///< The translator 
-  map<Address,BreakCallBack *> addresscallback;	///< a container of pcode based breakpoints
-  map<uintb,BreakCallBack *> pcodecallback; ///< a container of addressed based breakpoints
+  std::map<Address,BreakCallBack *> addresscallback;	///< a container of pcode based breakpoints
+  std::map<uintb,BreakCallBack *> pcodecallback; ///< a container of addressed based breakpoints
 public:
   BreakTableCallBack(Translate *t); ///< Basic breaktable constructor
-  void registerPcodeCallback(const string &nm,BreakCallBack *func); ///< Register a pcode based breakpoint
+  void registerPcodeCallback(const std::string &nm,BreakCallBack *func); ///< Register a pcode based breakpoint
   void registerAddressCallback(const Address &addr,BreakCallBack *func); ///< Register an address based breakpoint
   virtual void setEmulate(Emulate *emu); ///< Associate an emulator with all breakpoints in the table
   virtual bool doPcodeOpBreak(PcodeOpRaw *curop); ///< Invoke any breakpoints for the given pcode op
@@ -276,14 +276,14 @@ inline MemoryState *EmulateMemory::getMemoryState(void) const
 ///
 /// This is used for emulation when full Varnode and PcodeOp objects aren't needed
 class PcodeEmitCache : public PcodeEmit {
-  vector<PcodeOpRaw *> &opcache;	///< The cache of current p-code ops
-  vector<VarnodeData *> &varcache;	///< The cache of current varnodes
-  const vector<OpBehavior *> &inst;	///< Array of behaviors for translating OpCode
+  std::vector<PcodeOpRaw *> &opcache;	///< The cache of current p-code ops
+  std::vector<VarnodeData *> &varcache;	///< The cache of current varnodes
+  const std::vector<OpBehavior *> &inst;	///< Array of behaviors for translating OpCode
   uintm uniq;				///< Starting offset for defining temporaries in \e unique space
   VarnodeData *createVarnode(const VarnodeData *var);	///< Clone and cache a raw VarnodeData
 public:
-  PcodeEmitCache(vector<PcodeOpRaw *> &ocache,vector<VarnodeData *> &vcache,
-		 const vector<OpBehavior *> &in,uintb uniqReserve);	///< Constructor
+  PcodeEmitCache(std::vector<PcodeOpRaw *> &ocache,std::vector<VarnodeData *> &vcache,
+		 const std::vector<OpBehavior *> &in,uintb uniqReserve);	///< Constructor
   virtual void dump(const Address &addr,OpCode opc,VarnodeData *outvar,VarnodeData *vars,int4 isize);
 };
 
@@ -295,9 +295,9 @@ class PcodeEmitCache : public PcodeEmit {
 /// are additional methods for inspecting the pcode ops in the current instruction as a sequence.
 class EmulatePcodeCache : public EmulateMemory {
   Translate *trans;		///< The SLEIGH translator
-  vector<PcodeOpRaw *> opcache;	///< The cache of current p-code ops
-  vector<VarnodeData *> varcache;	///< The cache of current varnodes
-  vector<OpBehavior *> inst;	///< Map from OpCode to OpBehavior
+  std::vector<PcodeOpRaw *> opcache;	///< The cache of current p-code ops
+  std::vector<VarnodeData *> varcache;	///< The cache of current varnodes
+  std::vector<OpBehavior *> inst;	///< Map from OpCode to OpBehavior
   BreakTable *breaktable;	///< The table of breakpoints
   Address current_address;	///< Address of current instruction being executed
   bool instruction_start;	///< \b true if next pcode op is start of instruction
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
index fe37a7be2..8e022e3a3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.cc
@@ -16,6 +16,8 @@
 #include "architecture.hh"
 #include "emulateutil.hh"
 
+using namespace std;
+
 /// \param g is the Architecture providing the LoadImage
 EmulatePcodeOp::EmulatePcodeOp(Architecture *g)
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.hh
index a06b49ce3..92f76bd75 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/emulateutil.hh
@@ -110,9 +110,9 @@ class EmulatePcodeOp : public Emulate {
 /// class, which can be repeatedly used by calling resetMemory() between executions.
 class EmulateSnippet : public Emulate {
   Architecture *glb;			///< The underlying Architecture for the program being emulated
-  vector<PcodeOpRaw *> opList;		///< Sequence of p-code ops to be executed
-  vector<VarnodeData *> varList;	///< Varnodes allocated for ops
-  map<uintb,uintb> tempValues;		///< Values stored in temporary registers
+  std::vector<PcodeOpRaw *> opList;		///< Sequence of p-code ops to be executed
+  std::vector<VarnodeData *> varList;	///< Varnodes allocated for ops
+  std::map<uintb,uintb> tempValues;		///< Values stored in temporary registers
   PcodeOpRaw *currentOp;		///< Current p-code op being executed
   int4 pos;				///< Index of current p-code op being executed
 
@@ -153,7 +153,7 @@ class EmulateSnippet : public Emulate {
   /// Reset the memory state, and set the first p-code op as current.
   void resetMemory(void) { tempValues.clear(); setCurrentOp(0); emu_halted = false; }
 
-  PcodeEmit *buildEmitter(const vector<OpBehavior *> &inst,uintb uniqReserve);
+  PcodeEmit *buildEmitter(const std::vector<OpBehavior *> &inst,uintb uniqReserve);
   bool checkForLegalCode(void) const;
 
   /// \brief Set the current executing p-code op by index
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/error.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/error.hh
index 788b2421d..d2b35046e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/error.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/error.hh
@@ -33,8 +33,6 @@
 #include <cstring>
 #include <cctype>
 
-using namespace std;
-
 /// \brief The lowest level error generated by the decompiler
 ///
 /// This is the base error for all exceptions thrown by the
@@ -42,9 +40,9 @@ using namespace std;
 /// level errors that immediately abort decompilation (usually
 /// for just a single function).
 struct LowlevelError {
-  string explain;		///< Explanatory string
+  std::string explain;		///< Explanatory string
   /// Initialize the error with an explanatory string
-  LowlevelError(const string &s) { explain = s; }
+  LowlevelError(const std::string &s) { explain = s; }
 };
 
 /// \brief A generic recoverable error
@@ -54,7 +52,7 @@ struct LowlevelError {
 /// into account.
 struct RecovError : public LowlevelError {
   /// Initialize the error with an explanatory string
-  RecovError(const string &s) : LowlevelError(s) {}
+  RecovError(const std::string &s) : LowlevelError(s) {}
 };
 
 /// \brief An error generated while parsing a command or language
@@ -64,7 +62,7 @@ struct RecovError : public LowlevelError {
 /// C syntax.
 struct ParseError : public LowlevelError { // Parsing error
   /// Initialize the error with an explanatory string
-  ParseError(const string &s) : LowlevelError(s) {}
+  ParseError(const std::string &s) : LowlevelError(s) {}
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.cc
index 9ab665cd3..56cd2620f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.cc
@@ -29,6 +29,8 @@ extern "C" {
 }
 #endif
 
+using namespace std;
+
 // Path name separator
 #ifdef _WINDOWS
 char FileManage::separator = '\\';
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.hh
index 9cd6f4e8f..f0c7423a0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/filemanage.hh
@@ -24,26 +24,24 @@
 #include <sstream>
 #include <fstream>
 
-using namespace std;
-
 class FileManage {
-  vector<string> pathlist;	// List of paths to search for files
+  std::vector<std::string> pathlist;	// List of paths to search for files
   static char separator;
-  static string buildPath(const vector<string> &pathels,int level);
-  static bool testDevelopmentPath(const vector<string> &pathels,int level,string &root);
-  static bool testInstallPath(const vector<string> &pathels,int level,string &root);
+  static std::string buildPath(const std::vector<std::string> &pathels,int level);
+  static bool testDevelopmentPath(const std::vector<std::string> &pathels,int level,std::string &root);
+  static bool testInstallPath(const std::vector<std::string> &pathels,int level,std::string &root);
 public:
-  void addDir2Path(const string &path);
+  void addDir2Path(const std::string &path);
   void addCurrentDir(void);
-  void findFile(string &res,const string &name) const; // Resolve full pathname
-  void matchList(vector<string> &res,const string &match,bool isSuffix) const; // List of files with suffix
-  static bool isDirectory(const string &path);
-  static void matchListDir(vector<string> &res,const string &match,bool isSuffix,const string &dir,bool allowdot);
-  static void directoryList(vector<string> &res,const string &dirname,bool allowdot=false);
-  static void scanDirectoryRecursive(vector<string> &res,const string &matchname,const string &rootpath,int maxdepth);
-  static void splitPath(const string &full,string &path,string &base);
-  static bool isAbsolutePath(const string &full) { if (full.empty()) return false; return (full[0] == separator); }
-  static string discoverGhidraRoot(const char *argv0);
+  void findFile(std::string &res,const std::string &name) const; // Resolve full pathname
+  void matchList(std::vector<std::string> &res,const std::string &match,bool isSuffix) const; // List of files with suffix
+  static bool isDirectory(const std::string &path);
+  static void matchListDir(std::vector<std::string> &res,const std::string &match,bool isSuffix,const std::string &dir,bool allowdot);
+  static void directoryList(std::vector<std::string> &res,const std::string &dirname,bool allowdot=false);
+  static void scanDirectoryRecursive(std::vector<std::string> &res,const std::string &matchname,const std::string &rootpath,int maxdepth);
+  static void splitPath(const std::string &full,std::string &path,std::string &base);
+  static bool isAbsolutePath(const std::string &full) { if (full.empty()) return false; return (full[0] == separator); }
+  static std::string discoverGhidraRoot(const char *argv0);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/float.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/float.cc
index 068c7e991..8f843d1da 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/float.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/float.cc
@@ -19,6 +19,8 @@
 #include <cmath>
 #include "address.hh"
 
+using namespace std;
+
 /// Set format for a given encoding size according to IEEE 754 standards
 /// \param sz is the size of the encoding in bytes
 FloatFormat::FloatFormat(int4 sz)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/float.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/float.hh
index fff9075f1..f9c11b67b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/float.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/float.hh
@@ -92,7 +92,7 @@ class FloatFormat {
   uintb opInt2Float(uintb a,int4 sizein) const;		///< Convert integer to floating-point
   uintb opFloat2Float(uintb a,const FloatFormat &outformat) const;	///< Convert between floating-point precisions
 
-  void saveXml(ostream &s) const;			///< Save the format to an XML stream
+  void saveXml(std::ostream &s) const;			///< Save the format to an XML stream
   void restoreXml(const Element *el);			///< Restore the format from XML
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
index c59ebdf61..c7c37dc6c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
@@ -15,6 +15,8 @@
  */
 #include "flow.hh"
 
+using namespace std;
+
 /// Prepare for tracing flow for a new function.
 /// The Funcdata object and references to its internal containers must be explicitly given.
 /// \param d is the new function to trace
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.hh
index 7362e4b18..c2c11d0dd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.hh
@@ -80,15 +80,15 @@ class FlowInfo {
   Funcdata &data;			///< The function being flow-followed
   PcodeOpBank &obank;			///< Container for generated p-code
   BlockGraph &bblocks;			///< Container for the control-flow graph
-  vector<FuncCallSpecs *> &qlst;	///< The list of discovered sub-function call sites
+  std::vector<FuncCallSpecs *> &qlst;	///< The list of discovered sub-function call sites
   PcodeEmitFd emitter;			///< PCodeOp factory (configured to allocate into \b data and \b obank)
-  vector<Address> unprocessed;		///< Addresses which are permanently unprocessed
-  vector<Address> addrlist;		///< Addresses to which there is flow
-  vector<PcodeOp *> tablelist;		///< List of BRANCHIND ops (preparing for jump table recovery)
-  vector<PcodeOp *> injectlist;		///< List of p-code ops that need injection
-  map<Address,VisitStat> visited;	///< Map of machine instructions that have been visited so far
-  list<PcodeOp *> block_edge1;		///< Source p-code op (Edges between basic blocks)
-  list<PcodeOp *> block_edge2;		///< Destination p-code op (Edges between basic blocks)
+  std::vector<Address> unprocessed;		///< Addresses which are permanently unprocessed
+  std::vector<Address> addrlist;		///< Addresses to which there is flow
+  std::vector<PcodeOp *> tablelist;		///< List of BRANCHIND ops (preparing for jump table recovery)
+  std::vector<PcodeOp *> injectlist;		///< List of p-code ops that need injection
+  std::map<Address,VisitStat> visited;	///< Map of machine instructions that have been visited so far
+  std::list<PcodeOp *> block_edge1;		///< Source p-code op (Edges between basic blocks)
+  std::list<PcodeOp *> block_edge2;		///< Destination p-code op (Edges between basic blocks)
   uint4 insn_count;			///< Number of instructions flowed through
   uint4 insn_max;			///< Maximum number of instructions
   Address baddr;			///< Start of range in which we are allowed to flow
@@ -98,8 +98,8 @@ class FlowInfo {
   bool flowoverride_present;		///< Does the function have registered flow override instructions
   uint4 flags;				///< Boolean options for flow following
   Funcdata *inline_head;		///< First function in the in-lining chain
-  set<Address> *inline_recursion;	///< Active list of addresses for function that are in-lined
-  set<Address> inline_base;		///< Storage for addresses of functions that are in-lined
+  std::set<Address> *inline_recursion;	///< Active list of addresses for function that are in-lined
+  std::set<Address> inline_base;		///< Storage for addresses of functions that are in-lined
   bool hasPossibleUnreachable(void) const { return ((flags & possible_unreachable)!=0); }	///< Are there possible unreachable ops
   void setPossibleUnreachable(void) { flags |= possible_unreachable; }	///< Mark that there may be unreachable ops
   void clearProperties(void);		///< Clear any discovered flow properties
@@ -107,8 +107,8 @@ class FlowInfo {
     return (visited.find(addr) != visited.end()); }	///< Has the given instruction (address) been seen in flow
   PcodeOp *fallthruOp(PcodeOp *op) const;		///< Find fallthru pcode-op for given op
   void newAddress(PcodeOp *from,const Address &to);	///< Register a new (non fall-thru) flow target
-  void deleteRemainingOps(list<PcodeOp *>::const_iterator oiter);
-  PcodeOp *xrefControlFlow(list<PcodeOp *>::const_iterator oiter,bool &startbasic,bool &isfallthru,FuncCallSpecs *fc);
+  void deleteRemainingOps(std::list<PcodeOp *>::const_iterator oiter);
+  PcodeOp *xrefControlFlow(std::list<PcodeOp *>::const_iterator oiter,bool &startbasic,bool &isfallthru,FuncCallSpecs *fc);
   bool processInstruction(const Address &curaddr,bool &startbasic);
   void fallthru(void);					///< Process (the next) sequence of instructions in fall-thru order
   PcodeOp *findRelTarget(PcodeOp *op,Address &res) const;
@@ -135,10 +135,10 @@ class FlowInfo {
   void checkMultistageJumptables(void);
   void deleteCallSpec(FuncCallSpecs *fc);		///< Remove the given call site from the list for \b this function
   void truncateIndirectJump(PcodeOp *op,int4 failuremode);  	///< Treat indirect jump as indirect call that never returns
-  static bool isInArray(vector<PcodeOp *> &array,PcodeOp *op);
+  static bool isInArray(std::vector<PcodeOp *> &array,PcodeOp *op);
 public:
-  FlowInfo(Funcdata &d,PcodeOpBank &o,BlockGraph &b,vector<FuncCallSpecs *> &q);	///< Constructor
-  FlowInfo(Funcdata &d,PcodeOpBank &o,BlockGraph &b,vector<FuncCallSpecs *> &q,const FlowInfo *op2);	///< Cloning constructor
+  FlowInfo(Funcdata &d,PcodeOpBank &o,BlockGraph &b,std::vector<FuncCallSpecs *> &q);	///< Constructor
+  FlowInfo(Funcdata &d,PcodeOpBank &o,BlockGraph &b,std::vector<FuncCallSpecs *> &q,const FlowInfo *op2);	///< Cloning constructor
   void setRange(const Address &b,const Address &e) { baddr = b; eaddr = e; }	///< Establish the flow bounds
   void setMaximumInstructions(uint4 max) { insn_max = max; }	///< Set the maximum number of instructions
   void setFlags(uint4 val) { flags |= val; }	///< Enable a specific option
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
index d1bd842d8..064b98a34 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
@@ -16,6 +16,8 @@
 #include "fspec.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_CUSTOM = AttributeId("custom",114);
 AttributeId ATTRIB_DOTDOTDOT = AttributeId("dotdotdot",115);
 AttributeId ATTRIB_EXTENSION = AttributeId("extension",116);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
index 08487fa4e..e086556b0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
@@ -58,7 +58,7 @@ extern ElementId ELEM_UNAFFECTED;	///< Marshaling element \<unaffected>
 
 /// \brief Exception thrown when a prototype can't be modeled properly
 struct ParamUnassignedError : public LowlevelError {
-  ParamUnassignedError(const string &s) : LowlevelError(s) {}	///< Constructor
+  ParamUnassignedError(const std::string &s) : LowlevelError(s) {}	///< Constructor
 };
 
 /// \brief A contiguous range of memory that can be used to pass parameters
@@ -110,9 +110,9 @@ class ParamEntry {
   int4 alignment;		///< How much alignment (0 means only 1 logical value is allowed)
   int4 numslots;		///< (Maximum) number of slots that can store separate parameters
   JoinRecord *joinrec;		///< Non-null if this is logical variable from joined pieces
-  static const ParamEntry *findEntryByStorage(const list<ParamEntry> &entryList,const VarnodeData &vn);
-  void resolveJoin(list<ParamEntry> &curList); 	///< Make adjustments for a \e join ParamEntry
-  void resolveOverlap(list<ParamEntry> &curList);	///< Make adjustments for ParamEntry that overlaps others
+  static const ParamEntry *findEntryByStorage(const std::list<ParamEntry> &entryList,const VarnodeData &vn);
+  void resolveJoin(std::list<ParamEntry> &curList); 	///< Make adjustments for a \e join ParamEntry
+  void resolveOverlap(std::list<ParamEntry> &curList);	///< Make adjustments for ParamEntry that overlaps others
 
   /// \brief Is the logical value left-justified within its container
   bool isLeftJustified(void) const { return (((flags&force_left_justify)!=0)||(!spaceid->isBigEndian())); }
@@ -140,7 +140,7 @@ class ParamEntry {
   AddrSpace *getSpace(void) const { return spaceid; }	///< Get the address space containing \b this entry
   uintb getBase(void) const { return addressbase; }	///< Get the starting offset of \b this entry
   Address getAddrBySlot(int4 &slot,int4 sz) const;
-  void decode(Decoder &decoder,bool normalstack,bool grouped,list<ParamEntry> &curList);
+  void decode(Decoder &decoder,bool normalstack,bool grouped,std::list<ParamEntry> &curList);
   bool isParamCheckHigh(void) const { return ((flags & extracheck_high)!=0); }	///< Return \b true if there is a high overlap
   bool isParamCheckLow(void) const { return ((flags & extracheck_low)!=0); }	///< Return \b true if there is a low overlap
   static void orderWithinGroup(const ParamEntry &entry1,const ParamEntry &entry2);	///< Enforce ParamEntry group ordering rules
@@ -275,7 +275,7 @@ class ParamTrial {
 /// they are in address order for input Varnodes to the active function.
 /// After, the trials are put into formal parameter order, as dictated by the PrototypeModel.
 class ParamActive {
-  vector<ParamTrial> trial;	///< The list of parameter trials
+  std::vector<ParamTrial> trial;	///< The list of parameter trials
   int4 slotbase;		///< Slot where next parameter will go
   int4 stackplaceholder;	///< Which call input slot holds the stack placeholder
   int4 numpasses;		///< Number of attempts at evaluating parameters
@@ -341,10 +341,10 @@ class FspecSpace : public AddrSpace {
   FspecSpace(AddrSpaceManager *m,const Translate *t,int4 ind);	///< Constructor
   virtual void encodeAttributes(Encoder &encoder,uintb offset) const;
   virtual void encodeAttributes(Encoder &encoder,uintb offset,int4 size) const;
-  virtual void printRaw(ostream &s,uintb offset) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void printRaw(std::ostream &s,uintb offset) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
-  static const string NAME;		///< Reserved name for the fspec space
+  static const std::string NAME;		///< Reserved name for the fspec space
 };
 
 /// \brief Basic elements of a parameter: address, data-type, properties
@@ -419,7 +419,7 @@ class ParamList {
   /// \param proto is the ordered list of data-types
   /// \param typefactory is the TypeFactory (for constructing pointers)
   /// \param res will contain the storage locations corresponding to the datatypes
-  virtual void assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const=0;
+  virtual void assignMap(const std::vector<Datatype *> &proto,TypeFactory &typefactory,std::vector<ParameterPieces> &res) const=0;
 
   /// \brief Given an unordered list of storage locations, calculate a function prototype
   ///
@@ -538,7 +538,7 @@ class ParamList {
   /// \param decoder is the stream decoder
   /// \param effectlist is a container collecting EffectRecords across all parameters
   /// \param normalstack is \b true if parameters are pushed on the stack in the normal order
-  virtual void decode(Decoder &decoder,vector<EffectRecord> &effectlist,bool normalstack)=0;
+  virtual void decode(Decoder &decoder,std::vector<EffectRecord> &effectlist,bool normalstack)=0;
 
   virtual ParamList *clone(void) const=0;	///< Clone this parameter list model
 };
@@ -559,11 +559,11 @@ class ParamListStandard : public ParamList {
   int4 pointermax; 			///< If non-zero, maximum size of a data-type before converting to a pointer
   bool thisbeforeret;			///< Does a \b this parameter come before a hidden return parameter
   int4 resourceTwoStart;		///< If there are two resource sections, the group of the first entry in the second section
-  list<ParamEntry> entry;		///< The ordered list of parameter entries
-  vector<ParamEntryResolver *> resolverMap;	///< Map from space id to resolver
+  std::list<ParamEntry> entry;		///< The ordered list of parameter entries
+  std::vector<ParamEntryResolver *> resolverMap;	///< Map from space id to resolver
   AddrSpace *spacebase;			///< Address space containing relative offset parameters
   const ParamEntry *findEntry(const Address &loc,int4 size) const;	///< Given storage location find matching ParamEntry
-  Address assignAddress(const Datatype *tp,vector<int4> &status) const;	///< Assign storage for given parameter data-type
+  Address assignAddress(const Datatype *tp,std::vector<int4> &status) const;	///< Assign storage for given parameter data-type
   const ParamEntry *selectUnreferenceEntry(int4 grp,type_metatype prefType) const;	///< Select entry to fill an unreferenced param
   void buildTrialMap(ParamActive *active) const;	///< Build map from parameter trials to model ParamEntrys
   void separateSections(ParamActive *active,int4 &oneStart,int4 &oneStop,int4 &twoStart,int4 &twoStop) const;
@@ -575,17 +575,17 @@ class ParamListStandard : public ParamList {
   void calcDelay(void);		///< Calculate the maximum heritage delay for any potential parameter in this list
   void addResolverRange(AddrSpace *spc,uintb first,uintb last,ParamEntry *paramEntry,int4 position);
   void populateResolver(void);	///< Build the ParamEntry resolver maps
-  void parsePentry(Decoder &decoder,vector<EffectRecord> &effectlist,
+  void parsePentry(Decoder &decoder,std::vector<EffectRecord> &effectlist,
 		   int4 groupid,bool normalstack,bool autokill,bool splitFloat,bool grouped);
-  void parseGroup(Decoder &decoder,vector<EffectRecord> &effectlist,
+  void parseGroup(Decoder &decoder,std::vector<EffectRecord> &effectlist,
 		  int4 groupid,bool normalstack,bool autokill,bool splitFloat);
 public:
   ParamListStandard(void) {}						///< Construct for use with decode()
   ParamListStandard(const ParamListStandard &op2);			///< Copy constructor
   virtual ~ParamListStandard(void);
-  const list<ParamEntry> &getEntry(void) const { return entry; }	///< Get the list of parameter entries
+  const std::list<ParamEntry> &getEntry(void) const { return entry; }	///< Get the list of parameter entries
   virtual uint4 getType(void) const { return p_standard; }
-  virtual void assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
+  virtual void assignMap(const std::vector<Datatype *> &proto,TypeFactory &typefactory,std::vector<ParameterPieces> &res) const;
   virtual void fillinMap(ParamActive *active) const;
   virtual bool checkJoin(const Address &hiaddr,int4 hisize,const Address &loaddr,int4 losize) const;
   virtual bool checkSplit(const Address &loc,int4 size,int4 splitpoint) const;
@@ -598,7 +598,7 @@ class ParamListStandard : public ParamList {
   virtual AddrSpace *getSpacebase(void) const { return spacebase; }
   virtual void getRangeList(AddrSpace *spc,RangeList &res) const;
   virtual int4 getMaxDelay(void) const { return maxdelay; }
-  virtual void decode(Decoder &decoder,vector<EffectRecord> &effectlist,bool normalstack);
+  virtual void decode(Decoder &decoder,std::vector<EffectRecord> &effectlist,bool normalstack);
   virtual ParamList *clone(void) const;
 };
 
@@ -614,7 +614,7 @@ class ParamListRegisterOut : public ParamListStandard {
   ParamListRegisterOut(void) : ParamListStandard() {}		///< Constructor
   ParamListRegisterOut(const ParamListRegisterOut &op2) : ParamListStandard(op2) {}	///< Copy constructor
   virtual uint4 getType(void) const { return p_register_out; }
-  virtual void assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
+  virtual void assignMap(const std::vector<Datatype *> &proto,TypeFactory &typefactory,std::vector<ParameterPieces> &res) const;
   virtual void fillinMap(ParamActive *active) const;
   virtual bool possibleParam(const Address &loc,int4 size) const;
   virtual ParamList *clone(void) const;
@@ -649,8 +649,8 @@ class ParamListStandardOut : public ParamListRegisterOut {
   ParamListStandardOut(void) : ParamListRegisterOut() {}	///< Constructor for use with decode()
   ParamListStandardOut(const ParamListStandardOut &op2) : ParamListRegisterOut(op2) {}	///< Copy constructor
   virtual uint4 getType(void) const { return p_standard_out; }
-  virtual void assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
-  virtual void decode(Decoder &decoder,vector<EffectRecord> &effectlist,bool normalstack);
+  virtual void assignMap(const std::vector<Datatype *> &proto,TypeFactory &typefactory,std::vector<ParameterPieces> &res) const;
+  virtual void decode(Decoder &decoder,std::vector<EffectRecord> &effectlist,bool normalstack);
   virtual ParamList *clone(void) const;
 };
 
@@ -669,7 +669,7 @@ class ParamListMerged : public ParamListStandard {
   void foldIn(const ParamListStandard &op2);				///< Add another model to the union
   void finalize(void) { populateResolver(); }				///< Fold-ins are finished, finalize \b this
   virtual uint4 getType(void) const { return p_merged; }
-  virtual void assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const {
+  virtual void assignMap(const std::vector<Datatype *> &proto,TypeFactory &typefactory,std::vector<ParameterPieces> &res) const {
     throw LowlevelError("Cannot assign prototype before model has been resolved"); }
   virtual void fillinMap(ParamActive *active) const {
     throw LowlevelError("Cannot determine prototype before model has been resolved"); }
@@ -701,13 +701,13 @@ class ParamListMerged : public ParamListStandard {
 class ProtoModel {
   friend class ProtoModelMerged;
   Architecture *glb;		///< The Architecture owning this prototype model
-  string name;			///< Name of the model
+  std::string name;			///< Name of the model
   int4 extrapop;		///< Extra bytes popped from stack
   ParamList *input;		///< Resource model for input parameters
   ParamList *output;		///< Resource model for output parameters
   const ProtoModel *compatModel;	///< The model \b this is a copy of
-  vector<EffectRecord> effectlist; ///< List of side-effects
-  vector<VarnodeData> likelytrash;	///< Storage locations potentially carrying \e trash values
+  std::vector<EffectRecord> effectlist; ///< List of side-effects
+  std::vector<VarnodeData> likelytrash;	///< Storage locations potentially carrying \e trash values
   int4 injectUponEntry;		///< Id of injection to perform at beginning of function (-1 means not used)
   int4 injectUponReturn;	///< Id of injection to perform after a call to this function (-1 means not used)
   RangeList localrange;		///< Memory range(s) of space-based locals
@@ -718,15 +718,15 @@ class ProtoModel {
   bool isPrinted;		///< True if this model should be printed as part of function declarations
   void defaultLocalRange(void);	///< Set the default stack range used for local variables
   void defaultParamRange(void);	///< Set the default stack range used for input parameters
-  void buildParamList(const string &strategy);	 ///< Establish the main resource lists for input and output parameters.
+  void buildParamList(const std::string &strategy);	 ///< Establish the main resource lists for input and output parameters.
 public:
   enum {
     extrapop_unknown = 0x8000	///< Reserved extrapop value meaning the function's \e extrapop is unknown
   };
   ProtoModel(Architecture *g);	///< Constructor for use with decode()
-  ProtoModel(const string &nm,const ProtoModel &op2);	///< Copy constructor changing the name
+  ProtoModel(const std::string &nm,const ProtoModel &op2);	///< Copy constructor changing the name
   virtual ~ProtoModel(void);				///< Destructor
-  const string &getName(void) const { return name; }	///< Get the name of the prototype model
+  const std::string &getName(void) const { return name; }	///< Get the name of the prototype model
   Architecture *getArch(void) const { return glb; }	///< Get the owning Architecture
   const ProtoModel *getAliasParent(void) const { return compatModel; }	///< Return \e model \b this is an alias of (or null)
   uint4 hasEffect(const Address &addr,int4 size) const;	///< Determine side-effect of \b this on the given memory range
@@ -750,7 +750,7 @@ class ProtoModel {
   void deriveOutputMap(ParamActive *active) const {
     output->fillinMap(active); }
 
-  void assignParameterStorage(const vector<Datatype *> &typelist,vector<ParameterPieces> &res,bool ignoreOutputError);
+  void assignParameterStorage(const std::vector<Datatype *> &typelist,std::vector<ParameterPieces> &res,bool ignoreOutputError);
 
   /// \brief Check if the given two input storage locations can represent a single logical parameter
   ///
@@ -789,10 +789,10 @@ class ProtoModel {
 
   const RangeList &getLocalRange(void) const { return localrange; }	///< Get the range of (possible) local stack variables
   const RangeList &getParamRange(void) const { return paramrange; }	///< Get the range of (possible) stack parameters
-  vector<EffectRecord>::const_iterator effectBegin(void) const { return effectlist.begin(); }	///< Get an iterator to the first EffectRecord
-  vector<EffectRecord>::const_iterator effectEnd(void) const { return effectlist.end(); }	///< Get an iterator to the last EffectRecord
-  vector<VarnodeData>::const_iterator trashBegin(void) const { return likelytrash.begin(); }	///< Get an iterator to the first \e likelytrash
-  vector<VarnodeData>::const_iterator trashEnd(void) const { return likelytrash.end(); }	///< Get an iterator to the last \e likelytrash
+  std::vector<EffectRecord>::const_iterator effectBegin(void) const { return effectlist.begin(); }	///< Get an iterator to the first EffectRecord
+  std::vector<EffectRecord>::const_iterator effectEnd(void) const { return effectlist.end(); }	///< Get an iterator to the last EffectRecord
+  std::vector<VarnodeData>::const_iterator trashBegin(void) const { return likelytrash.begin(); }	///< Get an iterator to the first \e likelytrash
+  std::vector<VarnodeData>::const_iterator trashEnd(void) const { return likelytrash.end(); }	///< Get an iterator to the last \e likelytrash
 
   /// \brief Characterize whether the given range overlaps parameter storage
   ///
@@ -950,8 +950,8 @@ class ProtoModel {
   virtual bool isMerged(void) const { return false; }	///< Is \b this a merged prototype model
   virtual bool isUnknown(void) const { return false; }	///< Is \b this an unrecognized prototype model
   virtual void decode(Decoder &decoder);		///< Restore \b this model from a stream
-  static uint4 lookupEffect(const vector<EffectRecord> &efflist,const Address &addr,int4 size);
-  static int4 lookupRecord(const vector<EffectRecord> &efflist,int4 listSize,const Address &addr,int4 size);
+  static uint4 lookupEffect(const std::vector<EffectRecord> &efflist,const Address &addr,int4 size);
+  static int4 lookupRecord(const std::vector<EffectRecord> &efflist,int4 listSize,const Address &addr,int4 size);
 };
 
 /// \brief An unrecognized prototype model
@@ -963,7 +963,7 @@ class ProtoModel {
 class UnknownProtoModel : public ProtoModel {
   ProtoModel *placeholderModel;		///< The model whose behavior \b this adopts as a behavior placeholder
 public:
-  UnknownProtoModel(const string &nm,ProtoModel *placeHold) : ProtoModel(nm,*placeHold) { placeholderModel = placeHold; }
+  UnknownProtoModel(const std::string &nm,ProtoModel *placeHold) : ProtoModel(nm,*placeHold) { placeholderModel = placeHold; }
   ProtoModel *getPlaceholderModel(void) const { return placeholderModel; }	///< Retrieve the placeholder model
   virtual bool isUnknown(void) const { return true; }
 };
@@ -988,7 +988,7 @@ class ScoreProtoModel {
     bool operator<(const PEntry &op2) const { return (slot < op2.slot); }
   };
   bool isinputscore;		///< True if scoring against input parameters, \b false for outputs
-  vector<PEntry> entry;		///< Map of parameter entries corresponding to trials
+  std::vector<PEntry> entry;		///< Map of parameter entries corresponding to trials
   const ProtoModel *model;	///< Prototype model to score against
   int4 finalscore;		///< The final fitness score
   int4 mismatch;		///< Number of trials that don't fit the prototype model at all
@@ -1012,9 +1012,9 @@ class ScoreProtoModel {
 /// for the output part of the model is currently limited, so the constituent models must all share
 /// the same output model, and this part is \e not currently merged.
 class ProtoModelMerged : public ProtoModel {
-  vector<ProtoModel *> modellist;					///< Constituent models being merged
-  void intersectEffects(const vector<EffectRecord> &efflist);		///< Fold EffectRecords into \b this model
-  void intersectLikelyTrash(const vector<VarnodeData> &trashlist);	///< Fold \e likelytrash locations into \b this model
+  std::vector<ProtoModel *> modellist;					///< Constituent models being merged
+  void intersectEffects(const std::vector<EffectRecord> &efflist);		///< Fold EffectRecords into \b this model
+  void intersectLikelyTrash(const std::vector<VarnodeData> &trashlist);	///< Fold \e likelytrash locations into \b this model
 public:
   ProtoModelMerged(Architecture *g) : ProtoModel(g) {}			///< Constructor
   virtual ~ProtoModelMerged(void) {}					///< Destructor
@@ -1038,7 +1038,7 @@ class ProtoParameter {
 public:
   ProtoParameter(void) {}				///< Constructor
   virtual ~ProtoParameter(void) {}			///< Destructor
-  virtual const string &getName(void) const=0;		///< Get the name of the parameter ("" for return value)
+  virtual const std::string &getName(void) const=0;		///< Get the name of the parameter ("" for return value)
   virtual Datatype *getType(void) const=0;		///< Get the data-type associate with \b this
   virtual Address getAddress(void) const=0;		///< Get the storage address for \b this parameter
   virtual int4 getSize(void) const=0;			///< Get the number of bytes occupied by \b this parameter
@@ -1098,16 +1098,16 @@ class ProtoParameter {
 /// This is suitable for return values, function pointer prototypes, or functions
 /// that haven't been fully analyzed.
 class ParameterBasic : public ProtoParameter {
-  string name;			///< The name of the parameter, "" for undefined or return value parameters
+  std::string name;			///< The name of the parameter, "" for undefined or return value parameters
   Address addr;			///< Storage address of the parameter
   Datatype *type;		///< Data-type of the parameter
   uint4 flags;			///< Lock and other properties from ParameterPieces flags
 public:
-  ParameterBasic(const string &nm,const Address &ad,Datatype *tp,uint4 fl) {
+  ParameterBasic(const std::string &nm,const Address &ad,Datatype *tp,uint4 fl) {
     name = nm; addr = ad; type = tp; flags=fl; }		///< Construct from components
   ParameterBasic(Datatype *tp) {
     type = tp; flags = 0; }			///< Construct a \e void parameter
-  virtual const string &getName(void) const { return name; }
+  virtual const std::string &getName(void) const { return name; }
   virtual Datatype *getType(void) const { return type; }
   virtual Address getAddress(void) const { return addr; }
   virtual int4 getSize(void) const { return type->getSize(); }
@@ -1145,7 +1145,7 @@ class ProtoStore {
   /// \param nm is the (optional) name of the parameter
   /// \param pieces holds the raw storage address and data-type to set
   /// \return the new/modified ProtoParameter
-  virtual ProtoParameter *setInput(int4 i,const string &nm,const ParameterPieces &pieces)=0;
+  virtual ProtoParameter *setInput(int4 i,const std::string &nm,const ParameterPieces &pieces)=0;
 
   /// \brief Clear the input parameter at the specified slot
   ///
@@ -1195,7 +1195,7 @@ class ParameterSymbol : public ProtoParameter {
   Symbol *sym;		///< Backing Symbol for \b this parameter
 public:
   ParameterSymbol(void) { sym = (Symbol *)0; }		///< Constructor
-  virtual const string &getName(void) const;
+  virtual const std::string &getName(void) const;
   virtual Datatype *getType(void) const;
   virtual Address getAddress(void) const;
   virtual int4 getSize(void) const;
@@ -1223,13 +1223,13 @@ class ParameterSymbol : public ProtoParameter {
 class ProtoStoreSymbol : public ProtoStore {
   Scope *scope;				///< Backing Scope for input parameters
   Address restricted_usepoint;		///< A usepoint reference for storage locations (usually function entry -1)
-  vector<ProtoParameter *> inparam;	///< Cache of allocated input parameters
+  std::vector<ProtoParameter *> inparam;	///< Cache of allocated input parameters
   ProtoParameter *outparam;		///< The return-value parameter
   ParameterSymbol *getSymbolBacked(int4 i);	///< Fetch or allocate the parameter for the indicated slot
 public:
   ProtoStoreSymbol(Scope *sc,const Address &usepoint);	///< Constructor
   virtual ~ProtoStoreSymbol(void);
-  virtual ProtoParameter *setInput(int4 i,const string &nm,const ParameterPieces &pieces);
+  virtual ProtoParameter *setInput(int4 i,const std::string &nm,const ParameterPieces &pieces);
   virtual void clearInput(int4 i);
   virtual void clearAllInputs(void);
   virtual int4 getNumInputs(void) const;
@@ -1248,12 +1248,12 @@ class ProtoStoreSymbol : public ProtoStore {
 /// mirrored by a symbol table.
 class ProtoStoreInternal : public ProtoStore {
   Datatype *voidtype;			///< Cached reference to the \b void data-type
-  vector<ProtoParameter *> inparam;	///< Descriptions of input parameters
+  std::vector<ProtoParameter *> inparam;	///< Descriptions of input parameters
   ProtoParameter *outparam;		///< Description of the return value
 public:
   ProtoStoreInternal(Datatype *vt);	///< Constructor
   virtual ~ProtoStoreInternal(void);
-  virtual ProtoParameter *setInput(int4 i,const string &nm,const ParameterPieces &pieces);
+  virtual ProtoParameter *setInput(int4 i,const std::string &nm,const ParameterPieces &pieces);
   virtual void clearInput(int4 i);
   virtual void clearAllInputs(void);
   virtual int4 getNumInputs(void) const;
@@ -1269,10 +1269,10 @@ class ProtoStoreInternal : public ProtoStore {
 /// \brief Raw components of a function prototype (obtained from parsing source code)
 struct PrototypePieces {
   ProtoModel *model;		///< (Optional) model on which prototype is based
-  string name;			///< Identifier (function name) associated with prototype
+  std::string name;			///< Identifier (function name) associated with prototype
   Datatype *outtype;		///< Return data-type
-  vector<Datatype *> intypes;	///< Input data-types
-  vector<string> innames;	///< Identifiers for input types
+  std::vector<Datatype *> intypes;	///< Input data-types
+  std::vector<std::string> innames;	///< Identifiers for input types
   bool dotdotdot;		///< True if prototype takes variable arguments
 };
 
@@ -1307,8 +1307,8 @@ class FuncProto {
   ProtoStore *store;		///< Storage interface for parameters
   int4 extrapop;		///< Extra bytes popped from stack
   uint4 flags;			///< Boolean properties of the function prototype
-  vector<EffectRecord> effectlist;	///< Side-effects associated with non-parameter storage locations
-  vector<VarnodeData> likelytrash;	///< Locations that may contain \e trash values
+  std::vector<EffectRecord> effectlist;	///< Side-effects associated with non-parameter storage locations
+  std::vector<VarnodeData> likelytrash;	///< Locations that may contain \e trash values
   int4 injectid;		///< (If non-negative) id of p-code snippet that should replace this function
   int4 returnBytesConsumed;	///< Number of bytes of return value that are consumed by callers (0 = all bytes)
   void updateThisPointer(void);	///< Make sure any "this" parameter is properly marked
@@ -1335,7 +1335,7 @@ class FuncProto {
   bool hasModel(void) const { return (model != (ProtoModel *)0); }	///< Does \b this prototype have a model
 
   bool hasMatchingModel(const ProtoModel *op2) const { return (model == op2); }	///< Does \b this use the given model
-  const string &getModelName(void) const { return model->getName(); }	///< Get the prototype model name
+  const std::string &getModelName(void) const { return model->getName(); }	///< Get the prototype model name
   int4 getModelExtraPop(void) const { return model->getExtraPop(); }	///< Get the \e extrapop of the prototype model
   bool isModelUnknown(void) const { return model->isUnknown(); }	///< Return \b true if the prototype model is \e unknown
   bool printModelInDecl(void) const { return model->printInDecl(); }	///< Return \b true if the name should be printed in declarations
@@ -1470,11 +1470,11 @@ class FuncProto {
   bool checkInputSplit(const Address &loc,int4 size,int4 splitpoint) const {
     return model->checkInputSplit(loc,size,splitpoint); }
 
-  void updateInputTypes(Funcdata &data,const vector<Varnode *> &triallist,ParamActive *activeinput);
-  void updateInputNoTypes(Funcdata &data,const vector<Varnode *> &triallist,ParamActive *activeinput);
-  void updateOutputTypes(const vector<Varnode *> &triallist);
-  void updateOutputNoTypes(const vector<Varnode *> &triallist,TypeFactory *factory);
-  void updateAllTypes(const vector<string> &namelist,const vector<Datatype *> &typelist,bool dtdtdt);
+  void updateInputTypes(Funcdata &data,const std::vector<Varnode *> &triallist,ParamActive *activeinput);
+  void updateInputNoTypes(Funcdata &data,const std::vector<Varnode *> &triallist,ParamActive *activeinput);
+  void updateOutputTypes(const std::vector<Varnode *> &triallist);
+  void updateOutputNoTypes(const std::vector<Varnode *> &triallist,TypeFactory *factory);
+  void updateAllTypes(const std::vector<std::string> &namelist,const std::vector<Datatype *> &typelist,bool dtdtdt);
   ProtoParameter *getParam(int4 i) const { return store->getInput(i); }	///< Get the i-th input parameter
   void removeParam(int4 i) { store->clearInput(i); }		///< Remove the i-th input parameter
   int4 numParams(void) const { return store->getNumInputs(); }	///< Get the number of input parameters
@@ -1488,10 +1488,10 @@ class FuncProto {
   bool isOverride(void) const { return ((flags&is_override)!=0); }	///< Return \b true if \b this is a call site override
   void setOverride(bool val) { flags = val ? (flags|is_override) : (flags & ~((uint4)is_override)); }	///< Toggle whether \b this is a call site override
   uint4 hasEffect(const Address &addr,int4 size) const;
-  vector<EffectRecord>::const_iterator effectBegin(void) const;	///< Get iterator to front of EffectRecord list
-  vector<EffectRecord>::const_iterator effectEnd(void) const;	///< Get iterator to end of EffectRecord list
-  vector<VarnodeData>::const_iterator trashBegin(void) const;	///< Get iterator to front of \e likelytrash list
-  vector<VarnodeData>::const_iterator trashEnd(void) const;	///< Get iterator to end of \e likelytrash list
+  std::vector<EffectRecord>::const_iterator effectBegin(void) const;	///< Get iterator to front of EffectRecord list
+  std::vector<EffectRecord>::const_iterator effectEnd(void) const;	///< Get iterator to end of EffectRecord list
+  std::vector<VarnodeData>::const_iterator trashBegin(void) const;	///< Get iterator to front of \e likelytrash list
+  std::vector<VarnodeData>::const_iterator trashEnd(void) const;	///< Get iterator to end of \e likelytrash list
   int4 characterizeAsInputParam(const Address &addr,int4 size) const;
   int4 characterizeAsOutput(const Address &addr,int4 size) const;
   bool possibleInputParam(const Address &addr,int4 size) const;
@@ -1551,7 +1551,7 @@ class FuncProto {
 
   bool isCompatible(const FuncProto &op2) const;
   AddrSpace *getSpacebase(void) const { return model->getSpacebase(); }		///< Get the \e stack address space
-  void printRaw(const string &funcname,ostream &s) const;
+  void printRaw(const std::string &funcname,std::ostream &s) const;
 
   /// \brief Get the comparable properties of \b this prototype
   ///
@@ -1584,7 +1584,7 @@ class Funcdata;
 /// and the placeholder is removed.
 class FuncCallSpecs : public FuncProto {
   PcodeOp *op;			///< Pointer to CALL or CALLIND instruction
-  string name;			///< Name of function if present
+  std::string name;			///< Name of function if present
   Address entryaddress;		///< First executing address of function
   Funcdata *fd;			///< The Funcdata object for the called functon (if known)
   int4 effective_extrapop;	///< Working extrapop for the CALL
@@ -1594,7 +1594,7 @@ class FuncCallSpecs : public FuncProto {
   int4 matchCallCount;		///< Number of calls to this sub-function within the calling function
   ParamActive activeinput;	///< Info for recovering input parameters
   ParamActive activeoutput;	///< Info for recovering output parameters
-  mutable vector<int4> inputConsume;	///< Number of bytes consumed by sub-function, for each input parameter
+  mutable std::vector<int4> inputConsume;	///< Number of bytes consumed by sub-function, for each input parameter
   bool isinputactive; 		///< Are we actively trying to recover input parameters
   bool isoutputactive;		///< Are we actively trying to recover output parameters
   bool isbadjumptable;		///< Was the call originally a jump-table we couldn't recover
@@ -1602,11 +1602,11 @@ class FuncCallSpecs : public FuncProto {
   Varnode *buildParam(Funcdata &data,Varnode *vn,ProtoParameter *param,Varnode *stackref);
   int4 transferLockedInputParam(ProtoParameter *param);
   PcodeOp *transferLockedOutputParam(ProtoParameter *param);
-  bool transferLockedInput(vector<Varnode *> &newinput);
+  bool transferLockedInput(std::vector<Varnode *> &newinput);
   bool transferLockedOutput(Varnode *&newoutput);
-  void commitNewInputs(Funcdata &data,vector<Varnode *> &newinput);
+  void commitNewInputs(Funcdata &data,std::vector<Varnode *> &newinput);
   void commitNewOutputs(Funcdata &data,Varnode *newout);
-  void collectOutputTrialVarnodes(vector<Varnode *> &trialvn);
+  void collectOutputTrialVarnodes(std::vector<Varnode *> &trialvn);
 public:
   enum {
     offset_unknown = 0xBADBEEF					///< "Magic" stack offset indicating the offset is unknown
@@ -1617,7 +1617,7 @@ class FuncCallSpecs : public FuncProto {
   Funcdata *getFuncdata(void) const { return fd; }		///< Get the Funcdata object associated with the called function
   void setFuncdata(Funcdata *f);				///< Set the Funcdata object associated with the called function
   FuncCallSpecs *clone(PcodeOp *newop) const;			///< Clone \b this given the mirrored p-code CALL
-  const string &getName(void) const { return name; }		///< Get the function name associated with the callee
+  const std::string &getName(void) const { return name; }		///< Get the function name associated with the callee
   const Address &getEntryAddress(void) const { return entryaddress; }	///< Get the entry address of the callee
   void setEffectiveExtraPop(int4 epop) { effective_extrapop = epop; }	///< Set the specific \e extrapop associate with \b this call site
   int4 getEffectiveExtraPop(void) const { return effective_extrapop; }	///< Get the specific \e extrapop associate with \b this call site
@@ -1644,7 +1644,7 @@ class FuncCallSpecs : public FuncProto {
 
   bool checkInputJoin(int4 slot1,bool ishislot,Varnode *vn1,Varnode *vn2) const;
   void doInputJoin(int4 slot1,bool ishislot);
-  bool lateRestriction(const FuncProto &restrictedProto,vector<Varnode *> &newinput,Varnode *&newoutput);
+  bool lateRestriction(const FuncProto &restrictedProto,std::vector<Varnode *> &newinput,Varnode *&newoutput);
   void deindirect(Funcdata &data,Funcdata *newfd);
   void forceSet(Funcdata &data,const FuncProto &fp);
   void insertPcode(Funcdata &data);
@@ -1652,9 +1652,9 @@ class FuncCallSpecs : public FuncProto {
   void abortSpacebaseRelative(Funcdata &data);
   void finalInputCheck(void);
   void checkInputTrialUse(Funcdata &data,AliasChecker &aliascheck);
-  void checkOutputTrialUse(Funcdata &data,vector<Varnode *> &trialvn);
+  void checkOutputTrialUse(Funcdata &data,std::vector<Varnode *> &trialvn);
   void buildInputFromTrials(Funcdata &data);
-  void buildOutputFromTrials(Funcdata &data,vector<Varnode *> &trialvn);
+  void buildOutputFromTrials(Funcdata &data,std::vector<Varnode *> &trialvn);
   int4 getInputBytesConsumed(int4 slot) const;
   bool setInputBytesConsumed(int4 slot,int4 val) const;
   void paramshiftModifyStart(void);
@@ -1674,7 +1674,7 @@ class FuncCallSpecs : public FuncProto {
   /// \param b is the second to compare
   /// \return \b true if the first should be ordered before the second
   static bool compareByEntryAddress(const FuncCallSpecs *a,const FuncCallSpecs *b) { return a->entryaddress < b->entryaddress; }
-  static void countMatchingCalls(const vector<FuncCallSpecs *> &qlst);
+  static void countMatchingCalls(const std::vector<FuncCallSpecs *> &qlst);
 };
 
 /// Return the trial associated with the input Varnode to the associated p-code CALL or CALLIND.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
index 2412d35bb..602910d36 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
@@ -15,6 +15,8 @@
  */
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_NOCODE = AttributeId("nocode",84);
 
 ElementId ELEM_AST = ElementId("ast",115);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
index 892883c0d..90c98d096 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
@@ -76,13 +76,13 @@ class Funcdata {
   int4 size;			///< Number of bytes of binary data in function body
   Architecture *glb;		///< Global configuration data
   FunctionSymbol *functionSymbol;	///< The symbol representing \b this function
-  string name;			///< Name of function
+  std::string name;			///< Name of function
   Address baseaddr;		///< Starting code address of binary data
   FuncProto funcp;		///< Prototype of this function
   ScopeLocal *localmap;		///< Local variables (symbols in the function scope)
 
-  vector<FuncCallSpecs *> qlst;	///< List of calls this function makes
-  vector<JumpTable *> jumpvec;	///< List of jump-tables for this function
+  std::vector<FuncCallSpecs *> qlst;	///< List of calls this function makes
+  std::vector<JumpTable *> jumpvec;	///< List of jump-tables for this function
 
   VarnodeBank vbank;		///< Container of Varnode objects for \b this function
   PcodeOpBank obank;		///< Container of PcodeOp objects for \b this function
@@ -92,8 +92,8 @@ class Funcdata {
   Merge covermerge;		///< Variable range intersection algorithms
   ParamActive *activeoutput;	///< Data for assessing which parameters are passed to \b this function
   Override localoverride;	///< Overrides of data-flow, prototypes, etc. that are local to \b this function
-  map<VarnodeData,const LanedRegister *> lanedMap;	///< Current storage locations which may be laned registers
-  map<ResolveEdge,ResolvedUnion> unionMap;	///< A map from data-flow edges to the resolved field of TypeUnion being accessed
+  std::map<VarnodeData,const LanedRegister *> lanedMap;	///< Current storage locations which may be laned registers
+  std::map<ResolveEdge,ResolvedUnion> unionMap;	///< A map from data-flow edges to the resolved field of TypeUnion being accessed
 
 				// Low level Varnode functions
   void setVarnodeProperties(Varnode *vn) const;	///< Look-up boolean properties and data-type information
@@ -105,7 +105,7 @@ class Funcdata {
   void splitUses(Varnode *vn);			///< Make all reads of the given Varnode unique
   Varnode *cloneVarnode(const Varnode *vn);	///< Clone a Varnode (between copies of the function)
   void destroyVarnode(Varnode *vn);		///< Delete the given Varnode from \b this function
-  void coverVarnodes(SymbolEntry *entry,vector<Varnode *> &list);
+  void coverVarnodes(SymbolEntry *entry,std::vector<Varnode *> &list);
   bool applyUnionFacet(SymbolEntry *entry,DynamicHash &dhash);
 				// Low level op functions
   void opZeroMulti(PcodeOp *op);		///< Transform trivial CPUI_MULTIEQUAL to CPUI_COPY
@@ -134,9 +134,9 @@ class Funcdata {
   static PcodeOp *findPrimaryBranch(PcodeOpTree::const_iterator iter,PcodeOpTree::const_iterator enditer,
 				    bool findbranch,bool findcall,bool findreturn);
 public:
-  Funcdata(const string &nm,Scope *conf,const Address &addr,FunctionSymbol *sym,int4 sz=0);	///< Constructor
+  Funcdata(const std::string &nm,Scope *conf,const Address &addr,FunctionSymbol *sym,int4 sz=0);	///< Constructor
   ~Funcdata(void);							///< Destructor
-  const string &getName(void) const { return name; }			///< Get the function's local symbol name
+  const std::string &getName(void) const { return name; }			///< Get the function's local symbol name
   const Address &getAddress(void) const { return baseaddr; }		///< Get the entry point address
   int4 getSize(void) const { return size; }				///< Get the function body size in bytes
   Architecture *getArch(void) const { return glb; }			///< Get the program/architecture owning \b this function
@@ -166,8 +166,8 @@ class Funcdata {
   bool isDoublePrecisOn(void) const { return ((flags & double_precis_on)!=0); }	///< Is double precision analysis enabled
   bool hasNoStructBlocks(void) const { return (sblocks.getSize() == 0); }	///< Return \b true if no block structuring was performed
   void clear(void);						///< Clear out old disassembly
-  void warning(const string &txt,const Address &ad) const;	///< Add a warning comment in the function body
-  void warningHeader(const string &txt) const;			///< Add a warning comment as part of the function header
+  void warning(const std::string &txt,const Address &ad) const;	///< Add a warning comment in the function body
+  void warningHeader(const std::string &txt) const;			///< Add a warning comment as part of the function header
   void startProcessing(void);					///< Start processing for this function
   void stopProcessing(void);					///< Mark that processing has completed for this function
   bool startTypeRecovery(void);					///< Mark that data-type analysis has started
@@ -186,12 +186,12 @@ class Funcdata {
   void truncatedFlow(const Funcdata *fd,const FlowInfo *flow);
   bool inlineFlow(Funcdata *inlinefd,FlowInfo &flow,PcodeOp *callop);
   void overrideFlow(const Address &addr,uint4 type);
-  void doLiveInject(InjectPayload *payload,const Address &addr,BlockBasic *bl,list<PcodeOp *>::iterator pos);
+  void doLiveInject(InjectPayload *payload,const Address &addr,BlockBasic *bl,std::list<PcodeOp *>::iterator pos);
   
-  void printRaw(ostream &s) const;			///< Print raw p-code op descriptions to a stream
-  void printVarnodeTree(ostream &s) const;		///< Print a description of all Varnodes to a stream
-  void printBlockTree(ostream &s) const;		///< Print a description of control-flow structuring to a stream
-  void printLocalRange(ostream &s) const;		///< Print description of memory ranges associated with local scopes
+  void printRaw(std::ostream &s) const;			///< Print raw p-code op descriptions to a stream
+  void printVarnodeTree(std::ostream &s) const;		///< Print a description of all Varnodes to a stream
+  void printBlockTree(std::ostream &s) const;		///< Print a description of control-flow structuring to a stream
+  void printLocalRange(std::ostream &s) const;		///< Print description of memory ranges associated with local scopes
   void encode(Encoder &encoder,uint8 id,bool savetree) const;	///< Encode a description of \b this function to stream
   uint8 decode(Decoder &decoder);			///< Restore the state of \b this function from an XML description
   void encodeJumpTable(Encoder &encoder) const;		///< Encode a description of jump-tables to stream
@@ -259,8 +259,8 @@ class Funcdata {
   /// \return \b true if the Varnode is fully linked
   bool isHeritaged(Varnode *vn) { return (heritage.heritagePass(vn->getAddr())>=0); }
 
-  const list<LoadGuard> &getLoadGuards(void) const { return heritage.getLoadGuards(); }		///< Get the list of guarded LOADs
-  const list<LoadGuard> &getStoreGuards(void) const { return heritage.getStoreGuards(); }	///< Get the list of guarded STOREs
+  const std::list<LoadGuard> &getLoadGuards(void) const { return heritage.getLoadGuards(); }		///< Get the list of guarded LOADs
+  const std::list<LoadGuard> &getStoreGuards(void) const { return heritage.getStoreGuards(); }	///< Get the list of guarded STOREs
   const LoadGuard *getStoreGuard(PcodeOp *op) const { return heritage.getStoreGuard(op); }	///< Get LoadGuard associated with STORE op
 
   // Function prototype and call specification routines
@@ -375,11 +375,11 @@ class Funcdata {
   VarnodeDefSet::const_iterator endDef(uint4 fl,const Address &addr) const { return vbank.endDef(fl,addr); }
 
   void checkForLanedRegister(int4 sz,const Address &addr);	///< Check for a potential laned register
-  map<VarnodeData,const LanedRegister *>::const_iterator beginLaneAccess(void) const { return lanedMap.begin(); }	///< Beginning iterator over laned accesses
-  map<VarnodeData,const LanedRegister *>::const_iterator endLaneAccess(void) const { return lanedMap.end(); }	///< Ending iterator over laned accesses
+  std::map<VarnodeData,const LanedRegister *>::const_iterator beginLaneAccess(void) const { return lanedMap.begin(); }	///< Beginning iterator over laned accesses
+  std::map<VarnodeData,const LanedRegister *>::const_iterator endLaneAccess(void) const { return lanedMap.end(); }	///< Ending iterator over laned accesses
   void clearLanedAccessMap(void) { lanedMap.clear(); }	///< Clear records from the laned access list
 
-  HighVariable *findHigh(const string &nm) const;	///< Find a high-level variable by name
+  HighVariable *findHigh(const std::string &nm) const;	///< Find a high-level variable by name
   void mapGlobals(void);			///< Make sure there is a Symbol entry for all global Varnodes
   void prepareThisPointer(void);		///< Prepare for recovery of the "this" pointer
   bool checkCallDoubleUse(const PcodeOp *opmatch,const PcodeOp *op,const Varnode *vn,uint4 fl,const ParamTrial &trial) const;
@@ -414,7 +414,7 @@ class Funcdata {
   Symbol *linkSymbol(Varnode *vn);				///< Find or create Symbol associated with given Varnode
   Symbol *linkSymbolReference(Varnode *vn);			///< Discover and attach Symbol to a constant reference
   Varnode *findLinkedVarnode(SymbolEntry *entry) const;	///< Find a Varnode matching the given Symbol mapping
-  void findLinkedVarnodes(SymbolEntry *entry,vector<Varnode *> &res) const;	///< Find Varnodes that map to the given SymbolEntry
+  void findLinkedVarnodes(SymbolEntry *entry,std::vector<Varnode *> &res) const;	///< Find Varnodes that map to the given SymbolEntry
   void buildDynamicSymbol(Varnode *vn);				///< Build a \e dynamic Symbol associated with the given Varnode
   bool attemptDynamicMapping(SymbolEntry *entry,DynamicHash &dhash);
   bool attemptDynamicMappingLate(SymbolEntry *entry,DynamicHash &dhash);
@@ -446,13 +446,13 @@ class Funcdata {
   void opSetInput(PcodeOp *op,Varnode *vn,int4 slot);		///< Set a specific input operand for the given PcodeOp
   void opSwapInput(PcodeOp *op,int4 slot1,int4 slot2);		///< Swap two input operands in the given PcodeOp
   void opUnsetInput(PcodeOp *op,int4 slot);			///< Clear an input operand slot for the given PcodeOp
-  void opInsert(PcodeOp *op,BlockBasic *bl,list<PcodeOp *>::iterator iter);
+  void opInsert(PcodeOp *op,BlockBasic *bl,std::list<PcodeOp *>::iterator iter);
   void opUninsert(PcodeOp *op);					///< Remove the given PcodeOp from its basic block
   void opUnlink(PcodeOp *op);					///< Unset inputs/output and remove given PcodeOP from its basic block
   void opDestroy(PcodeOp *op);					///< Remove given PcodeOp and destroy its Varnode operands
   void opDestroyRaw(PcodeOp *op);				///< Remove the given \e raw PcodeOp
   void opDeadAndGone(PcodeOp *op) { obank.destroy(op); }	///< Free resources for the given \e dead PcodeOp
-  void opSetAllInput(PcodeOp *op,const vector<Varnode *> &vvec);	///< Set all input Varnodes for the given PcodeOp simultaneously
+  void opSetAllInput(PcodeOp *op,const std::vector<Varnode *> &vvec);	///< Set all input Varnodes for the given PcodeOp simultaneously
   void opRemoveInput(PcodeOp *op,int4 slot);			///< Remove a specific input slot for the given PcodeOp
   void opInsertInput(PcodeOp *op,Varnode *vn,int4 slot);	///< Insert a new Varnode into the operand list for the given PcodeOp
   void opMarkStartBasic(PcodeOp *op) { op->setFlag(PcodeOp::startbasic); }	///< Mark PcodeOp as starting a basic block
@@ -472,22 +472,22 @@ class Funcdata {
   void opUndoPtradd(PcodeOp *op,bool finalize);	///< Convert a CPUI_PTRADD back into a CPUI_INT_ADD
 
   /// \brief Start of PcodeOp objects with the given op-code
-  list<PcodeOp *>::const_iterator beginOp(OpCode opc) const { return obank.begin(opc); }
+  std::list<PcodeOp *>::const_iterator beginOp(OpCode opc) const { return obank.begin(opc); }
 
   /// \brief End of PcodeOp objects with the given op-code
-  list<PcodeOp *>::const_iterator endOp(OpCode opc) const { return obank.end(opc); }
+  std::list<PcodeOp *>::const_iterator endOp(OpCode opc) const { return obank.end(opc); }
 
   /// \brief Start of PcodeOp objects in the \e alive list
-  list<PcodeOp *>::const_iterator beginOpAlive(void) const { return obank.beginAlive(); }
+  std::list<PcodeOp *>::const_iterator beginOpAlive(void) const { return obank.beginAlive(); }
 
   /// \brief End of PcodeOp objects in the \e alive list
-  list<PcodeOp *>::const_iterator endOpAlive(void) const { return obank.endAlive(); }
+  std::list<PcodeOp *>::const_iterator endOpAlive(void) const { return obank.endAlive(); }
 
   /// \brief Start of PcodeOp objects in the \e dead list
-  list<PcodeOp *>::const_iterator beginOpDead(void) const { return obank.beginDead(); }
+  std::list<PcodeOp *>::const_iterator beginOpDead(void) const { return obank.beginDead(); }
 
   /// \brief End of PcodeOp objects in the \e dead list
-  list<PcodeOp *>::const_iterator endOpDead(void) const { return obank.endDead(); }
+  std::list<PcodeOp *>::const_iterator endOpDead(void) const { return obank.endDead(); }
 
   /// \brief Start of all (alive) PcodeOp objects sorted by sequence number
   PcodeOpTree::const_iterator beginOpAll(void) const { return obank.beginAll(); }
@@ -548,24 +548,24 @@ class Funcdata {
 
 #ifdef OPACTION_DEBUG
   void (*jtcallback)(Funcdata &orig,Funcdata &fd);	///< Hook point debugging the jump-table simplification process
-  vector<PcodeOp *> modify_list;		///< List of modified ops
-  vector<string> modify_before;			///< List of "before" strings for modified ops
+  std::vector<PcodeOp *> modify_list;		///< List of modified ops
+  std::vector<std::string> modify_before;			///< List of "before" strings for modified ops
   int4 opactdbg_count;				///< Number of debug statements printed
   int4 opactdbg_breakcount;			///< Which debug to break on
   bool opactdbg_on;				///< Are we currently doing op action debugs
   bool opactdbg_active;				///< \b true if current op mods should be recorded
   bool opactdbg_breakon;			///< Has a breakpoint been hit
-  vector<Address> opactdbg_pclow;		///< Lower bounds on the PC register
-  vector<Address> opactdbg_pchigh;		///< Upper bounds on the PC register
-  vector<uintm> opactdbg_uqlow;			///< Lower bounds on the unique register
-  vector<uintm> opactdbg_uqhigh;		///< Upper bounds on the unique register
+  std::vector<Address> opactdbg_pclow;		///< Lower bounds on the PC register
+  std::vector<Address> opactdbg_pchigh;		///< Upper bounds on the PC register
+  std::vector<uintm> opactdbg_uqlow;			///< Lower bounds on the unique register
+  std::vector<uintm> opactdbg_uqhigh;		///< Upper bounds on the unique register
   void enableJTCallback(void (*jtcb)(Funcdata &orig,Funcdata &fd)) { jtcallback = jtcb; }	///< Enable a debug callback
   void disableJTCallback(void) { jtcallback = (void (*)(Funcdata &orig,Funcdata &fd))0; }	///< Disable debug callback
   void debugActivate(void) { if (opactdbg_on) opactdbg_active=true; }	///< Turn on recording
   void debugDeactivate(void) { opactdbg_active = false; }		///< Turn off recording
   void debugModCheck(PcodeOp *op);		///< Cache \e before state of the given PcodeOp
   void debugModClear(void);			///< Abandon printing debug for current action
-  void debugModPrint(const string &actionname);	///< Print before and after strings for PcodeOps modified by given action
+  void debugModPrint(const std::string &actionname);	///< Print before and after strings for PcodeOps modified by given action
   bool debugBreak(void) const { return opactdbg_on&&opactdbg_breakon; }	///< Has a breakpoint been hit
   int4 debugSize(void) const { return opactdbg_pclow.size(); }	///< Number of code ranges being debug traced
   void debugEnable(void) { opactdbg_on = true; opactdbg_count = 0; }	///< Turn on debugging
@@ -649,8 +649,8 @@ class AncestorRealistic {
     pop_failkill	///< Backtracking, from path with a bad ancestor, specifically killedbycall
   };
   ParamTrial *trial;			///< Current trial being analyzed for suitability
-  vector<State> stateStack;		///< Holds the depth-first traversal stack
-  vector<const Varnode *> markedVn;	///< Holds visited Varnodes to properly trim cycles
+  std::vector<State> stateStack;		///< Holds the depth-first traversal stack
+  std::vector<const Varnode *> markedVn;	///< Holds visited Varnodes to properly trim cycles
   int4 multiDepth;			///< Number of MULTIEQUAL ops along current traversal path
   bool allowFailingPath;		///< True if we allow and test for failing paths due to conditional execution
 
@@ -669,13 +669,13 @@ class AncestorRealistic {
   bool execute(PcodeOp *op,int4 slot,ParamTrial *t,bool allowFail);
 };
 
-extern int4 opFlipInPlaceTest(PcodeOp *op,vector<PcodeOp *> &fliplist);
-extern void opFlipInPlaceExecute(Funcdata &data,vector<PcodeOp *> &fliplist);
+extern int4 opFlipInPlaceTest(PcodeOp *op,std::vector<PcodeOp *> &fliplist);
+extern void opFlipInPlaceExecute(Funcdata &data,std::vector<PcodeOp *> &fliplist);
 
 extern PcodeOp *earliestUseInBlock(Varnode *vn,BlockBasic *bl);
 extern PcodeOp *cseFindInBlock(PcodeOp *op,Varnode *vn,BlockBasic *bl,PcodeOp *earliest);
 extern PcodeOp *cseElimination(Funcdata &data,PcodeOp *op1,PcodeOp *op2);
-extern void cseEliminateList(Funcdata &data,vector< pair<uintm,PcodeOp *> > &list,
-			     vector<Varnode *> &outlist);
+extern void cseEliminateList(Funcdata &data,std::vector< std::pair<uintm,PcodeOp *> > &list,
+			     std::vector<Varnode *> &outlist);
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
index a7a2756e2..126ffe727 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
@@ -16,6 +16,8 @@
 #include "funcdata.hh"
 #include "flow.hh"
 
+using namespace std;
+
 // Funcdata members pertaining directly to blocks
 
 /// A description of each block in the current structure hierarchy is
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
index d546e58b6..6a4d8be41 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
@@ -16,6 +16,8 @@
 #include "funcdata.hh"
 #include "flow.hh"
 
+using namespace std;
+
 // Funcdata members pertaining directly to ops
 
 /// \param op is the given PcodeOp
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_varnode.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_varnode.cc
index 117518e24..d89d35888 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_varnode.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_varnode.cc
@@ -15,6 +15,8 @@
  */
 #include "funcdata.hh"
 
+using namespace std;
+
 // Funcdata members pertaining directly to varnodes
 
 /// Properties of a given storage location are gathered from symbol information and
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
index ce67e2cc8..4e7cc5318 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
@@ -23,6 +23,8 @@
 #include "cpool_ghidra.hh"
 #include "inject_ghidra.hh"
 
+using namespace std;
+
 //AttributeId ATTRIB_BADDATA = AttributeId("baddata",145);
 
 ElementId ELEM_COMMAND_ISNAMEUSED = ElementId("command_isnameused",239);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
index bd0fc3afe..261bebe05 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
@@ -51,8 +51,8 @@ extern ElementId ELEM_COMMAND_GETUSEROPNAME;		///< Marshaling element \<command_
 /// This class also doubles as an exception generated by the decompiler
 /// because of message protocol \e alignment, which should get sent back to the Ghidra client
 struct JavaError : public LowlevelError {
-  string type;				///< The name of the Java exception class
-  JavaError(const string &tp,const string &message) : LowlevelError(message) {
+  std::string type;				///< The name of the Java exception class
+  JavaError(const std::string &tp,const std::string &message) : LowlevelError(message) {
     type = tp; }			///< Construct given a class and message
 };
 
@@ -78,13 +78,13 @@ struct JavaError : public LowlevelError {
 ///   - Local symbol and jump-table information
 ///   - Parameter identification information
 class ArchitectureGhidra : public Architecture {
-  istream &sin;			///< Input stream for interfacing with Ghidra
-  ostream &sout;		///< Output stream for interfacing with Ghidra
-  mutable string warnings;	///< Warnings accumulated by the decompiler
-  string pspecxml;              ///< XML pspec passed from Ghidra
-  string cspecxml;		///< XML cspec passed from Ghidra
-  string tspecxml;              ///< Stripped down .sla file passed from Ghidra
-  string corespecxml;		///< A specification of the core data-types
+  std::istream &sin;			///< Input stream for interfacing with Ghidra
+  std::ostream &sout;		///< Output stream for interfacing with Ghidra
+  mutable std::string warnings;	///< Warnings accumulated by the decompiler
+  std::string pspecxml;              ///< XML pspec passed from Ghidra
+  std::string cspecxml;		///< XML cspec passed from Ghidra
+  std::string tspecxml;              ///< Stripped down .sla file passed from Ghidra
+  std::string corespecxml;		///< A specification of the core data-types
   bool sendsyntaxtree;		///< True if the syntax tree should be sent with function output
   bool sendCcode;		///< True if C code should be sent with function output
   bool sendParamMeasures;       ///< True if measurements for argument and return parameters should be sent
@@ -102,25 +102,25 @@ class ArchitectureGhidra : public Architecture {
   virtual void postSpecFile(void);
   virtual void resolveArchitecture(void);
 public:
-  ArchitectureGhidra(const string &pspec,const string &cspec,const string &tspec,const string &corespec,
-		     istream &i,ostream &o);
-  const string &getWarnings(void) const { return warnings; }	///< Get warnings produced by the last decompilation
+  ArchitectureGhidra(const std::string &pspec,const std::string &cspec,const std::string &tspec,const std::string &corespec,
+		     std::istream &i,std::ostream &o);
+  const std::string &getWarnings(void) const { return warnings; }	///< Get warnings produced by the last decompilation
   void clearWarnings(void) { warnings.clear(); }		///< Clear warnings
-  bool getRegister(const string &regname,Decoder &decoder);	///< Retrieve a register description given a name
-  string getRegisterName(const VarnodeData &vndata);		///< Retrieve a register name given its storage location
+  bool getRegister(const std::string &regname,Decoder &decoder);	///< Retrieve a register description given a name
+  std::string getRegisterName(const VarnodeData &vndata);		///< Retrieve a register name given its storage location
   bool getTrackedRegisters(const Address &addr,Decoder &decoder);	///< Retrieve \e tracked register values at the given address
-  string getUserOpName(int4 index);				///< Get the name of a user-defined p-code op
+  std::string getUserOpName(int4 index);				///< Get the name of a user-defined p-code op
   bool getPcode(const Address &addr,Decoder &decoder);		///< Get p-code for a single instruction
   bool getMappedSymbolsXML(const Address &addr,Decoder &decoder);	///< Get symbols associated with the given address
   bool getExternalRef(const Address &addr,Decoder &decoder);		///< Retrieve a description of an external function
   bool getNamespacePath(uint8 id,Decoder &decoder);			///< Get a description of a namespace path
-  bool isNameUsed(const string &nm,uint8 startId,uint8 stopId);	///< Is given name used along namespace path
-  string getCodeLabel(const Address &addr);			///< Retrieve a label at the given address
-  bool getDataType(const string &name,uint8 id,Decoder &decoder);	///< Retrieve a data-type description for the given name and id
+  bool isNameUsed(const std::string &nm,uint8 startId,uint8 stopId);	///< Is given name used along namespace path
+  std::string getCodeLabel(const Address &addr);			///< Retrieve a label at the given address
+  bool getDataType(const std::string &name,uint8 id,Decoder &decoder);	///< Retrieve a data-type description for the given name and id
   bool getComments(const Address &fad,uint4 flags,Decoder &decoder);	///< Retrieve comments for a particular function
   void getBytes(uint1 *buf,int4 size,const Address &inaddr);	///< Retrieve bytes in the LoadImage at the given address
-  bool getPcodeInject(const string &name,int4 type,const InjectContext &con,Decoder &decoder);
-  bool getCPoolRef(const vector<uintb> &refs,Decoder &decoder);		///< Resolve a constant pool reference
+  bool getPcodeInject(const std::string &name,int4 type,const InjectContext &con,Decoder &decoder);
+  bool getCPoolRef(const std::vector<uintb> &refs,Decoder &decoder);		///< Resolve a constant pool reference
   //  Document *getScopeProperties(Scope *newscope);
 
   /// \brief Toggle whether the data-flow and control-flow is emitted as part of the main decompile action
@@ -148,21 +148,21 @@ class ArchitectureGhidra : public Architecture {
 
   bool getSendParamMeasures(void) const { return sendParamMeasures; }	///< Get the current setting for emitting parameter info
 
-  void getStringData(vector<uint1> &buffer,const Address &addr,Datatype *ct,int4 maxBytes,bool &isTrunc);
-  virtual void printMessage(const string &message) const;
+  void getStringData(std::vector<uint1> &buffer,const Address &addr,Datatype *ct,int4 maxBytes,bool &isTrunc);
+  virtual void printMessage(const std::string &message) const;
 
   static void segvHandler(int4 sig);				///< Handler for a segment violation (SIGSEGV) signal
-  static int4 readToAnyBurst(istream &s);			///< Read the next message protocol marker
-  static bool readBoolStream(istream &s);			///< Read a boolean value from the client
-  static void readStringStream(istream &s,string &res);		///< Receive a string from the client
-  static bool readStringStream(istream &s,Decoder &decoder);	///< Receive an encoded string from the client
-  static void writeStringStream(ostream &s,const string &msg);	///< Send a string to the client
-  static void readToResponse(istream &s);			///< Read the query response protocol marker
-  static void readResponseEnd(istream &s);			///< Read the ending query response protocol marker
-  static bool readAll(istream &s,Decoder &decoder);		///< Read a whole response as an XML document
-  static void passJavaException(ostream &s,const string &tp,const string &msg);
+  static int4 readToAnyBurst(std::istream &s);			///< Read the next message protocol marker
+  static bool readBoolStream(std::istream &s);			///< Read a boolean value from the client
+  static void readStringStream(std::istream &s,std::string &res);		///< Receive a string from the client
+  static bool readStringStream(std::istream &s,Decoder &decoder);	///< Receive an encoded string from the client
+  static void writeStringStream(std::ostream &s,const std::string &msg);	///< Send a string to the client
+  static void readToResponse(std::istream &s);			///< Read the query response protocol marker
+  static void readResponseEnd(std::istream &s);			///< Read the ending query response protocol marker
+  static bool readAll(std::istream &s,Decoder &decoder);		///< Read a whole response as an XML document
+  static void passJavaException(std::ostream &s,const std::string &tp,const std::string &msg);
 
-  static bool isDynamicSymbolName(const string &nm);		///< Check if name is of form FUN_.. or DAT_..
+  static bool isDynamicSymbolName(const std::string &nm);		///< Check if name is of form FUN_.. or DAT_..
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.cc
index 226c3249c..80106670a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.cc
@@ -15,6 +15,8 @@
  */
 #include "ghidra_context.hh"
 
+using namespace std;
+
 const TrackedSet &ContextGhidra::getTrackedSet(const Address &addr) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.hh
index 68c201a33..bd41a9042 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_context.hh
@@ -31,13 +31,13 @@
 class ContextGhidra : public ContextDatabase {
   ArchitectureGhidra *glb;			///< Architecture and connection to the Ghidra client
   mutable TrackedSet cache;			///< A cache of previously fetched tracked registers.
-  virtual ContextBitRange &getVariable(const string &nm) {
+  virtual ContextBitRange &getVariable(const std::string &nm) {
     throw LowlevelError("getVariable should not be called for GHIDRA"); }
-  virtual const ContextBitRange &getVariable(const string &nm) const {
+  virtual const ContextBitRange &getVariable(const std::string &nm) const {
     throw LowlevelError("getVariable should not be called for GHIDRA"); }
-  virtual void getRegionForSet(vector<uintm *> &res,const Address &addr1,const Address &addr2,int4 num,uintm mask) {
+  virtual void getRegionForSet(std::vector<uintm *> &res,const Address &addr1,const Address &addr2,int4 num,uintm mask) {
     throw LowlevelError("getRegionForSet should not be called for GHIDRA"); }
-  virtual void getRegionToChangePoint(vector<uintm *> &res,const Address &addr,int4 num,uintm mask) {
+  virtual void getRegionToChangePoint(std::vector<uintm *> &res,const Address &addr,int4 num,uintm mask) {
     throw LowlevelError("getRegionToChangePoint should not be called for GHIDRA"); }
   virtual const uintm *getDefaultValue(void) const {
     throw LowlevelError("getDefaultValue should not be called for GHIDRA"); }
@@ -61,7 +61,7 @@ class ContextGhidra : public ContextDatabase {
     throw LowlevelError("getContext should not be called for GHIDRA"); }
   virtual const uintm *getContext(const Address &addr,uintb &first,uintb &last) const {
     throw LowlevelError("getContext should not be called for GHIDRA"); }
-  virtual void registerVariable(const string &nm,int4 sbit,int4 ebit) {
+  virtual void registerVariable(const std::string &nm,int4 sbit,int4 ebit) {
     throw LowlevelError("registerVariable should not be called for GHIDRA"); }
   virtual void encode(Encoder &encoder) const {
     throw LowlevelError("context::encode should not be called for GHIDRA"); }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
index a2cc2299b..e1a7f57cd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
@@ -22,6 +22,8 @@
 #include <io.h>
 #endif
 
+using namespace std;
+
 #ifdef __REMOTE_SOCKET__
 
 #include "ifacedecomp.hh"
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
index 8c682d80d..428319a65 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
@@ -39,11 +39,11 @@ extern ElementId ELEM_DOC;		///< Marshaling element \<doc>
 /// a command from the stream and dispatching to the correct GhidraCommand object.
 class GhidraCapability : public CapabilityPoint {
 protected:
-  static map<string,GhidraCommand *> commandmap;	///< The central map from \e name to Ghidra command
-  string name;						///< Identifier for capability and associated commands
+  static std::map<std::string,GhidraCommand *> commandmap;	///< The central map from \e name to Ghidra command
+  std::string name;						///< Identifier for capability and associated commands
 public:
-  const string &getName(void) const { return name; }	///< Get the capability name
-  static int4 readCommand(istream &sin,ostream &out);	///< Dispatch a Ghidra command
+  const std::string &getName(void) const { return name; }	///< Get the capability name
+  static int4 readCommand(std::istream &sin,std::ostream &out);	///< Dispatch a Ghidra command
   static void shutDown(void);				///< Release all GhidraCommand resources
 };
 
@@ -72,14 +72,14 @@ class GhidraDecompCapability : public GhidraCapability {
 /// and sendResult() will send back any accumulated warning/error messages.
 class GhidraCommand {
 protected:
-  istream &sin;				///< The input stream from the Ghidra client
-  ostream &sout;			///< The output stream to the Ghidra client
+  std::istream &sin;				///< The input stream from the Ghidra client
+  std::ostream &sout;			///< The output stream to the Ghidra client
   ArchitectureGhidra *ghidra;		///< The Architecture on which to perform the command
   int4 status;				///< Meta-command to system (0=wait for next command, 1=terminate process)
   virtual void loadParameters(void);	///< Read parameters directing command execution
   virtual void sendResult(void);	///< Send results of the command (if any) back to the Ghidra client
 public:
-  GhidraCommand(void) : sin(cin),sout(cout) {
+  GhidraCommand(void) : sin(std::cin),sout(std::cout) {
     ghidra = (ArchitectureGhidra *)0; 
   }					///< Construct given i/o streams
   virtual ~GhidraCommand(void) {}	///< Destructor
@@ -102,10 +102,10 @@ class GhidraCommand {
 ///   - The stripped down \<sleigh> tag describing address spaces for the program
 ///   - The \<coretypes> tag describing the built-in datatypes for the program
 class RegisterProgram : public GhidraCommand {
-  string pspec;				///< Processor specification to configure with
-  string cspec;				///< Compiler specification to configure with
-  string tspec;				///< Configuration (address-spaces) for the Translate object
-  string corespec;			///< A description of core data-types for the TypeFactory object
+  std::string pspec;				///< Processor specification to configure with
+  std::string cspec;				///< Compiler specification to configure with
+  std::string tspec;				///< Configuration (address-spaces) for the Translate object
+  std::string corespec;			///< A description of core data-types for the TypeFactory object
   virtual void loadParameters(void);
   virtual void sendResult(void);
 public:
@@ -203,8 +203,8 @@ class StructureGraph : public GhidraCommand {
 /// The command returns a single character message, 't' or 'f', indicating whether the
 /// action succeeded.
 class SetAction : public GhidraCommand {
-  string actionstring;			///< The \e root Action to switch to
-  string printstring;			///< The \e printing output configuration to toggle
+  std::string actionstring;			///< The \e root Action to switch to
+  std::string printstring;			///< The \e printing output configuration to toggle
   virtual void loadParameters(void);
   virtual void sendResult(void);
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.cc
index dd2c0274a..bb5211a8f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.cc
@@ -16,6 +16,8 @@
 #include "ghidra_translate.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 /// \brief Associate a Varnode with a register name
 ///
 /// \param nm is the register name
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.hh
index 207f2f375..c41fc12d9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_translate.hh
@@ -33,19 +33,19 @@
 /// have a tight internal encoding.
 class GhidraTranslate : public Translate {
   ArchitectureGhidra *glb;			///< The Ghidra Architecture and connection to the client
-  mutable map<string,VarnodeData> nm2addr;	///< Mapping from register name to Varnode
-  mutable map<VarnodeData,string> addr2nm;	///< Mapping rom Varnode to register name
-  const VarnodeData &cacheRegister(const string &nm,const VarnodeData &data) const;
+  mutable std::map<std::string,VarnodeData> nm2addr;	///< Mapping from register name to Varnode
+  mutable std::map<VarnodeData,std::string> addr2nm;	///< Mapping rom Varnode to register name
+  const VarnodeData &cacheRegister(const std::string &nm,const VarnodeData &data) const;
   void decode(Decoder &decoder);		///< Initialize \b this Translate from a stream
 public:
   GhidraTranslate(ArchitectureGhidra *g) { glb = g; }	///< Constructor
 
   virtual void initialize(DocumentStorage &store);
-  virtual const VarnodeData &getRegister(const string &nm) const;
-  virtual string getRegisterName(AddrSpace *base,uintb off,int4 size) const;
-  virtual void getAllRegisters(map<VarnodeData,string> &reglist) const {
+  virtual const VarnodeData &getRegister(const std::string &nm) const;
+  virtual std::string getRegisterName(AddrSpace *base,uintb off,int4 size) const;
+  virtual void getAllRegisters(std::map<VarnodeData,std::string> &reglist) const {
     throw LowlevelError("Cannot currently get all registers through this interface"); }
-  virtual void getUserOpNames(vector<string> &res) const;
+  virtual void getUserOpNames(std::vector<std::string> &res) const;
   virtual int4 oneInstruction(PcodeEmit &emit,const Address &baseaddr) const;
   virtual int4 instructionLength(const Address &baseaddr) const {
     throw LowlevelError("Cannot currently get instruction length through this interface"); }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.cc
index 15badbad3..a70ec2686 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.cc
@@ -15,6 +15,8 @@
  */
 #include "globalcontext.hh"
 
+using namespace std;
+
 ElementId ELEM_CONTEXT_DATA = ElementId("context_data",120);
 ElementId ELEM_CONTEXT_POINTS = ElementId("context_points",121);
 ElementId ELEM_CONTEXT_POINTSET = ElementId("context_pointset",122);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.hh
index 6bf5ae0fe..6e76a125a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/globalcontext.hh
@@ -79,7 +79,7 @@ struct TrackedContext {
   void decode(Decoder &decoder);			///< Decode \b this from a stream
   void encode(Encoder &encoder) const;			///< Encode \b this to a stream
 };
-typedef vector<TrackedContext> TrackedSet;		///< A set of tracked registers and their values (at one code point)
+typedef std::vector<TrackedContext> TrackedSet;		///< A set of tracked registers and their values (at one code point)
 
 /// \brief An interface to a database of disassembly/decompiler \b context information
 ///
@@ -123,14 +123,14 @@ class ContextDatabase {
   /// If the variable doesn't exist an exception is thrown.
   /// \param nm is the name of the context value
   /// \return the ContextBitRange object matching the name
-  virtual ContextBitRange &getVariable(const string &nm)=0;
+  virtual ContextBitRange &getVariable(const std::string &nm)=0;
 
   /// \brief Retrieve the context variable description object by name
   ///
   /// If the variable doesn't exist an exception is thrown.
   /// \param nm is the name of the context value
   /// \return the ContextBitRange object matching the name
-  virtual const ContextBitRange &getVariable(const string &nm) const=0;
+  virtual const ContextBitRange &getVariable(const std::string &nm) const=0;
 
   /// \brief Grab the context blob(s) for the given address range, marking bits that will be set
   ///
@@ -144,7 +144,7 @@ class ContextDatabase {
   /// \param addr2 is (1 past) the last address of the range or is invalid
   /// \param num is the word index for the context value that will be set
   /// \param mask is a mask of the value being set (within its word)
-  virtual void getRegionForSet(vector<uintm *> &res,const Address &addr1,
+  virtual void getRegionForSet(std::vector<uintm *> &res,const Address &addr1,
 			       const Address &addr2,int4 num,uintm mask)=0;
 
   /// \brief Grab the context blob(s) starting at the given address up to the first point of change
@@ -156,7 +156,7 @@ class ContextDatabase {
   /// \param addr is the starting address of the regions to fetch
   /// \param num is the word index for the specific context value being set
   /// \param mask is a mask of the context value being set (within its word)
-  virtual void getRegionToChangePoint(vector<uintm *> &res,const Address &addr,int4 num,uintm mask)=0;
+  virtual void getRegionToChangePoint(std::vector<uintm *> &res,const Address &addr,int4 num,uintm mask)=0;
 
   /// \brief Retrieve the memory region holding all default context values
   ///
@@ -188,7 +188,7 @@ class ContextDatabase {
   /// \param nm is the name of the new variable
   /// \param sbit is the position of the variable's most significant bit within the blob
   /// \param ebit is the position of the variable's least significant bit within the blob
-  virtual void registerVariable(const string &nm,int4 sbit,int4 ebit)=0;
+  virtual void registerVariable(const std::string &nm,int4 sbit,int4 ebit)=0;
 
   /// \brief Get the context blob of values associated with a given address
   ///
@@ -243,13 +243,13 @@ class ContextDatabase {
   /// \param decoder is the given stream decoder
   virtual void decodeFromSpec(Decoder &decoder)=0;
 
-  void setVariableDefault(const string &nm,uintm val);	///< Provide a default value for a context variable
-  uintm getDefaultValue(const string &nm) const;	///< Retrieve the default value for a context variable
-  void setVariable(const string &nm,const Address &addr,uintm value);	///< Set a context value at the given address
-  uintm getVariable(const string &nm,const Address &addr) const;	///< Retrieve a context value at the given address
+  void setVariableDefault(const std::string &nm,uintm val);	///< Provide a default value for a context variable
+  uintm getDefaultValue(const std::string &nm) const;	///< Retrieve the default value for a context variable
+  void setVariable(const std::string &nm,const Address &addr,uintm value);	///< Set a context value at the given address
+  uintm getVariable(const std::string &nm,const Address &addr) const;	///< Retrieve a context value at the given address
   void setContextChangePoint(const Address &addr,int4 num,uintm mask,uintm value);
   void setContextRegion(const Address &addr1,const Address &addr2,int4 num,uintm mask,uintm value);
-  void setVariableRegion(const string &nm,const Address &begad,
+  void setVariableRegion(const std::string &nm,const Address &begad,
 			 const Address &endad,uintm value);
   uintb getTrackedValue(const VarnodeData &mem,const Address &point) const;
 };
@@ -277,23 +277,23 @@ class ContextInternal : public ContextDatabase {
   };
 
   int4 size;			///< Number of words in a context blob (for this architecture)
-  map<string,ContextBitRange> variables;		///< Map from context variable name to description object
+  std::map<std::string,ContextBitRange> variables;		///< Map from context variable name to description object
   partmap<Address,FreeArray> database;			///< Partition map of context blobs (FreeArray)
   partmap<Address,TrackedSet> trackbase;		///< Partition map of tracked register sets
   void encodeContext(Encoder &encoder,const Address &addr,const uintm *vec) const;
   void decodeContext(Decoder &decoder,const Address &addr1,const Address &addr2);
-  virtual ContextBitRange &getVariable(const string &nm);
-  virtual const ContextBitRange &getVariable(const string &nm) const;
-  virtual void getRegionForSet(vector<uintm *> &res,const Address &addr1,
+  virtual ContextBitRange &getVariable(const std::string &nm);
+  virtual const ContextBitRange &getVariable(const std::string &nm) const;
+  virtual void getRegionForSet(std::vector<uintm *> &res,const Address &addr1,
 			       const Address &addr2,int4 num,uintm mask);
-  virtual void getRegionToChangePoint(vector<uintm *> &res,const Address &addr,int4 num,uintm mask);
+  virtual void getRegionToChangePoint(std::vector<uintm *> &res,const Address &addr,int4 num,uintm mask);
   virtual uintm *getDefaultValue(void) { return database.defaultValue().array; }
   virtual const uintm *getDefaultValue(void) const { return database.defaultValue().array; }
 public:
   ContextInternal(void) { size = 0; }
   virtual ~ContextInternal(void) {}
   virtual int4 getContextSize(void) const { return size; }
-  virtual void registerVariable(const string &nm,int4 sbit,int4 ebit);
+  virtual void registerVariable(const std::string &nm,int4 sbit,int4 ebit);
 
   virtual const uintm *getContext(const Address &addr) const { return database.getValue(addr).array; }
   virtual const uintm *getContext(const Address &addr,uintb &first,uintb &last) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
index aab637f39..a87932dc8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.cc
@@ -89,6 +89,8 @@
 
 #include "grammar.hh"
 
+using namespace std;
+
 extern int yylex(void);
 extern int yyerror(const char *str);
 static CParse *parse;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.hh
index 3f9115e72..2caa79ce4 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/grammar.hh
@@ -45,7 +45,7 @@ class GrammarToken {
   uint4 type;
   union tokenvalue {
     uintb integer;
-    string *stringval;
+    std::string *stringval;
   };
   tokenvalue value;
   int4 lineno;			// Line number containing this token
@@ -58,25 +58,25 @@ class GrammarToken {
   GrammarToken(void);
   uint4 getType(void) const { return type; }
   uintb getInteger(void) const { return value.integer; }
-  string *getString(void) const { return value.stringval; }
+  std::string *getString(void) const { return value.stringval; }
   int4 getLineNo(void) const { return lineno; }
   int4 getColNo(void) const { return colno; }
   int4 getFileNum(void) const { return filenum; }
 };
 
 class GrammarLexer {
-  map<int4,string> filenamemap;	// All files ever seen
-  map<int4,istream *> streammap;
-  vector<int4> filestack;	// Stack of current files
+  std::map<int4,std::string> filenamemap;	// All files ever seen
+  std::map<int4,std::istream *> streammap;
+  std::vector<int4> filestack;	// Stack of current files
   int4 buffersize;		// maximum characters in buffer
   char *buffer;			// Current line being processed
   int4 bufstart;		// Next character to process
   int4 bufend;			// Next open position in buffer
   int4 curlineno;
-  istream *in;			// Current stream
+  std::istream *in;			// Current stream
   bool endoffile;
   uint4 state;			// State of parser
-  string error;
+  std::string error;
   enum {
     start,
     slash,
@@ -97,18 +97,18 @@ class GrammarLexer {
   void bumpLine(void);
   uint4 moveState(char lookahead);
   void establishToken(GrammarToken &token,uint4 val);
-  void setError(const string &err) { error = err; }
+  void setError(const std::string &err) { error = err; }
 public:
   GrammarLexer(int4 maxbuffer);
   ~GrammarLexer(void);
   void clear(void);
-  istream *getCurStream(void) { return in; }
-  void pushFile(const string &filename,istream *i);
+  std::istream *getCurStream(void) { return in; }
+  void pushFile(const std::string &filename,std::istream *i);
   void popFile(void);
   void getNextToken(GrammarToken &token);
-  void writeLocation(ostream &s,int4 line,int4 filenum);
-  void writeTokenLocation(ostream &s,int4 line,int4 colno);
-  const string &getError(void) const { return error; }
+  void writeLocation(std::ostream &s,int4 line,int4 filenum);
+  void writeTokenLocation(std::ostream &s,int4 line,int4 colno);
+  const std::string &getError(void) const { return error; }
 };
 
 class TypeDeclarator;		// Forward declaration
@@ -148,12 +148,12 @@ class ArrayModifier : public TypeModifier {
 };
 
 class FunctionModifier : public TypeModifier {
-  vector<TypeDeclarator *> paramlist;
+  std::vector<TypeDeclarator *> paramlist;
   bool dotdotdot;
 public:
-  FunctionModifier(const vector<TypeDeclarator *> *p,bool dtdtdt);
-  void getInTypes(vector<Datatype *> &intypes,Architecture *glb) const;
-  void getInNames(vector<string> &innames) const;
+  FunctionModifier(const std::vector<TypeDeclarator *> *p,bool dtdtdt);
+  void getInTypes(std::vector<Datatype *> &intypes,Architecture *glb) const;
+  void getInNames(std::vector<std::string> &innames) const;
   bool isDotdotdot(void) const { return dotdotdot; }
   virtual uint4 getType(void) const { return function_mod; }
   virtual bool isValid(void) const;
@@ -162,18 +162,18 @@ class FunctionModifier : public TypeModifier {
 
 class TypeDeclarator {
   friend class CParse;
-  vector<TypeModifier *> mods;
+  std::vector<TypeModifier *> mods;
   Datatype *basetype;
-  string ident;			// variable identifier associated with type
-  string model;			// name of model associated with function pointer
+  std::string ident;			// variable identifier associated with type
+  std::string model;			// name of model associated with function pointer
   uint4 flags;			// Specifiers qualifiers
 public:
   TypeDeclarator(void) { basetype=(Datatype *)0; flags=0; }
-  TypeDeclarator(const string &nm) { ident=nm; basetype=(Datatype *)0; flags=0; }
+  TypeDeclarator(const std::string &nm) { ident=nm; basetype=(Datatype *)0; flags=0; }
   ~TypeDeclarator(void);
   Datatype *getBaseType(void) const { return basetype; }
   int4 numModifiers(void) const { return mods.size(); }
-  const string &getIdentifier(void) const { return ident; }
+  const std::string &getIdentifier(void) const { return ident; }
   ProtoModel *getModel(Architecture *glb) const;
   bool getPrototype(PrototypePieces &pieces,Architecture *glb) const;
   bool hasProperty(uint4 mask) { return ((flags&mask)!=0); }
@@ -183,17 +183,17 @@ class TypeDeclarator {
 
 struct TypeSpecifiers {
   Datatype *type_specifier;
-  string function_specifier;
+  std::string function_specifier;
   uint4 flags;
   TypeSpecifiers(void) { type_specifier = (Datatype *)0; flags = 0; }
 };
 
 struct Enumerator {
-  string enumconstant;		// Identifier associated with constant
+  std::string enumconstant;		// Identifier associated with constant
   bool constantassigned;	// True if user specified explicit constant
   uintb value;			// The actual constant
-  Enumerator(const string &nm) { constantassigned = false; enumconstant = nm; }
-  Enumerator(const string &nm,uintb val) { constantassigned = true; enumconstant=nm; value=val; }
+  Enumerator(const std::string &nm) { constantassigned = false; enumconstant = nm; }
+  Enumerator(const std::string &nm,uintb val) { constantassigned = true; enumconstant=nm; value=val; }
 };
 
 class CParse {
@@ -218,74 +218,74 @@ class CParse {
   };
 private:
   Architecture *glb;
-  map<string,uint4> keywords;
+  std::map<std::string,uint4> keywords;
   GrammarLexer lexer;
   int4 lineno,colno,filenum;	// Location of last token
-  list<TypeDeclarator *> typedec_alloc;
-  list<TypeSpecifiers *> typespec_alloc;
-  list<vector<uint4> *> vecuint4_alloc;
-  list<vector<TypeDeclarator *> *> vecdec_alloc;
-  list<string *> string_alloc;
-  list<uintb *> num_alloc;
-  list<Enumerator *> enum_alloc;
-  list<vector<Enumerator *> *> vecenum_alloc;
+  std::list<TypeDeclarator *> typedec_alloc;
+  std::list<TypeSpecifiers *> typespec_alloc;
+  std::list<std::vector<uint4> *> vecuint4_alloc;
+  std::list<std::vector<TypeDeclarator *> *> vecdec_alloc;
+  std::list<std::string *> string_alloc;
+  std::list<uintb *> num_alloc;
+  std::list<Enumerator *> enum_alloc;
+  std::list<std::vector<Enumerator *> *> vecenum_alloc;
 
-  vector<TypeDeclarator *> *lastdecls;
+  std::vector<TypeDeclarator *> *lastdecls;
   int4 firsttoken;		// Message to parser indicating desired object
-  string lasterror;
-  void setError(const string &msg);
-  int4 lookupIdentifier(const string &nm);
+  std::string lasterror;
+  void setError(const std::string &msg);
+  int4 lookupIdentifier(const std::string &nm);
   bool runParse(uint4 doctype);
 public:
   CParse(Architecture *g,int4 maxbuf);
   ~CParse(void);
   void clear(void);
-  vector<TypeDeclarator *> *mergeSpecDecVec(TypeSpecifiers *spec);
-  vector<TypeDeclarator *> *mergeSpecDecVec(TypeSpecifiers *spec,vector<TypeDeclarator *> *declist);
+  std::vector<TypeDeclarator *> *mergeSpecDecVec(TypeSpecifiers *spec);
+  std::vector<TypeDeclarator *> *mergeSpecDecVec(TypeSpecifiers *spec,std::vector<TypeDeclarator *> *declist);
   TypeDeclarator *mergeSpecDec(TypeSpecifiers *spec);
   TypeDeclarator *mergeSpecDec(TypeSpecifiers *spec,TypeDeclarator *dec);
-  TypeSpecifiers *addSpecifier(TypeSpecifiers *spec,string *str);
+  TypeSpecifiers *addSpecifier(TypeSpecifiers *spec,std::string *str);
   TypeSpecifiers *addTypeSpecifier(TypeSpecifiers *spec,Datatype *tp);
-  TypeSpecifiers *addFuncSpecifier(TypeSpecifiers *spec,string *str);
-  TypeDeclarator *mergePointer(vector<uint4> *ptr,TypeDeclarator *dec);
-  TypeDeclarator *newDeclarator(string *str);
+  TypeSpecifiers *addFuncSpecifier(TypeSpecifiers *spec,std::string *str);
+  TypeDeclarator *mergePointer(std::vector<uint4> *ptr,TypeDeclarator *dec);
+  TypeDeclarator *newDeclarator(std::string *str);
   TypeDeclarator *newDeclarator(void);
   TypeSpecifiers *newSpecifier(void);
-  vector<TypeDeclarator *> *newVecDeclarator(void);
-  vector<uint4> *newPointer(void);
+  std::vector<TypeDeclarator *> *newVecDeclarator(void);
+  std::vector<uint4> *newPointer(void);
   TypeDeclarator *newArray(TypeDeclarator *dec,uint4 flags,uintb *num);
-  TypeDeclarator *newFunc(TypeDeclarator *dec,vector<TypeDeclarator *> *declist);
-  Datatype *newStruct(const string &ident,vector<TypeDeclarator *> *declist);
-  Datatype *oldStruct(const string &ident);
-  Datatype *newUnion(const string &ident,vector<TypeDeclarator *> *declist);
-  Datatype *oldUnion(const string &ident);
-  Enumerator *newEnumerator(const string &ident);
-  Enumerator *newEnumerator(const string &ident,uintb val);
-  vector<Enumerator *> *newVecEnumerator(void);
-  Datatype *newEnum(const string &ident,vector<Enumerator *> *vecenum);
-  Datatype *oldEnum(const string &ident);
-  uint4 convertFlag(string *str);
+  TypeDeclarator *newFunc(TypeDeclarator *dec,std::vector<TypeDeclarator *> *declist);
+  Datatype *newStruct(const std::string &ident,std::vector<TypeDeclarator *> *declist);
+  Datatype *oldStruct(const std::string &ident);
+  Datatype *newUnion(const std::string &ident,std::vector<TypeDeclarator *> *declist);
+  Datatype *oldUnion(const std::string &ident);
+  Enumerator *newEnumerator(const std::string &ident);
+  Enumerator *newEnumerator(const std::string &ident,uintb val);
+  std::vector<Enumerator *> *newVecEnumerator(void);
+  Datatype *newEnum(const std::string &ident,std::vector<Enumerator *> *vecenum);
+  Datatype *oldEnum(const std::string &ident);
+  uint4 convertFlag(std::string *str);
 
   void clearAllocation(void);
   int4 lex(void);
 
-  bool parseFile(const string &filename,uint4 doctype);
-  bool parseStream(istream &s,uint4 doctype);
+  bool parseFile(const std::string &filename,uint4 doctype);
+  bool parseStream(std::istream &s,uint4 doctype);
 
-  const string &getError(void) const { return lasterror; }
-  void setResultDeclarations(vector<TypeDeclarator *> *val) { lastdecls = val; }
-  vector<TypeDeclarator *> *getResultDeclarations(void) { return lastdecls; }
+  const std::string &getError(void) const { return lasterror; }
+  void setResultDeclarations(std::vector<TypeDeclarator *> *val) { lastdecls = val; }
+  std::vector<TypeDeclarator *> *getResultDeclarations(void) { return lastdecls; }
 };
 
-extern Datatype *parse_type(istream &s,string &name,Architecture *glb);
-extern void parse_protopieces(PrototypePieces &pieces,istream &s,Architecture *glb);
-extern void parse_C(Architecture *glb,istream &s);
+extern Datatype *parse_type(std::istream &s,std::string &name,Architecture *glb);
+extern void parse_protopieces(PrototypePieces &pieces,std::istream &s,Architecture *glb);
+extern void parse_C(Architecture *glb,std::istream &s);
 
 // Routines to parse interface commands
 
-extern void parse_toseparator(istream &s,string &name);
-extern Address parse_machaddr(istream &s,int4 &defaultsize,const TypeFactory &typegrp,bool ignorecolon=false);
-extern Address parse_varnode(istream &s,int4 &size,Address &pc,uintm &uq,const TypeFactory &typegrp);
-extern Address parse_op(istream &s,uintm &uq,const TypeFactory &typegrp);
+extern void parse_toseparator(std::istream &s,std::string &name);
+extern Address parse_machaddr(std::istream &s,int4 &defaultsize,const TypeFactory &typegrp,bool ignorecolon=false);
+extern Address parse_varnode(std::istream &s,int4 &size,Address &pc,uintm &uq,const TypeFactory &typegrp);
+extern Address parse_op(std::istream &s,uintm &uq,const TypeFactory &typegrp);
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/graph.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/graph.cc
index 20d7cd196..31b69addd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/graph.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/graph.cc
@@ -16,6 +16,8 @@
  */
 #include "graph.hh"
 
+using namespace std;
+
 static void print_varnode_vertex(Varnode *vn,ostream &s)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/graph.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/graph.hh
index edd6ce865..09467394f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/graph.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/graph.hh
@@ -20,8 +20,8 @@
 
 #include "funcdata.hh"
 
-extern void dump_dataflow_graph(Funcdata &data,ostream &s);
-extern void dump_controlflow_graph(const string &name,const BlockGraph &graph,ostream &s);
-extern void dump_dom_graph(const string &name,const BlockGraph &graph,ostream &s);
+extern void dump_dataflow_graph(Funcdata &data,std::ostream &s);
+extern void dump_controlflow_graph(const std::string &name,const BlockGraph &graph,std::ostream &s);
+extern void dump_dom_graph(const std::string &name,const BlockGraph &graph,std::ostream &s);
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
index c0347663e..804d90f2c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
@@ -17,6 +17,8 @@
 #include "funcdata.hh"
 #include "prefersplit.hh"
 
+using namespace std;
+
 /// Update disjoint cover making sure (addr,size) is contained in a single element
 /// and return iterator to this element. Pass back \b intersect value:
 ///   - 0 if the only intersection is with range from the same pass
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.hh
index e3609d42f..69b49906a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.hh
@@ -24,7 +24,7 @@
 
 /// Container holding the stack system for the renaming algorithm.  Every disjoint address
 /// range (indexed by its initial address) maps to its own Varnode stack.
-typedef map<Address,vector<Varnode *> > VariableStack;
+typedef std::map<Address,std::vector<Varnode *> > VariableStack;
 
 /// \brief Label for describing extent of address range that has been heritaged
 struct SizePass {
@@ -42,9 +42,9 @@ struct SizePass {
 class LocationMap {
 public:
   /// Iterator into the main map
-  typedef map<Address,SizePass>::iterator iterator;
+  typedef std::map<Address,SizePass>::iterator iterator;
 private:
-  map<Address,SizePass> themap;	///< Heritaged addresses mapped to range size and pass number
+  std::map<Address,SizePass> themap;	///< Heritaged addresses mapped to range size and pass number
 public:
   iterator add(Address addr,int4 size,int4 pass,int4 &intersect); ///< Mark new address as \b heritaged
   iterator find(const Address &addr);			///< Look up if/how given address was heritaged
@@ -62,7 +62,7 @@ class LocationMap {
 /// with an associated \e priority (or depth) using the insert() method.  The current
 /// highest priority block is retrieved with the extract() method.
 class PriorityQueue {
-  vector<vector<FlowBlock *> > queue; ///< An array of \e stacks, indexed by priority
+  std::vector<std::vector<FlowBlock *> > queue; ///< An array of \e stacks, indexed by priority
   int4 curdepth;		      ///< The current highest priority index with active blocks
 public:
   PriorityQueue(void) { curdepth = -2; } ///< Constructor
@@ -184,7 +184,7 @@ class Heritage {
     Varnode *vn;		///< Varnode being traversed
     uintb offset;		///< Offset relative to base
     uint4 traversals;		///< What kind of operations has this pointer accumulated
-    list<PcodeOp *>::const_iterator iter;	///< Next PcodeOp to follow
+    std::list<PcodeOp *>::const_iterator iter;	///< Next PcodeOp to follow
 
     /// \brief Constructor
     /// \param v is the Varnode being visited
@@ -201,19 +201,19 @@ class Heritage {
   Funcdata *fd;		        ///< The function \b this is controlling SSA construction 
   LocationMap globaldisjoint;	///< Disjoint cover of every heritaged memory location
   LocationMap disjoint;		///< Disjoint cover of memory locations currently being heritaged
-  vector<vector<FlowBlock *> > domchild; ///< Parent->child edges in dominator tree
-  vector<vector<FlowBlock *> > augment; ///< Augmented edges
-  vector<uint4> flags;		///< Block properties for phi-node placement algorithm
-  vector<int4> depth;		///< Dominator depth of individual blocks
+  std::vector<std::vector<FlowBlock *> > domchild; ///< Parent->child edges in dominator tree
+  std::vector<std::vector<FlowBlock *> > augment; ///< Augmented edges
+  std::vector<uint4> flags;		///< Block properties for phi-node placement algorithm
+  std::vector<int4> depth;		///< Dominator depth of individual blocks
   int4 maxdepth;		///< Maximum depth of the dominator tree
   int4 pass;			///< Current pass being executed
 
   PriorityQueue pq;		///< Priority queue for phi-node placement
-  vector<FlowBlock *> merge;	///< Calculate merge points (blocks containing phi-nodes)
-  vector<HeritageInfo> infolist; ///< Heritage status for individual address spaces
-  list<LoadGuard> loadGuard;	///< List of LOAD operations that need to be guarded
-  list<LoadGuard> storeGuard;	///< List of STORE operations taking an indexed pointer to the stack
-  vector<PcodeOp *> loadCopyOps;	///< List of COPY ops generated by load guards
+  std::vector<FlowBlock *> merge;	///< Calculate merge points (blocks containing phi-nodes)
+  std::vector<HeritageInfo> infolist; ///< Heritage status for individual address spaces
+  std::list<LoadGuard> loadGuard;	///< List of LOAD operations that need to be guarded
+  std::list<LoadGuard> storeGuard;	///< List of STORE operations taking an indexed pointer to the stack
+  std::vector<PcodeOp *> loadCopyOps;	///< List of COPY ops generated by load guards
   void clearInfoList(void);	 ///< Reset heritage status for all address spaces
 
   /// \brief Get the heritage status for the given address space
@@ -223,47 +223,47 @@ class Heritage {
   const HeritageInfo *getInfo(AddrSpace *spc) const { return &(infolist[spc->getIndex()]); }
 
   void clearStackPlaceholders(HeritageInfo *info);	///< Clear remaining stack placeholder LOADs on any call
-  void splitJoinLevel(vector<Varnode *> &lastcombo,vector<Varnode *> &nextlev,JoinRecord *joinrec);
+  void splitJoinLevel(std::vector<Varnode *> &lastcombo,std::vector<Varnode *> &nextlev,JoinRecord *joinrec);
   void splitJoinRead(Varnode *vn,JoinRecord *joinrec);
   void splitJoinWrite(Varnode *vn,JoinRecord *joinrec);
   void floatExtensionRead(Varnode *vn,JoinRecord *joinrec);
   void floatExtensionWrite(Varnode *vn,JoinRecord *joinrec);
   void processJoins(void);
   void buildADT(void);		///< Build the augmented dominator tree
-  void removeRevisitedMarkers(const vector<Varnode *> &remove,const Address &addr,int4 size);
-  int4 collect(Address addr,int4 size,vector<Varnode *> &read,vector<Varnode *> &write,vector<Varnode *> &input,vector<Varnode *> &remove) const;
+  void removeRevisitedMarkers(const std::vector<Varnode *> &remove,const Address &addr,int4 size);
+  int4 collect(Address addr,int4 size,std::vector<Varnode *> &read,std::vector<Varnode *> &write,std::vector<Varnode *> &input,std::vector<Varnode *> &remove) const;
   bool callOpIndirectEffect(const Address &addr,int4 size,PcodeOp *op) const;
   Varnode *normalizeReadSize(Varnode *vn,const Address &addr,int4 size);
   Varnode *normalizeWriteSize(Varnode *vn,const Address &addr,int4 size);
-  Varnode *concatPieces(const vector<Varnode *> &vnlist,PcodeOp *insertop,Varnode *finalvn);
-  void splitPieces(const vector<Varnode *> &vnlist,PcodeOp *insertop,const Address &addr,int4 size,Varnode *startvn);
-  void findAddressForces(vector<PcodeOp *> &copySinks,vector<PcodeOp *> &forces);
+  Varnode *concatPieces(const std::vector<Varnode *> &vnlist,PcodeOp *insertop,Varnode *finalvn);
+  void splitPieces(const std::vector<Varnode *> &vnlist,PcodeOp *insertop,const Address &addr,int4 size,Varnode *startvn);
+  void findAddressForces(std::vector<PcodeOp *> &copySinks,std::vector<PcodeOp *> &forces);
   void propagateCopyAway(PcodeOp *op);
   void handleNewLoadCopies(void);
   void analyzeNewLoadGuards(void);
   void generateLoadGuard(StackNode &node,PcodeOp *op,AddrSpace *spc);
   void generateStoreGuard(StackNode &node,PcodeOp *op,AddrSpace *spc);
-  bool protectFreeStores(AddrSpace *spc,vector<PcodeOp *> &freeStores);
-  bool discoverIndexedStackPointers(AddrSpace *spc,vector<PcodeOp *> &freeStores,bool checkFreeStores);
-  void reprocessFreeStores(AddrSpace *spc,vector<PcodeOp *> &freeStores);
-  void guard(const Address &addr,int4 size,vector<Varnode *> &read,vector<Varnode *> &write,vector<Varnode *> &inputvars);
-  void guardInput(const Address &addr,int4 size,vector<Varnode *> &input);
+  bool protectFreeStores(AddrSpace *spc,std::vector<PcodeOp *> &freeStores);
+  bool discoverIndexedStackPointers(AddrSpace *spc,std::vector<PcodeOp *> &freeStores,bool checkFreeStores);
+  void reprocessFreeStores(AddrSpace *spc,std::vector<PcodeOp *> &freeStores);
+  void guard(const Address &addr,int4 size,std::vector<Varnode *> &read,std::vector<Varnode *> &write,std::vector<Varnode *> &inputvars);
+  void guardInput(const Address &addr,int4 size,std::vector<Varnode *> &input);
   void guardCallOverlappingInput(FuncCallSpecs *fc,const Address &addr,const Address &transAddr,int4 size);
-  bool guardCallOverlappingOutput(FuncCallSpecs *fc,const Address &addr,int4 size,vector<Varnode *> &write);
-  void guardCalls(uint4 fl,const Address &addr,int4 size,vector<Varnode *> &write);
-  void guardStores(const Address &addr,int4 size,vector<Varnode *> &write);
-  void guardLoads(uint4 fl,const Address &addr,int4 size,vector<Varnode *> &write);
+  bool guardCallOverlappingOutput(FuncCallSpecs *fc,const Address &addr,int4 size,std::vector<Varnode *> &write);
+  void guardCalls(uint4 fl,const Address &addr,int4 size,std::vector<Varnode *> &write);
+  void guardStores(const Address &addr,int4 size,std::vector<Varnode *> &write);
+  void guardLoads(uint4 fl,const Address &addr,int4 size,std::vector<Varnode *> &write);
   void guardReturnsOverlapping(const Address &addr,int4 size);
-  void guardReturns(uint4 fl,const Address &addr,int4 size,vector<Varnode *> &write);
-  static void buildRefinement(vector<int4> &refine,const Address &addr,int4 size,const vector<Varnode *> &vnlist);
-  void splitByRefinement(Varnode *vn,const Address &addr,const vector<int4> &refine,vector<Varnode *> &split);
-  void refineRead(Varnode *vn,const Address &addr,const vector<int4> &refine,vector<Varnode *> &newvn);
-  void refineWrite(Varnode *vn,const Address &addr,const vector<int4> &refine,vector<Varnode *> &newvn);
-  void refineInput(Varnode *vn,const Address &addr,const vector<int4> &refine,vector<Varnode *> &newvn);
-  void remove13Refinement(vector<int4> &refine);
-  bool refinement(const Address &addr,int4 size,const vector<Varnode *> &readvars,const vector<Varnode *> &writevars,const vector<Varnode *> &inputvars);
+  void guardReturns(uint4 fl,const Address &addr,int4 size,std::vector<Varnode *> &write);
+  static void buildRefinement(std::vector<int4> &refine,const Address &addr,int4 size,const std::vector<Varnode *> &vnlist);
+  void splitByRefinement(Varnode *vn,const Address &addr,const std::vector<int4> &refine,std::vector<Varnode *> &split);
+  void refineRead(Varnode *vn,const Address &addr,const std::vector<int4> &refine,std::vector<Varnode *> &newvn);
+  void refineWrite(Varnode *vn,const Address &addr,const std::vector<int4> &refine,std::vector<Varnode *> &newvn);
+  void refineInput(Varnode *vn,const Address &addr,const std::vector<int4> &refine,std::vector<Varnode *> &newvn);
+  void remove13Refinement(std::vector<int4> &refine);
+  bool refinement(const Address &addr,int4 size,const std::vector<Varnode *> &readvars,const std::vector<Varnode *> &writevars,const std::vector<Varnode *> &inputvars);
   void visitIncr(FlowBlock *qnode,FlowBlock *vnode);
-  void calcMultiequals(const vector<Varnode *> &write);
+  void calcMultiequals(const std::vector<Varnode *> &write);
   void renameRecurse(BlockBasic *bl,VariableStack &varstack);
   void bumpDeadcodeDelay(Varnode *vn);
   void placeMultiequals(void);
@@ -288,8 +288,8 @@ class Heritage {
   void forceRestructure(void) { maxdepth = -1; }    ///< Force regeneration of basic block structures
   void clear(void);				    ///< Reset all analysis of heritage
   void heritage(void);				    ///< Perform one pass of heritage
-  const list<LoadGuard> &getLoadGuards(void) const { return loadGuard; }	///< Get list of LOAD ops that are guarded
-  const list<LoadGuard> &getStoreGuards(void) const { return storeGuard; }	///< Get list of STORE ops that are guarded
+  const std::list<LoadGuard> &getLoadGuards(void) const { return loadGuard; }	///< Get list of LOAD ops that are guarded
+  const std::list<LoadGuard> &getStoreGuards(void) const { return storeGuard; }	///< Get list of STORE ops that are guarded
   const LoadGuard *getStoreGuard(PcodeOp *op) const;	///< Get LoadGuard record associated with given PcodeOp
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
index 5e035d4a2..f4a1acfee 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
@@ -20,6 +20,8 @@ extern "C" {
 #include "pcodeparse.hh"
 #include "blockaction.hh"
 
+using namespace std;
+
 // Constructing this registers the capability
 IfaceDecompCapability IfaceDecompCapability::ifaceDecompCapability;
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.hh
index 73f476e20..fb9777427 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.hh
@@ -47,7 +47,7 @@ class IfaceDecompData : public IfaceData {
   FunctionTestCollection *testCollection;		///< Executable environment from a datatest
 
 #ifdef CPUI_RULECOMPILE
-  string experimental_file;	// File containing experimental rules
+  std::string experimental_file;	// File containing experimental rules
 #endif
 #ifdef OPACTION_DEBUG
   bool jumptabledebug;
@@ -55,11 +55,11 @@ class IfaceDecompData : public IfaceData {
   IfaceDecompData(void);		///< Constructor
   virtual ~IfaceDecompData(void);
   void allocateCallGraph(void);		///< Allocate the call-graph object
-  void abortFunction(ostream &s);	///< Clear references to current function
+  void abortFunction(std::ostream &s);	///< Clear references to current function
   void clearArchitecture(void);		///< Free all resources for the current architecture/program
-  void followFlow(ostream &s,int4 size);
-  Varnode *readVarnode(istream &s);	///< Read a varnode from the given stream
-  void readSymbol(const string &name,vector<Symbol *> &res);	///< Find a symbol by name
+  void followFlow(std::ostream &s,int4 size);
+  Varnode *readVarnode(std::istream &s);	///< Read a varnode from the given stream
+  void readSymbol(const std::string &name,std::vector<Symbol *> &res);	///< Find a symbol by name
 };
 
 /// \brief Disassembly emitter that prints to a console stream
@@ -68,14 +68,14 @@ class IfaceDecompData : public IfaceData {
 /// followed by the mnemonic and then column aligned operands.
 class IfaceAssemblyEmit : public AssemblyEmit {
   int4 mnemonicpad;		///< How much to pad the mnemonic
-  ostream *s;			///< The current stream to write to
+  std::ostream *s;			///< The current stream to write to
 public:
-  IfaceAssemblyEmit(ostream *val,int4 mp) { s = val; mnemonicpad=mp; }	///< Constructor
-  virtual void dump(const Address &addr,const string &mnem,const string &body) {
+  IfaceAssemblyEmit(std::ostream *val,int4 mp) { s = val; mnemonicpad=mp; }	///< Constructor
+  virtual void dump(const Address &addr,const std::string &mnem,const std::string &body) {
     addr.printRaw(*s);
     *s << ": " << mnem;
     for(int4 i=mnem.size();i<mnemonicpad;++i) *s << ' ';
-    *s << body << endl;
+    *s << body << std::endl;
   }
 };
 
@@ -94,7 +94,7 @@ class IfaceDecompCommand : public IfaceCommand {
   void iterateFunctionsAddrOrder(Scope *scope);	///< Iterate over all functions in a given scope
 public:
   virtual void setData(IfaceStatus *root,IfaceData *data) { status = root; dcp = (IfaceDecompData *)data; }
-  virtual string getModule(void) const { return "decompile"; }
+  virtual std::string getModule(void) const { return "decompile"; }
   virtual IfaceData *createData(void) { return new IfaceDecompData(); }
 
   /// \brief Perform the per-function aspect of \b this command.
@@ -108,545 +108,545 @@ class IfaceDecompCommand : public IfaceCommand {
 
 class IfcSource : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcOption : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcParseLine : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcParseFile : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcAdjustVma : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcFuncload : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcAddrrangeLoad : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCleararch : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcReadSymbols : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMapaddress : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMaphash : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMapfunction : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMapexternalref : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMaplabel : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMapconvert : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcMapunionfacet : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintdisasm : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcDump : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcDumpbinary : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcDecompile : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintLanguage : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCXml : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCFlat : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCStruct : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCGlobals : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCTypes : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcProduceC : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
 };
 
 class IfcProducePrototypes : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
 };
 
 class IfcListaction : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcListOverride : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcListprototypes : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcSetcontextrange : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcSettrackedrange : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcBreakstart : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcBreakaction : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintTree : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintBlocktree : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintSpaces : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintHigh : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintParamMeasures : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcRename : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcRetype : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcRemove : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintVarnode : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintCover : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcVarnodehighCover : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintExtrapop : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcVarnodeCover : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcNameVarnode : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTypeVarnode : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcForceFormat : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcForceDatatypeFormat : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcForcegoto : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcProtooverride : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcJumpOverride : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcFlowOverride : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcDeadcodedelay : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGlobalAdd : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGlobalRemove : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGlobalify : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGlobalRegisters : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintInputs : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   static bool nonTrivialUse(Varnode *vn);		///< Check for non-trivial use of given Varnode
   static int4 checkRestore(Varnode *vn);		///< Check if a Varnode is \e restored to its original input value
   static bool findRestore(Varnode *vn,Funcdata *fd);	///< Check if storage is \e restored
-  static void print(Funcdata *fd,ostream &s);		///< Print information about function inputs
+  static void print(Funcdata *fd,std::ostream &s);		///< Print information about function inputs
 };
 
 class IfcPrintInputsAll : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
 };
 
 class IfcLockPrototype : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcUnlockPrototype : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintLocalrange : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintMap : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcContinue : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintRaw : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGraphDataflow : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGraphControlflow : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcGraphDom : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCommentInstr : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcDuplicateHash : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
-  static void check(Funcdata *fd,ostream &s);		///< Check for duplicate hashes in given function
+  static void check(Funcdata *fd,std::ostream &s);		///< Check for duplicate hashes in given function
 
 };
 
 class IfcCallGraphDump : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCallGraphBuild : public IfaceDecompCommand {
 protected:
   bool quick;		///< Set to \b true if a quick analysis is desired
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
 };
 
 class IfcCallGraphBuildQuick : public IfcCallGraphBuild {
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCallGraphLoad : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCallGraphList : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
   virtual void iterationCallback(Funcdata *fd);
 };
 
 class IfcComment : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCallFixup : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
-  static void readPcodeSnippet(istream &s,string &name,string &outname,vector<string> &inname,
-			       string &pcodestring);
+  virtual void execute(std::istream &s);
+  static void readPcodeSnippet(std::istream &s,std::string &name,std::string &outname,std::vector<std::string> &inname,
+			       std::string &pcodestring);
 };
 
 class IfcCallOtherFixup : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcFixupApply : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcCountPcode : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPrintActionstats : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcResetActionstats : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcVolatile : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcReadonly : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPointerSetting : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcPreferSplit : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcStructureBlocks : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcAnalyzeRange : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcLoadTestFile : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcListTestCommands : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcExecuteTestCommand : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 #ifdef CPUI_RULECOMPILE
 class IfcParseRule : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcExperimentalRules : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 #endif
 
 #ifdef OPACTION_DEBUG
 class IfcDebugAction : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceBreak : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceAddress : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceEnable : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceDisable : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceClear : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcTraceList : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcBreakjump : public IfaceDecompCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.cc
index 44a584305..ebcf1fcfd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.cc
@@ -15,6 +15,8 @@
  */
 #include "ifaceterm.hh"
 
+using namespace std;
+
 IfaceTerm::IfaceTerm(const string &prmpt,istream &is,ostream &os)
   : IfaceStatus(prmpt,os)
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.hh
index 0b70d8b22..43817d845 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifaceterm.hh
@@ -40,14 +40,14 @@ class IfaceTerm : public IfaceStatus {
   int4 ifd;			///< Underlying file descriptor
   struct termios itty;		///< Original terminal settings
 #endif
-  istream *sptr;		///< The base input stream for the interface
-  vector<istream *> inputstack;	///< Stack of nested input streams
-  int4 doCompletion(string &line,int4 cursor);	///< 'Complete' the current command line
-  virtual void readLine(string &line);
+  std::istream *sptr;		///< The base input stream for the interface
+  std::vector<std::istream *> inputstack;	///< Stack of nested input streams
+  int4 doCompletion(std::string &line,int4 cursor);	///< 'Complete' the current command line
+  virtual void readLine(std::string &line);
 public:
-  IfaceTerm(const string &prmpt,istream &is,ostream &os);	///< Constructor
+  IfaceTerm(const std::string &prmpt,std::istream &is,std::ostream &os);	///< Constructor
   virtual ~IfaceTerm(void);
-  virtual void pushScript(istream *iptr,const string &newprompt);
+  virtual void pushScript(std::istream *iptr,const std::string &newprompt);
   virtual void popScript(void);
   virtual bool isStreamFinished(void) const;
 };
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.cc
index 6ecde748c..5845276ce 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "inject_ghidra.hh"
 
+using namespace std;
+
 void InjectContextGhidra::encode(Encoder &encoder) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.hh
index c0678039c..18844d334 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_ghidra.hh
@@ -37,26 +37,26 @@ class InjectContextGhidra : public InjectContext {
 /// When the inject() method is invoked, the context is wrapped as XML and
 /// sent to the Ghidra client, which returns the actual p-code to inject.
 class InjectPayloadGhidra : public InjectPayload {
-  string source;		///< Source description to associate with the payload
+  std::string source;		///< Source description to associate with the payload
 public:
-  InjectPayloadGhidra(const string &src,const string &nm,int4 tp) : InjectPayload(nm,tp) { source = src; }	///< Constructor
+  InjectPayloadGhidra(const std::string &src,const std::string &nm,int4 tp) : InjectPayload(nm,tp) { source = src; }	///< Constructor
   virtual void inject(InjectContext &context,PcodeEmit &emit) const;
   virtual void decode(Decoder &decoder);
-  virtual void printTemplate(ostream &s) const;
-  virtual string getSource(void) const { return source; }
+  virtual void printTemplate(std::ostream &s) const;
+  virtual std::string getSource(void) const { return source; }
 };
 
 /// \brief A call-fixup injection that uses a Ghidra client to generate the p-code ops
 class InjectCallfixupGhidra : public InjectPayloadGhidra {
 public:
-  InjectCallfixupGhidra(const string &src,const string &nm);	///< Constructor
+  InjectCallfixupGhidra(const std::string &src,const std::string &nm);	///< Constructor
   virtual void decode(Decoder &decoder);
 };
 
 /// \brief A callother-fixup injection that uses a Ghidra client to generate the p-code ops
 class InjectCallotherGhidra : public InjectPayloadGhidra {
 public:
-  InjectCallotherGhidra(const string &src,const string &nm);	///< Constructor
+  InjectCallotherGhidra(const std::string &src,const std::string &nm);	///< Constructor
   virtual void decode(Decoder &decoder);
 };
 
@@ -67,10 +67,10 @@ class InjectCallotherGhidra : public InjectPayloadGhidra {
 /// from the Ghidra client.
 class ExecutablePcodeGhidra : public ExecutablePcode {
 public:
-  ExecutablePcodeGhidra(Architecture *g,const string &src,const string &nm);	///< Constructor
+  ExecutablePcodeGhidra(Architecture *g,const std::string &src,const std::string &nm);	///< Constructor
   virtual void inject(InjectContext &context,PcodeEmit &emit) const;
   virtual void decode(Decoder &decoder);
-  virtual void printTemplate(ostream &s) const;
+  virtual void printTemplate(std::ostream &s) const;
 };
 
 /// \brief A p-code injection library that uses a Ghidra client to generate/compile the injection p-code
@@ -79,16 +79,16 @@ class ExecutablePcodeGhidra : public ExecutablePcode {
 /// At the time of injection, final p-code is generated by the Ghidra client.
 class PcodeInjectLibraryGhidra : public PcodeInjectLibrary {
   InjectContextGhidra contextCache;		///< A context object that wraps data in XML for the Ghidra client
-  vector<OpBehavior *> inst;			///< Collected behaviors for the ExecutablePcode payloads
-  virtual int4 allocateInject(const string &sourceName,const string &name,int4 type);
+  std::vector<OpBehavior *> inst;			///< Collected behaviors for the ExecutablePcode payloads
+  virtual int4 allocateInject(const std::string &sourceName,const std::string &name,int4 type);
   virtual void registerInject(int4 injectid);
 public:
   PcodeInjectLibraryGhidra(ArchitectureGhidra *ghi);		///< Constructor
-  virtual int4 manualCallFixup(const string &name,const string &snippet);
-  virtual int4 manualCallOtherFixup(const string &name,const string &outname,const vector<string> &inname,
-				    const string &snippet);
+  virtual int4 manualCallFixup(const std::string &name,const std::string &snippet);
+  virtual int4 manualCallOtherFixup(const std::string &name,const std::string &outname,const std::vector<std::string> &inname,
+				    const std::string &snippet);
   virtual InjectContext &getCachedContext(void) { return contextCache; }
-  virtual const vector<OpBehavior *> &getBehaviors(void);
+  virtual const std::vector<OpBehavior *> &getBehaviors(void);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
index e37e3f469..137d0402c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.cc
@@ -17,6 +17,8 @@
 #include "pcodeparse.hh"
 #include "architecture.hh"
 
+using namespace std;
+
 InjectContextSleigh::~InjectContextSleigh(void)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.hh
index be86fbcf6..4fa80954f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/inject_sleigh.hh
@@ -31,82 +31,82 @@ class InjectContextSleigh : public InjectContext {
 class InjectPayloadSleigh : public InjectPayload {
   friend class PcodeInjectLibrarySleigh;
   ConstructTpl *tpl;
-  string parsestring;
-  string source;
+  std::string parsestring;
+  std::string source;
 protected:
   void decodeBody(Decoder &decoder);	///< Parse the <body> tag
 public:
-  InjectPayloadSleigh(const string &src,const string &nm,int4 tp);
+  InjectPayloadSleigh(const std::string &src,const std::string &nm,int4 tp);
   virtual ~InjectPayloadSleigh(void);
   virtual void inject(InjectContext &context,PcodeEmit &emit) const;
   virtual void decode(Decoder &decoder);
-  virtual void printTemplate(ostream &s) const;
-  virtual string getSource(void) const { return source; }
+  virtual void printTemplate(std::ostream &s) const;
+  virtual std::string getSource(void) const { return source; }
 
-  static void checkParameterRestrictions(InjectContextSleigh &con,const vector<InjectParameter> &inputlist,
-					 const vector<InjectParameter> &output,const string &source);
+  static void checkParameterRestrictions(InjectContextSleigh &con,const std::vector<InjectParameter> &inputlist,
+					 const std::vector<InjectParameter> &output,const std::string &source);
   static void setupParameters(InjectContextSleigh &con,ParserWalkerChange &walker,
-			      const vector<InjectParameter> &inputlist,const vector<InjectParameter> &output,
-			      const string &source);
+			      const std::vector<InjectParameter> &inputlist,const std::vector<InjectParameter> &output,
+			      const std::string &source);
 };
 
 class InjectPayloadCallfixup : public InjectPayloadSleigh {
-  vector<string> targetSymbolNames;
+  std::vector<std::string> targetSymbolNames;
 public:
-  InjectPayloadCallfixup(const string &sourceName);
+  InjectPayloadCallfixup(const std::string &sourceName);
   virtual void decode(Decoder &decoder);
 };
 
 class InjectPayloadCallother : public InjectPayloadSleigh {
 public:
-  InjectPayloadCallother(const string &sourceName);
+  InjectPayloadCallother(const std::string &sourceName);
   virtual void decode(Decoder &decoder);
 };
 
 class ExecutablePcodeSleigh : public ExecutablePcode {
   friend class PcodeInjectLibrarySleigh;
 protected:
-  string parsestring;
+  std::string parsestring;
   ConstructTpl *tpl;
  public:
-  ExecutablePcodeSleigh(Architecture *g,const string &src,const string &nm);
+  ExecutablePcodeSleigh(Architecture *g,const std::string &src,const std::string &nm);
   virtual ~ExecutablePcodeSleigh(void);
   virtual void inject(InjectContext &context,PcodeEmit &emit) const;
   virtual void decode(Decoder &decoder);
-  virtual void printTemplate(ostream &s) const;
+  virtual void printTemplate(std::ostream &s) const;
 };
 
 class InjectPayloadDynamic : public InjectPayload {
   Architecture *glb;
-  map<Address,Document *> addrMap;		// Map from address to specific inject
+  std::map<Address,Document *> addrMap;		// Map from address to specific inject
 public:
-  InjectPayloadDynamic(Architecture *g,const string &nm,int4 tp) : InjectPayload(nm,tp) { glb = g; dynamic = true; }
+  InjectPayloadDynamic(Architecture *g,const std::string &nm,int4 tp) : InjectPayload(nm,tp) { glb = g; dynamic = true; }
   virtual ~InjectPayloadDynamic(void);
   void decodeEntry(Decoder &decoder);
   virtual void inject(InjectContext &context,PcodeEmit &emit) const;
   virtual void decode(Decoder &decoder) { throw LowlevelError("decode not supported for InjectPayloadDynamic"); }
-  virtual void printTemplate(ostream &s) const { s << "dynamic"; }
-  virtual string getSource(void) const { return "dynamic"; }
+  virtual void printTemplate(std::ostream &s) const { s << "dynamic"; }
+  virtual std::string getSource(void) const { return "dynamic"; }
 };
 
 class PcodeInjectLibrarySleigh : public PcodeInjectLibrary {
   const SleighBase *slgh;
-  vector<OpBehavior *> inst;
+  std::vector<OpBehavior *> inst;
   InjectContextSleigh contextCache;
   int4 registerDynamicInject(InjectPayload *payload);
   InjectPayloadDynamic *forceDebugDynamic(int4 injectid);
   void parseInject(InjectPayload *payload);
 protected:
-  virtual int4 allocateInject(const string &sourceName,const string &name,int4 type);
+  virtual int4 allocateInject(const std::string &sourceName,const std::string &name,int4 type);
   virtual void registerInject(int4 injectid);
 public:
   PcodeInjectLibrarySleigh(Architecture *g);
   virtual void decodeDebug(Decoder &decoder);
-  virtual int4 manualCallFixup(const string &name,const string &snippetstring);
-  virtual int4 manualCallOtherFixup(const string &name,const string &outname,const vector<string> &inname,
-				    const string &snippet);
+  virtual int4 manualCallFixup(const std::string &name,const std::string &snippetstring);
+  virtual int4 manualCallOtherFixup(const std::string &name,const std::string &outname,const std::vector<std::string> &inname,
+				    const std::string &snippet);
   virtual InjectContext &getCachedContext(void) { return contextCache; }
-  virtual const vector<OpBehavior *> &getBehaviors(void);
+  virtual const std::vector<OpBehavior *> &getBehaviors(void);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
index 8ac61f889..977703bbd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.cc
@@ -21,6 +21,8 @@
 #include "ext/stdio_filebuf.h"
 #endif
 
+using namespace std;
+
 vector<IfaceCapability *> IfaceCapability::thelist;
 
 void IfaceCapability::initialize(void)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.hh
index 0771e7428..1a467abda 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/interface.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/interface.hh
@@ -27,8 +27,6 @@
 #include <sstream>
 #include <cstdio>
 
-using namespace std;
-
 #ifdef __REMOTE_SOCKET__
 
 /// \brief A wrapper around a UNIX domain socket
@@ -38,18 +36,18 @@ using namespace std;
 /// The socket is bound to a C++ istream and ostream.
 class RemoteSocket {
   int fileDescriptor;		///< Descriptor for the socket
-  basic_filebuf<char> *inbuf;	///< Input buffer associated with the socket
-  basic_filebuf<char> *outbuf;	///< Output buffer for the socket
-  istream *inStream;		///< The C++ input stream
-  ostream *outStream;		///< The C++ output stream
+  std::basic_filebuf<char> *inbuf;	///< Input buffer associated with the socket
+  std::basic_filebuf<char> *outbuf;	///< Output buffer for the socket
+  std::istream *inStream;		///< The C++ input stream
+  std::ostream *outStream;		///< The C++ output stream
   bool isOpen;			///< Has the socket been opened
 public:
   RemoteSocket(void);				///< Constructor
   ~RemoteSocket(void) { close(); }		///< Destructor
-  bool open(const string &filename);		///< Connect to the given socket
+  bool open(const std::string &filename);		///< Connect to the given socket
   bool isSocketOpen(void);			///< Return \b true if the socket is ready to transfer data
-  istream *getInputStream(void) { return inStream; }	///< Get the input stream
-  ostream *getOutputStream(void) { return outStream; }	///< Get the output stream
+  std::istream *getInputStream(void) { return inStream; }	///< Get the input stream
+  std::ostream *getOutputStream(void) { return outStream; }	///< Get the output stream
   void close(void);				///< Close the streams and socket
 };
 
@@ -57,8 +55,8 @@ class RemoteSocket {
 
 /// \brief An exception specific to the command line interface
 struct IfaceError {
-  string explain;		///< Explanatory string
-  IfaceError(const string &s) { explain = s; }	///< Constructor
+  std::string explain;		///< Explanatory string
+  IfaceError(const std::string &s) { explain = s; }	///< Constructor
 };
 
 /// \brief An exception describing a parsing error in a command line
@@ -66,14 +64,14 @@ struct IfaceError {
 /// Thrown when attempting to parse a command line.  Options are missing or are in
 /// the wrong form etc.
 struct IfaceParseError : public IfaceError {
-  IfaceParseError(const string &s) : IfaceError(s) {}	///< Constructor
+  IfaceParseError(const std::string &s) : IfaceError(s) {}	///< Constructor
 };
 
 /// \brief An exception throw during the execution of a command
 ///
 /// Processing of a specific command has started but has reached an error state
 struct IfaceExecutionError : public IfaceError {
-  IfaceExecutionError(const string &s) : IfaceError(s) {}	///< Constructor
+  IfaceExecutionError(const std::string &s) : IfaceError(s) {}	///< Constructor
 };
 
 class IfaceStatus;		// Forward declaration
@@ -95,7 +93,7 @@ class IfaceData {
 /// The command is associated with a specific sequence of words (tokens)
 /// that should appear at the start of the command line.
 class IfaceCommand {
-  vector<string> com;		///< The token sequence associated with the command
+  std::vector<std::string> com;		///< The token sequence associated with the command
 public:
   virtual ~IfaceCommand(void) {}	///< Destructor
 
@@ -108,13 +106,13 @@ class IfaceCommand {
   /// Execute this command. Additional state can be read from the given command line stream.
   /// Otherwise, the command gets its data from its registered IfaceData object
   /// \param s is the input stream from the command line
-  virtual void execute(istream &s)=0;
+  virtual void execute(std::istream &s)=0;
 
   /// \brief Get the formal module name to which this command belongs
   ///
   /// Commands in the same module share data through their registered IfaceData object
   /// \return the formal module name
-  virtual string getModule(void) const=0;
+  virtual std::string getModule(void) const=0;
 
   /// \brief Create a specialized data object for \b this command (and its module)
   ///
@@ -125,13 +123,13 @@ class IfaceCommand {
   /// \brief Add a token to the command line string associated with this command
   ///
   /// \param temp is the new token to add
-  void addWord(const string &temp) { com.push_back(temp); }
+  void addWord(const std::string &temp) { com.push_back(temp); }
 
   void removeWord(void) { com.pop_back(); }	///< Remove the last token from the associated command line string
-  const string &getCommandWord(int4 i) const { return com[i]; }	///< Get the i-th command token
-  void addWords(const vector<string> &wordlist);	///< Add words to the associated command line string
+  const std::string &getCommandWord(int4 i) const { return com[i]; }	///< Get the i-th command token
+  void addWords(const std::vector<std::string> &wordlist);	///< Add words to the associated command line string
   int4 numWords(void) const { return com.size(); }	///< Return the number of tokens in the command line string
-  void commandString(string &res) const;	///< Get the complete command line string
+  void commandString(std::string &res) const;	///< Get the complete command line string
   int4 compare(const IfaceCommand &op2) const;	///< Order two commands by their command line strings
 };
 
@@ -139,8 +137,8 @@ class IfaceCommand {
 class IfaceCommandDummy : public IfaceCommand {
 public:
   virtual void setData(IfaceStatus *root,IfaceData *data) {}
-  virtual void execute(istream &s) {}
-  virtual string getModule(void) const { return "dummy"; }
+  virtual void execute(std::istream &s) {}
+  virtual std::string getModule(void) const { return "dummy"; }
   virtual IfaceData *createData(void) { return (IfaceData *)0; }
 };
 
@@ -159,11 +157,11 @@ inline bool compare_ifacecommand(const IfaceCommand *a,const IfaceCommand *b) {
 /// is automatically made available to any IfaceStatus object just by calling
 /// the static registerAllCommands()
 class IfaceCapability : public CapabilityPoint {
-  static vector<IfaceCapability *> thelist;	///< The global list of discovered command groupings
+  static std::vector<IfaceCapability *> thelist;	///< The global list of discovered command groupings
 protected:
-  string name;			///< Identifying name for the capability
+  std::string name;			///< Identifying name for the capability
 public:
-  const string &getName(void) const { return name; }	///< Get the name of the capability
+  const std::string &getName(void) const { return name; }	///< Get the name of the capability
   virtual void initialize(void);
   virtual void registerCommands(IfaceStatus *status)=0; ///< Register commands for \b this grouping
 
@@ -193,39 +191,39 @@ class IfaceCapability : public CapabilityPoint {
 ///   - Override pushScript() and popScript() to allow command scripts
 ///   - Get custom data into IfaceCommand callbacks
 class IfaceStatus {
-  vector<string> promptstack;	///< Stack of command prompts corresponding to script nesting level
-  vector<uint4> flagstack;	///< Stack of flag state corresponding to script nesting level
-  string prompt;		///< The current command prompt
+  std::vector<std::string> promptstack;	///< Stack of command prompts corresponding to script nesting level
+  std::vector<uint4> flagstack;	///< Stack of flag state corresponding to script nesting level
+  std::string prompt;		///< The current command prompt
   int4 maxhistory;		///< Maximum number of command lines to store in history
   int4 curhistory;		///< Most recent history
-  vector<string> history;	///< History of commands executed through this interface
+  std::vector<std::string> history;	///< History of commands executed through this interface
   bool sorted;			///< Set to \b true if commands are sorted
   bool errorisdone;		///< Set to \b true if any error terminates the process
-  void restrictCom(vector<IfaceCommand *>::const_iterator &first,
-		   vector<IfaceCommand *>::const_iterator &last,vector<string> &input);
+  void restrictCom(std::vector<IfaceCommand *>::const_iterator &first,
+		   std::vector<IfaceCommand *>::const_iterator &last,std::vector<std::string> &input);
 
   /// \brief Read the next command line
   ///
   /// \param line is filled in with the next command to execute
-  virtual void readLine(string &line)=0;
-  void saveHistory(const string &line);		///< Store the given command line into \e history
+  virtual void readLine(std::string &line)=0;
+  void saveHistory(const std::string &line);		///< Store the given command line into \e history
 protected:
   bool inerror;			///< Set to \b true if last command did not succeed
-  vector<IfaceCommand *> comlist; ///< List of registered commands
-  map<string,IfaceData *> datamap; ///< Data associated with particular modules
-  int4 expandCom(vector<string> &expand,istream &s,
-		vector<IfaceCommand *>::const_iterator &first,
-		vector<IfaceCommand *>::const_iterator &last);
+  std::vector<IfaceCommand *> comlist; ///< List of registered commands
+  std::map<std::string,IfaceData *> datamap; ///< Data associated with particular modules
+  int4 expandCom(std::vector<std::string> &expand,std::istream &s,
+		std::vector<IfaceCommand *>::const_iterator &first,
+		std::vector<IfaceCommand *>::const_iterator &last);
 public:
   bool done;			///< Set to \b true (by a command) to indicate processing is finished
-  ostream *optr;		///< Where to put command line output
-  ostream *fileoptr;		///< Where to put bulk output
+  std::ostream *optr;		///< Where to put command line output
+  std::ostream *fileoptr;		///< Where to put bulk output
 
-  IfaceStatus(const string &prmpt,ostream &os,int4 mxhist=10);	///< Constructor
+  IfaceStatus(const std::string &prmpt,std::ostream &os,int4 mxhist=10);	///< Constructor
   virtual ~IfaceStatus(void);					///< Destructor
   void setErrorIsDone(bool val) { errorisdone = val; }	///< Set if processing should terminate on an error
-  void pushScript(const string &filename,const string &newprompt);
-  virtual void pushScript(istream *iptr,const string &newprompt);
+  void pushScript(const std::string &filename,const std::string &newprompt);
+  virtual void pushScript(std::istream *iptr,const std::string &newprompt);
   virtual void popScript(void);
   virtual void reset(void);	///< Pop any existing script streams and return to processing from the base stream
   int4 getNumInputStreamSize(void) const { return promptstack.size(); }	///< Get depth of script nesting
@@ -235,14 +233,14 @@ class IfaceStatus {
 		   const char *nm3 = (const char *)0,
 		   const char *nm4 = (const char *)0,
 		   const char *nm5 = (const char *)0);
-  IfaceData *getData(const string &nm) const;	///< Get data associated with a IfaceCommand module
+  IfaceData *getData(const std::string &nm) const;	///< Get data associated with a IfaceCommand module
   bool runCommand(void);			///< Run the next command
-  void getHistory(string &line,int4 i) const;	///< Get the i-th command line from history
+  void getHistory(std::string &line,int4 i) const;	///< Get the i-th command line from history
   int4 getHistorySize(void) const { return history.size(); }	///< Get the number of command lines in history
   virtual bool isStreamFinished(void) const=0;		///< Return \b true if the current stream is finished
   bool isInError(void) const { return inerror; }	///< Return \b true if the last command failed
   void evaluateError(void);			///< Adjust which stream to process based on last error
-  static void wordsToString(string &res,const vector<string> &list);	///< Concatenate tokens
+  static void wordsToString(std::string &res,const std::vector<std::string> &list);	///< Concatenate tokens
 };
 
 /// \brief A root class for a basic set of commands
@@ -254,38 +252,38 @@ class IfaceBaseCommand : public IfaceCommand {
   IfaceStatus *status;		///< The interface owning this command instance
 public:
   virtual void setData(IfaceStatus *root,IfaceData *data) { status = root; }
-  virtual string getModule(void) const { return "base"; }
+  virtual std::string getModule(void) const { return "base"; }
   virtual IfaceData *createData(void) { return (IfaceData *)0; }
 };
 
 class IfcQuit : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcHistory : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcOpenfile : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcOpenfileAppend : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcClosefile : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 class IfcEcho : public IfaceBaseCommand {
 public:
-  virtual void execute(istream &s);
+  virtual void execute(std::istream &s);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
index 63126e06e..86146b913 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
@@ -17,6 +17,8 @@
 #include "emulate.hh"
 #include "flow.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_LABEL = AttributeId("label",131);
 AttributeId ATTRIB_NUM = AttributeId("num",132);
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.hh
index eafb09897..1e0282f41 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.hh
@@ -37,12 +37,12 @@ extern ElementId ELEM_STARTVAL;		///< Marshaling element \<startval>
 
 /// \brief Exception thrown for a thunk mechanism that looks like a jump-table
 struct JumptableThunkError : public LowlevelError {
-  JumptableThunkError(const string &s) : LowlevelError(s) {}	///< Construct with an explanatory string
+  JumptableThunkError(const std::string &s) : LowlevelError(s) {}	///< Construct with an explanatory string
 };
 
 /// \brief Exception thrown is there are no legal flows to a switch
 struct JumptableNotReachableError : public LowlevelError {
-  JumptableNotReachableError(const string &s) : LowlevelError(s) {}	///< Constructor
+  JumptableNotReachableError(const std::string &s) : LowlevelError(s) {}	///< Constructor
 };
 
 /// \brief A description where and how data was loaded from memory
@@ -61,7 +61,7 @@ class LoadTable {
   bool operator<(const LoadTable &op2) const { return (addr < op2.addr); }	///< Compare \b this with another table by address
   void encode(Encoder &encoder) const;				///< Encode a description of \b this as an \<loadtable> element
   void decode(Decoder &decoder);				///< Decode \b this table from a \<loadtable> element
-  static void collapseTable(vector<LoadTable> &table);		///< Collapse a sequence of table descriptions
+  static void collapseTable(std::vector<LoadTable> &table);		///< Collapse a sequence of table descriptions
 };
 
 /// \brief All paths from a (putative) switch variable to the CPUI_BRANCHIND
@@ -81,18 +81,18 @@ class PathMeld {
     int4 rootVn;	///< The index, within commonVn, of the Varnode at the split point
     RootedOp(PcodeOp *o,int4 root) { op = o; rootVn = root; }	///< Constructor
   };
-  vector<Varnode *> commonVn;		///< Varnodes in common with all paths
-  vector<RootedOp> opMeld;		///< All the ops for the melded paths
-  void internalIntersect(vector<int4> &parentMap);
-  int4 meldOps(const vector<PcodeOpNode> &path,int4 cutOff,const vector<int4> &parentMap);
+  std::vector<Varnode *> commonVn;		///< Varnodes in common with all paths
+  std::vector<RootedOp> opMeld;		///< All the ops for the melded paths
+  void internalIntersect(std::vector<int4> &parentMap);
+  int4 meldOps(const std::vector<PcodeOpNode> &path,int4 cutOff,const std::vector<int4> &parentMap);
   void truncatePaths(int4 cutPoint);
 public:
   void set(const PathMeld &op2);	///< Copy paths from another container
-  void set(const vector<PcodeOpNode> &path);	///< Initialize \b this to be a single path
+  void set(const std::vector<PcodeOpNode> &path);	///< Initialize \b this to be a single path
   void set(PcodeOp *op,Varnode *vn);	///< Initialize \b this container to a single node "path"
   void append(const PathMeld &op2);	///< Append a new set of paths to \b this set of paths
   void clear(void);			///< Clear \b this to be an empty container
-  void meld(vector<PcodeOpNode> &path);	///< Meld a new path into \b this container
+  void meld(std::vector<PcodeOpNode> &path);	///< Meld a new path into \b this container
   void markPaths(bool val,int4 startVarnode);			///< Mark PcodeOps paths from the given start
   int4 numCommonVarnode(void) const { return commonVn.size(); }	///< Return the number of Varnodes common to all paths
   int4 numOps(void) const { return opMeld.size(); }		///< Return the number of PcodeOps across all paths
@@ -110,9 +110,9 @@ class PathMeld {
 /// only be one execution path, although there can be multiple data-flow paths.
 class EmulateFunction : public EmulatePcodeOp {
   Funcdata *fd;				///< The function being emulated
-  map<Varnode *,uintb> varnodeMap;	///< Light-weight memory state based on Varnodes
+  std::map<Varnode *,uintb> varnodeMap;	///< Light-weight memory state based on Varnodes
   bool collectloads;			///< Set to \b true if the emulator collects individual LOAD addresses
-  vector<LoadTable> loadpoints;		///< The set of collected LOAD records
+  std::vector<LoadTable> loadpoints;		///< The set of collected LOAD records
   virtual void executeLoad(void);
   virtual void executeBranch(void);
   virtual void executeBranchind(void);
@@ -127,7 +127,7 @@ class EmulateFunction : public EmulatePcodeOp {
   virtual uintb getVarnodeValue(Varnode *vn) const;
   virtual void setVarnodeValue(Varnode *vn,uintb val);
   uintb emulatePath(uintb val,const PathMeld &pathMeld,PcodeOp *startop,Varnode *startvn);
-  void collectLoadPoints(vector<LoadTable> &res) const;	///< Recover any LOAD table descriptions
+  void collectLoadPoints(std::vector<LoadTable> &res) const;	///< Recover any LOAD table descriptions
 };
 
 class FlowInfo;
@@ -267,7 +267,7 @@ class JumpModel {
   /// \param indop is the root BRANCHIND of the switch
   /// \param addresstable will hold the list of Addresses
   /// \param loadpoints if non-null will hold LOAD table information used by the model
-  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable,vector<LoadTable> *loadpoints) const=0;
+  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable,std::vector<LoadTable> *loadpoints) const=0;
 
   /// \brief Recover the unnormalized switch variable
   ///
@@ -288,7 +288,7 @@ class JumpModel {
   /// \param addresstable is the address table (used to label code blocks with bad or missing labels)
   /// \param label will hold recovered labels in JumpValues order
   /// \param orig is the JumpModel to use for the JumpValues iterator
-  virtual void buildLabels(Funcdata *fd,vector<Address> &addresstable,vector<uintb> &label,const JumpModel *orig) const=0;
+  virtual void buildLabels(Funcdata *fd,std::vector<Address> &addresstable,std::vector<uintb> &label,const JumpModel *orig) const=0;
 
   /// \brief Do normalization of the given switch specific to \b this model.
   ///
@@ -316,7 +316,7 @@ class JumpModel {
   /// \param indop is the root BRANCHIND of the switch
   /// \param addresstable is the list of recovered Addresses, which may be modified
   /// \return \b true if there are (at least some) reasonable addresses in the table
-  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable)=0;
+  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable)=0;
 
   virtual JumpModel *clone(JumpTable *jt) const=0;	///< Clone \b this model
   virtual void clear(void) {}				///< Clear any non-permanent aspects of the model
@@ -337,12 +337,12 @@ class JumpModelTrivial : public JumpModel {
   virtual bool isOverride(void) const { return false; }
   virtual int4 getTableSize(void) const { return size; }
   virtual bool recoverModel(Funcdata *fd,PcodeOp *indop,uint4 matchsize,uint4 maxtablesize);
-  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable,vector<LoadTable> *loadpoints) const;
+  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable,std::vector<LoadTable> *loadpoints) const;
   virtual void findUnnormalized(uint4 maxaddsub,uint4 maxleftright,uint4 maxext) {}
-  virtual void buildLabels(Funcdata *fd,vector<Address> &addresstable,vector<uintb> &label,const JumpModel *orig) const;
+  virtual void buildLabels(Funcdata *fd,std::vector<Address> &addresstable,std::vector<uintb> &label,const JumpModel *orig) const;
   virtual Varnode *foldInNormalization(Funcdata *fd,PcodeOp *indop) { return (Varnode *)0; }
   virtual bool foldInGuards(Funcdata *fd,JumpTable *jump) { return false; }
-  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable) { return true; }
+  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable) { return true; }
   virtual JumpModel *clone(JumpTable *jt) const;
 };
 
@@ -356,7 +356,7 @@ class JumpBasic : public JumpModel {
 protected:
   JumpValuesRange *jrange;		///< Range of values for the (normalized) switch variable
   PathMeld pathMeld;			///< Set of PcodeOps and Varnodes producing the final target addresses
-  vector<GuardRecord> selectguards;	///< Any guards associated with \b model
+  std::vector<GuardRecord> selectguards;	///< Any guards associated with \b model
   int4 varnodeIndex;			///< Position of the normalized switch Varnode within PathMeld
   Varnode *normalvn;			///< Normalized switch Varnode
   Varnode *switchvn;			///< Unnormalized switch Varnode
@@ -391,12 +391,12 @@ class JumpBasic : public JumpModel {
   virtual bool isOverride(void) const { return false; }
   virtual int4 getTableSize(void) const { return jrange->getSize(); }
   virtual bool recoverModel(Funcdata *fd,PcodeOp *indop,uint4 matchsize,uint4 maxtablesize);
-  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable,vector<LoadTable> *loadpoints) const;
+  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable,std::vector<LoadTable> *loadpoints) const;
   virtual void findUnnormalized(uint4 maxaddsub,uint4 maxleftright,uint4 maxext);
-  virtual void buildLabels(Funcdata *fd,vector<Address> &addresstable,vector<uintb> &label,const JumpModel *orig) const;
+  virtual void buildLabels(Funcdata *fd,std::vector<Address> &addresstable,std::vector<uintb> &label,const JumpModel *orig) const;
   virtual Varnode *foldInNormalization(Funcdata *fd,PcodeOp *indop);
   virtual bool foldInGuards(Funcdata *fd,JumpTable *jump);
-  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable);
+  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable);
   virtual JumpModel *clone(JumpTable *jt) const;
   virtual void clear(void);
 };
@@ -434,9 +434,9 @@ class JumpBasic2 : public JumpBasic {
 /// The model tries to repurpose some of the analysis that JumpBasic does to recover the switch variable.
 /// But it will revert to the trivial model if it can't find a suitable switch variable.
 class JumpBasicOverride : public JumpBasic {
-  set<Address> adset;		///< Absolute address table (manually specified)
-  vector<uintb> values;		///< Normalized switch variable values associated with addresses
-  vector<Address> addrtable;	///< Address associated with each value
+  std::set<Address> adset;		///< Absolute address table (manually specified)
+  std::vector<uintb> values;		///< Normalized switch variable values associated with addresses
+  std::vector<Address> addrtable;	///< Address associated with each value
   uintb startingvalue;		///< Possible start for guessing values that match addresses
   Address normaddress;		///< Dynamic info for recovering normalized switch variable
   uint8 hash;			///< if (hash==0) there is no normalized switch (use trivial model)
@@ -448,18 +448,18 @@ class JumpBasicOverride : public JumpBasic {
   void clearCopySpecific(void);
 public:
   JumpBasicOverride(JumpTable *jt);		///< Constructor
-  void setAddresses(const vector<Address> &adtable);	///< Manually set the address table for \b this model
+  void setAddresses(const std::vector<Address> &adtable);	///< Manually set the address table for \b this model
   void setNorm(const Address &addr,uintb h) { normaddress = addr; hash = h; }	///< Set the normalized switch variable
   void setStartingValue(uintb val) { startingvalue = val; }		///< Set the starting value for the normalized range
   virtual bool isOverride(void) const { return true; }
   virtual int4 getTableSize(void) const { return addrtable.size(); }
   virtual bool recoverModel(Funcdata *fd,PcodeOp *indop,uint4 matchsize,uint4 maxtablesize);
-  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable,vector<LoadTable> *loadpoints) const;
+  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable,std::vector<LoadTable> *loadpoints) const;
   // findUnnormalized inherited from JumpBasic
-  virtual void buildLabels(Funcdata *fd,vector<Address> &addresstable,vector<uintb> &label,const JumpModel *orig) const;
+  virtual void buildLabels(Funcdata *fd,std::vector<Address> &addresstable,std::vector<uintb> &label,const JumpModel *orig) const;
   // foldInNormalization inherited from JumpBasic
   virtual bool foldInGuards(Funcdata *fd,JumpTable *jump) { return false; }
-  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable) { return true; }
+  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable) { return true; }
   virtual JumpModel *clone(JumpTable *jt) const;
   virtual void clear(void);
   virtual void encode(Encoder &encoder) const;
@@ -491,12 +491,12 @@ class JumpAssisted : public JumpModel {
   virtual bool isOverride(void) const { return false; }
   virtual int4 getTableSize(void) const { return sizeIndices+1; }
   virtual bool recoverModel(Funcdata *fd,PcodeOp *indop,uint4 matchsize,uint4 maxtablesize);
-  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable,vector<LoadTable> *loadpoints) const;
+  virtual void buildAddresses(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable,std::vector<LoadTable> *loadpoints) const;
   virtual void findUnnormalized(uint4 maxaddsub,uint4 maxleftright,uint4 maxext) {}
-  virtual void buildLabels(Funcdata *fd,vector<Address> &addresstable,vector<uintb> &label,const JumpModel *orig) const;
+  virtual void buildLabels(Funcdata *fd,std::vector<Address> &addresstable,std::vector<uintb> &label,const JumpModel *orig) const;
   virtual Varnode *foldInNormalization(Funcdata *fd,PcodeOp *indop);
   virtual bool foldInGuards(Funcdata *fd,JumpTable *jump);
-  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,vector<Address> &addresstable) { return true; }
+  virtual bool sanityCheck(Funcdata *fd,PcodeOp *indop,std::vector<Address> &addresstable) { return true; }
   virtual JumpModel *clone(JumpTable *jt) const;
   virtual void clear(void) { assistOp = (PcodeOp *)0; switchvn = (Varnode *)0; }
 };
@@ -519,10 +519,10 @@ class JumpTable {
   Architecture *glb;		///< Architecture under which this jump-table operates
   JumpModel *jmodel;		///< Current model of how the jump table is implemented in code
   JumpModel *origmodel;		///< Initial jump table model, which may be incomplete
-  vector<Address> addresstable; ///< Raw addresses in the jump-table
-  vector<IndexPair> block2addr;	///< Map from basic-blocks to address table index
-  vector<uintb> label;		///< The case label for each explicit target
-  vector<LoadTable> loadpoints;	///< Any recovered in-memory data for the jump-table
+  std::vector<Address> addresstable; ///< Raw addresses in the jump-table
+  std::vector<IndexPair> block2addr;	///< Map from basic-blocks to address table index
+  std::vector<uintb> label;		///< The case label for each explicit target
+  std::vector<LoadTable> loadpoints;	///< Any recovered in-memory data for the jump-table
   Address opaddress;		///< Absolute address of the BRANCHIND jump
   PcodeOp *indirect;		///< CPUI_BRANCHIND linked to \b this jump-table
   uintb switchVarConsume;	///< Bits of the switch variable being consumed
@@ -557,7 +557,7 @@ class JumpTable {
   void setMaxTableSize(uint4 val) { maxtablesize = val; }	///< Set the maximum entries allowed in the address table
   void setNormMax(uint4 maddsub,uint4 mleftright,uint4 mext) {
     maxaddsub = maddsub; maxleftright = mleftright; maxext = mext; }	///< Set the switch variable normalization model restrictions
-  void setOverride(const vector<Address> &addrtable,const Address &naddr,uintb h,uintb sv);
+  void setOverride(const std::vector<Address> &addrtable,const Address &naddr,uintb h,uintb sv);
   int4 numIndicesByBlock(const FlowBlock *bl) const;
   int4 getIndexByBlock(const FlowBlock *bl,int4 i) const;
   Address getAddressByIndex(int4 i) const { return addresstable[i]; }	///< Get the i-th address table entry
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.cc
index b60a349fe..81ab37960 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.cc
@@ -15,6 +15,8 @@
  */
 #include "libdecomp.hh"
 
+using namespace std;
+
 void startDecompilerLibrary(const char *sleighhome)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.hh
index e7f5ae179..1578984a6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/libdecomp.hh
@@ -28,8 +28,8 @@
 // If you have an entire ghidra distribution, you can specify its root with the -sleighhome- input,
 // otherwise you can provide a list of directories that contain '.lspec' files.
 extern void startDecompilerLibrary(const char *sleighhome);
-extern void startDecompilerLibrary(const vector<string> &extrapaths);
-extern void startDecompilerLibrary(const char *sleighhome,const vector<string> &extrapaths);
+extern void startDecompilerLibrary(const std::vector<std::string> &extrapaths);
+extern void startDecompilerLibrary(const char *sleighhome,const std::vector<std::string> &extrapaths);
 
 extern void shutdownDecompilerLibrary(void);
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
index e14109b32..bba3e9674 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.cc
@@ -15,6 +15,8 @@
  */
 #include "loadimage.hh"
 
+using namespace std;
+
 /// This is a convenience method wrapped around the core
 /// loadFill() routine.  It automatically allocates an array
 /// of the desired size, and then fills it with load image data.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.hh
index 59d4c9a5d..0cfd48715 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage.hh
@@ -27,7 +27,7 @@
 /// data cannot be met, usually because the requested address
 /// range is not in the image.
 struct DataUnavailError : public LowlevelError {
-  DataUnavailError(const string &s) : LowlevelError(s) {} ///< Instantiate with an explanatory string
+  DataUnavailError(const std::string &s) : LowlevelError(s) {} ///< Instantiate with an explanatory string
 };
 
 /// \brief A record indicating a function symbol
@@ -35,7 +35,7 @@ struct DataUnavailError : public LowlevelError {
 /// This is a lightweight object holding the Address and name of a function
 struct LoadImageFunc {
   Address address;	///< Start of function
-  string name;		///< Name of function
+  std::string name;		///< Name of function
 };
 
 /// \brief A record describing a section bytes in the executable
@@ -70,11 +70,11 @@ struct LoadImageSection {
 /// has only rudimentary support for accessing such properties.
 class LoadImage {
 protected:
-  string filename;		///< Name of the loadimage
+  std::string filename;		///< Name of the loadimage
 public:
-  LoadImage(const string &f);	///< LoadImage constructor
+  LoadImage(const std::string &f);	///< LoadImage constructor
   virtual ~LoadImage(void);	///< LoadImage destructor
-  const string &getFileName(void) const; ///< Get the name of the LoadImage
+  const std::string &getFileName(void) const; ///< Get the name of the LoadImage
   virtual void loadFill(uint1 *ptr,int4 size,const Address &addr)=0; ///< Get data from the LoadImage
   virtual void openSymbols(void) const; ///< Prepare to read symbols
   virtual void closeSymbols(void) const; ///< Stop reading symbols
@@ -83,7 +83,7 @@ class LoadImage {
   virtual void closeSectionInfo(void) const; ///< Stop reading section info
   virtual bool getNextSection(LoadImageSection &sec) const; ///< Get info on the next section
   virtual void getReadonly(RangeList &list) const; ///< Return list of \e readonly address ranges
-  virtual string getArchType(void) const=0; ///< Get a string indicating the architecture type
+  virtual std::string getArchType(void) const=0; ///< Get a string indicating the architecture type
   virtual void adjustVma(long adjust)=0; ///< Adjust load addresses with a global offset
   uint1 *load(int4 size,const Address &addr);	///< Load a chunk of image
 };
@@ -95,23 +95,23 @@ class LoadImage {
 /// of the first byte in the file.  No symbols or sections are supported
 class RawLoadImage : public LoadImage {
   uintb vma;			///< Address of first byte in the file
-  ifstream *thefile;		///< Main file stream for image
+  std::ifstream *thefile;		///< Main file stream for image
   uintb filesize;		///< Total number of bytes in the loadimage/file
   AddrSpace *spaceid;		///< Address space that the file bytes are mapped to
 public:
-  RawLoadImage(const string &f); ///< RawLoadImage constructor
+  RawLoadImage(const std::string &f); ///< RawLoadImage constructor
   void attachToSpace(AddrSpace *id) { spaceid = id; }	///< Attach the raw image to a particular space
   void open(void);					///< Open the raw file for reading
   virtual ~RawLoadImage(void);				///< RawLoadImage destructor
   virtual void loadFill(uint1 *ptr,int4 size,const Address &addr);
-  virtual string getArchType(void) const;
+  virtual std::string getArchType(void) const;
   virtual void adjustVma(long adjust);
 };
 
 /// For the base class there is no relevant initialization except
 /// the name of the image.
 /// \param f is the name of the image
-inline LoadImage::LoadImage(const string &f) {
+inline LoadImage::LoadImage(const std::string &f) {
   filename = f;
 }
 
@@ -122,7 +122,7 @@ inline LoadImage::~LoadImage(void) {
 /// The loadimage is usually associated with a file. This routine
 /// retrieves the name as a string.
 /// \return the name of the image
-inline const string &LoadImage::getFileName(void) const {
+inline const std::string &LoadImage::getFileName(void) const {
   return filename;
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
index 7e9f1ad8a..6009dde95 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.cc
@@ -16,6 +16,8 @@
  */
 #include "loadimage_bfd.hh"
 
+using namespace std;
+
 int4 LoadImageBfd::bfdinit = 0;	// Global initialization variable
 
 LoadImageBfd::LoadImageBfd(const string &f,const string &t) : LoadImage(f)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.hh
index 9d69fcca5..9905ce825 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_bfd.hh
@@ -47,8 +47,8 @@
 #endif
 
 struct ImportRecord {
-  string dllname;
-  string funcname;
+  std::string dllname;
+  std::string funcname;
   int ordinal;
   Address address;
   Address thunkaddress;
@@ -56,7 +56,7 @@ struct ImportRecord {
 
 class LoadImageBfd : public LoadImage {
   static int4 bfdinit;		// Is the library (globally) initialized
-  string target;		// File format (supported by BFD)
+  std::string target;		// File format (supported by BFD)
   bfd *thebfd;
   AddrSpace *spaceid;		// We need to map space id to segments but since
 				// we are currently ignoring segments anyway...
@@ -70,11 +70,11 @@ class LoadImageBfd : public LoadImage {
   asection *findSection(uintb offset,uintb &ssize) const; // Find section containing given offset
   void advanceToNextSymbol(void) const;
 public:
-  LoadImageBfd(const string &f,const string &t);
+  LoadImageBfd(const std::string &f,const std::string &t);
   void attachToSpace(AddrSpace *id) { spaceid = id; }
   void open(void);		// Open any descriptors
   void close(void);		// Close any descriptor
-  void getImportTable(vector<ImportRecord> &irec) { throw LowlevelError("Not implemented"); }
+  void getImportTable(std::vector<ImportRecord> &irec) { throw LowlevelError("Not implemented"); }
   virtual ~LoadImageBfd(void);
   virtual void loadFill(uint1 *ptr,int4 size,const Address &addr); // Load a chunk of image
   virtual void openSymbols(void) const;
@@ -84,7 +84,7 @@ class LoadImageBfd : public LoadImage {
   virtual void closeSectionInfo(void) const;
   virtual bool getNextSection(LoadImageSection &sec) const;
   virtual void getReadonly(RangeList &list) const;
-  virtual string getArchType(void) const;
+  virtual std::string getArchType(void) const;
   virtual void adjustVma(long adjust);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.cc
index 069a1f956..2ede5182b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "loadimage_ghidra.hh"
 
+using namespace std;
+
 LoadImageGhidra::LoadImageGhidra(ArchitectureGhidra *g)
   : LoadImage("ghidra_progam")
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.hh
index 95c56dcdf..82700069a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_ghidra.hh
@@ -35,7 +35,7 @@ class LoadImageGhidra : public LoadImage {
   void close(void);				///< Close any descriptor
   virtual void loadFill(uint1 *ptr,int4 size,const Address &addr);
   // Read only flags are all controlled through the database interface
-  virtual string getArchType(void) const;
+  virtual std::string getArchType(void) const;
   virtual void adjustVma(long adjust);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
index b7a9a30c4..0de974108 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
@@ -16,6 +16,8 @@
 #include "loadimage_xml.hh"
 #include "translate.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_ARCH = AttributeId("arch",135);
 
 ElementId ELEM_BINARYIMAGE = ElementId("binaryimage",230);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.hh
index 018cc06bb..5f0707e5b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.hh
@@ -32,15 +32,15 @@ extern ElementId ELEM_BYTECHUNK;	///< Marshaling element \<bytechunk>
 /// The data is encoded in \<bytechunk> and potentially \<symbol> files.
 class LoadImageXml : public LoadImage {
   const Element *rootel;			///< The root XML element
-  string archtype;				///< The architecture string
+  std::string archtype;				///< The architecture string
   const AddrSpaceManager *manage;		///< Manager of addresses
-  set<Address> readonlyset;			///< Starting address of read-only chunks
-  map<Address,vector<uint1> > chunk;		///< Chunks of image data, mapped by address
-  map<Address,string> addrtosymbol;		///< Symbols sorted by address
-  mutable map<Address,string>::const_iterator cursymbol;	///< Current symbol being reported
+  std::set<Address> readonlyset;			///< Starting address of read-only chunks
+  std::map<Address,std::vector<uint1> > chunk;		///< Chunks of image data, mapped by address
+  std::map<Address,std::string> addrtosymbol;		///< Symbols sorted by address
+  mutable std::map<Address,std::string>::const_iterator cursymbol;	///< Current symbol being reported
   void pad(void);			///< Make sure every chunk is followed by at least 512 bytes of pad
 public:
-  LoadImageXml(const string &f,const Element *el);	///< Constructor
+  LoadImageXml(const std::string &f,const Element *el);	///< Constructor
   void open(const AddrSpaceManager *m);		///< Read XML tags into the containers
   void clear(void);				///< Clear out all the caches
   void encode(Encoder &encoder) const;		///< Encode the image to a stream
@@ -49,7 +49,7 @@ class LoadImageXml : public LoadImage {
   virtual void openSymbols(void) const;
   virtual bool getNextSymbol(LoadImageFunc &record) const;
   virtual void getReadonly(RangeList &list) const;
-  virtual string getArchType(void) const { return archtype; }
+  virtual std::string getArchType(void) const { return archtype; }
   virtual void adjustVma(long adjust);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
index 20e51c1a9..c8f2af0ec 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
@@ -17,6 +17,7 @@
 #include "translate.hh"
 
 using namespace PackedFormat;
+using namespace std;
 
 unordered_map<string,uint4> AttributeId::lookupAttributeId;
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.hh
index c2eae63e0..7951c373c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.hh
@@ -20,8 +20,6 @@
 #include <list>
 #include <unordered_map>
 
-using namespace std;
-
 /// \brief An annotation for a data element to being transferred to/from a stream
 ///
 /// This class parallels the XML concept of an \b attribute on an element. An AttributeId describes
@@ -35,16 +33,16 @@ using namespace std;
 ///
 /// The same AttributeId can be used to label a different type of data when associated with a different ElementId.
 class AttributeId {
-  static unordered_map<string,uint4> lookupAttributeId;		///< A map of AttributeId names to their associated id
-  static vector<AttributeId *> &getList(void);			///< Retrieve the list of static AttributeId
-  string name;			///< The name of the attribute
+  static std::unordered_map<std::string,uint4> lookupAttributeId;		///< A map of AttributeId names to their associated id
+  static std::vector<AttributeId *> &getList(void);			///< Retrieve the list of static AttributeId
+  std::string name;			///< The name of the attribute
   uint4 id;			///< The (internal) id of the attribute
 public:
-  AttributeId(const string &nm,uint4 i);	///< Construct given a name and id
-  const string &getName(void) const { return name; }				///< Get the attribute's name
+  AttributeId(const std::string &nm,uint4 i);	///< Construct given a name and id
+  const std::string &getName(void) const { return name; }				///< Get the attribute's name
   uint4 getId(void) const { return id; }					///< Get the attribute's id
   bool operator==(const AttributeId &op2) const { return (id == op2.id); }	///< Test equality with another AttributeId
-  static uint4 find(const string &nm);			///< Find the id associated with a specific attribute name
+  static uint4 find(const std::string &nm);			///< Find the id associated with a specific attribute name
   static void initialize(void);				///< Populate a hashtable with all AttributeId objects
   friend bool operator==(uint4 id,const AttributeId &op2) { return (id == op2.id); }	///< Test equality of a raw integer id with an AttributeId
   friend bool operator==(const AttributeId &op1,uint4 id) { return (op1.id == id); }	///< Test equality of an AttributeId with a raw integer id
@@ -59,16 +57,16 @@ class AttributeId {
 /// AttributeId ATTRIB_CONTENT is used to label the XML element's text content, which is traditionally not labeled
 /// as an attribute.
 class ElementId {
-  static unordered_map<string,uint4> lookupElementId;	///< A map of ElementId names to their associated id
-  static vector<ElementId *> &getList(void);		///< Retrieve the list of static ElementId
-  string name;			///< The name of the element
+  static std::unordered_map<std::string,uint4> lookupElementId;	///< A map of ElementId names to their associated id
+  static std::vector<ElementId *> &getList(void);		///< Retrieve the list of static ElementId
+  std::string name;			///< The name of the element
   uint4 id;			///< The (internal) id of the attribute
 public:
-  ElementId(const string &nm,uint4 i);		///< Construct given a name and id
-  const string &getName(void) const { return name; }				///< Get the element's name
+  ElementId(const std::string &nm,uint4 i);		///< Construct given a name and id
+  const std::string &getName(void) const { return name; }				///< Get the element's name
   uint4 getId(void) const { return id; }					///< Get the element's id
   bool operator==(const ElementId &op2) const { return (id == op2.id); }	///< Test equality with another ElementId
-  static uint4 find(const string &nm);			///< Find the id associated with a specific element name
+  static uint4 find(const std::string &nm);			///< Find the id associated with a specific element name
   static void initialize(void);				///< Populate a hashtable with all ElementId objects
   friend bool operator==(uint4 id,const ElementId &op2) { return (id == op2.id); }	///< Test equality of a raw integer id with an ElementId
   friend bool operator==(const ElementId &op1,uint4 id) { return (op1.id == id); }	///< Test equality of an ElementId with a raw integer id
@@ -107,7 +105,7 @@ class Decoder {
   /// i.e. the input stream is cleared before any decoding takes place.
   /// \param s is the given input stream to be decode
   /// \return \b true if the stream was fully ingested
-  virtual void ingestStream(istream &s)=0;
+  virtual void ingestStream(std::istream &s)=0;
 
   /// \brief Peek at the next child element of the current parent, without traversing in (opening) it.
   ///
@@ -208,7 +206,7 @@ class Decoder {
   ///
   /// The last attribute, as returned by getNextAttributeId, is returned as a string.
   /// \return the string associated with the current attribute.
-  virtual string readString(void)=0;
+  virtual std::string readString(void)=0;
 
   /// \brief Find the specific attribute in the current element and return it as a string
   ///
@@ -217,7 +215,7 @@ class Decoder {
   /// Parse via getNextAttributeId is reset.
   /// \param attribId is the specific attribute id to match
   /// \return the string associated with the attribute
-  virtual string readString(const AttributeId &attribId)=0;
+  virtual std::string readString(const AttributeId &attribId)=0;
 
   /// \brief Parse the current attribute as an address space
   ///
@@ -296,7 +294,7 @@ class Encoder {
   /// The string is associated with the given AttributeId annotation and the current open element.
   /// \param attribId is the given AttributeId annotation
   /// \param val is the string to encode
-  virtual void writeString(const AttributeId &attribId,const string &val)=0;
+  virtual void writeString(const AttributeId &attribId,const std::string &val)=0;
 
   /// \brief Write an address space reference into the encoding
   ///
@@ -314,17 +312,17 @@ class Encoder {
 class XmlDecode : public Decoder {
   Document *document;				///< An ingested XML document, owned by \b this decoder
   const Element *rootElement;			///< The root XML element to be decoded
-  vector<const Element *> elStack;		///< Stack of currently \e open elements
-  vector<List::const_iterator> iterStack;	///< Index of next child for each \e open element
+  std::vector<const Element *> elStack;		///< Stack of currently \e open elements
+  std::vector<List::const_iterator> iterStack;	///< Index of next child for each \e open element
   int4 attributeIndex;				///< Position of \e current attribute to parse (in \e current element)
-  int4 findMatchingAttribute(const Element *el,const string &attribName);
+  int4 findMatchingAttribute(const Element *el,const std::string &attribName);
 public:
   XmlDecode(const AddrSpaceManager *spc,const Element *root) : Decoder(spc) {
     document = (Document *)0; rootElement = root; attributeIndex = -1; }	///< Constructor with preparsed root
   XmlDecode(const AddrSpaceManager *spc) : Decoder(spc) {
     document = (Document *)0; rootElement = (const Element *)0; attributeIndex = -1; }	///< Constructor for use with ingestStream
   virtual ~XmlDecode(void);
-  virtual void ingestStream(istream &s);
+  virtual void ingestStream(std::istream &s);
   virtual uint4 peekElement(void);
   virtual uint4 openElement(void);
   virtual uint4 openElement(const ElementId &elemId);
@@ -338,8 +336,8 @@ class XmlDecode : public Decoder {
   virtual intb readSignedInteger(const AttributeId &attribId);
   virtual uintb readUnsignedInteger(void);
   virtual uintb readUnsignedInteger(const AttributeId &attribId);
-  virtual string readString(void);
-  virtual string readString(const AttributeId &attribId);
+  virtual std::string readString(void);
+  virtual std::string readString(const AttributeId &attribId);
   virtual AddrSpace *readSpace(void);
   virtual AddrSpace *readSpace(const AttributeId &attribId);
 };
@@ -350,16 +348,16 @@ class XmlDecode : public Decoder {
 /// receive the XML document as calls are made on the encoder.
 class XmlEncode : public Encoder {
   friend class XmlDecode;
-  ostream &outStream;			///< The stream receiving the encoded data
+  std::ostream &outStream;			///< The stream receiving the encoded data
   bool elementTagIsOpen;		///< If \b true, new attributes can be written to the current element
 public:
-  XmlEncode(ostream &s) : outStream(s) { elementTagIsOpen = false; } ///< Construct from a stream
+  XmlEncode(std::ostream &s) : outStream(s) { elementTagIsOpen = false; } ///< Construct from a stream
   virtual void openElement(const ElementId &elemId);
   virtual void closeElement(const ElementId &elemId);
   virtual void writeBool(const AttributeId &attribId,bool val);
   virtual void writeSignedInteger(const AttributeId &attribId,intb val);
   virtual void writeUnsignedInteger(const AttributeId &attribId,uintb val);
-  virtual void writeString(const AttributeId &attribId,const string &val);
+  virtual void writeString(const AttributeId &attribId,const std::string &val);
   virtual void writeSpace(const AttributeId &attribId,const AddrSpace *spc);
 };
 
@@ -436,11 +434,11 @@ class PackedDecode : public Decoder {
   /// \brief An iterator into input stream
   class Position {
     friend class PackedDecode;
-    list<ByteChunk>::const_iterator seqIter;	///< Current byte sequence
+    std::list<ByteChunk>::const_iterator seqIter;	///< Current byte sequence
     uint1 *current;				///< Current position in sequence
     uint1 *end;					///< End of current sequence
   };
-  list<ByteChunk> inStream;		///< Incoming raw data as a sequence of byte arrays
+  std::list<ByteChunk> inStream;		///< Incoming raw data as a sequence of byte arrays
   Position startPos;			///< Position at the start of the current open element
   Position curPos;			///< Position of the next attribute as returned by getNextAttributeId
   Position endPos;			///< Ending position after all attributes in current open element
@@ -457,7 +455,7 @@ class PackedDecode : public Decoder {
 public:
   PackedDecode(const AddrSpaceManager *spcManager) : Decoder(spcManager) {}	///< Constructor
   virtual ~PackedDecode(void);
-  virtual void ingestStream(istream &s);
+  virtual void ingestStream(std::istream &s);
   virtual uint4 peekElement(void);
   virtual uint4 openElement(void);
   virtual uint4 openElement(const ElementId &elemId);
@@ -471,8 +469,8 @@ class PackedDecode : public Decoder {
   virtual intb readSignedInteger(const AttributeId &attribId);
   virtual uintb readUnsignedInteger(void);
   virtual uintb readUnsignedInteger(const AttributeId &attribId);
-  virtual string readString(void);
-  virtual string readString(const AttributeId &attribId);
+  virtual std::string readString(void);
+  virtual std::string readString(const AttributeId &attribId);
   virtual AddrSpace *readSpace(void);
   virtual AddrSpace *readSpace(const AttributeId &attribId);
 };
@@ -481,17 +479,17 @@ class PackedDecode : public Decoder {
 ///
 /// See PackedDecode for details of the encoding format.
 class PackedEncode : public Encoder {
-  ostream &outStream;			///< The stream receiving the encoded data
+  std::ostream &outStream;			///< The stream receiving the encoded data
   void writeHeader(uint1 header,uint4 id);	///< Write a header, element or attribute, to stream
   void writeInteger(uint1 typeByte,uint8 val);	///< Write an integer value to the stream
 public:
-  PackedEncode(ostream &s) : outStream(s) {} ///< Construct from a stream
+  PackedEncode(std::ostream &s) : outStream(s) {} ///< Construct from a stream
   virtual void openElement(const ElementId &elemId);
   virtual void closeElement(const ElementId &elemId);
   virtual void writeBool(const AttributeId &attribId,bool val);
   virtual void writeSignedInteger(const AttributeId &attribId,intb val);
   virtual void writeUnsignedInteger(const AttributeId &attribId,uintb val);
-  virtual void writeString(const AttributeId &attribId,const string &val);
+  virtual void writeString(const AttributeId &attribId,const std::string &val);
   virtual void writeSpace(const AttributeId &attribId,const AddrSpace *spc);
 };
 
@@ -503,7 +501,7 @@ inline uint1 PackedDecode::getBytePlus1(Position &pos)
 {
   uint1 *ptr = pos.current + 1;
   if (ptr == pos.end) {
-    list<ByteChunk>::const_iterator iter = pos.seqIter;
+    std::list<ByteChunk>::const_iterator iter = pos.seqIter;
     ++iter;
     if (iter == inStream.end())
       throw DecoderError("Unexpected end of stream");
@@ -573,10 +571,10 @@ extern AttributeId ATTRIB_CONTENT;	///< Special attribute for XML text content o
 /// placeholder attribute, ATTRIB_UNKNOWN, is returned as a placeholder for attributes with unrecognized names.
 /// \param nm is the name of the attribute
 /// \return the associated id
-inline uint4 AttributeId::find(const string &nm)
+inline uint4 AttributeId::find(const std::string &nm)
 
 {
-  unordered_map<string,uint4>::const_iterator iter = lookupAttributeId.find(nm);
+  std::unordered_map<std::string,uint4>::const_iterator iter = lookupAttributeId.find(nm);
   if (iter != lookupAttributeId.end())
     return (*iter).second;
   return ATTRIB_UNKNOWN.id;
@@ -586,10 +584,10 @@ inline uint4 AttributeId::find(const string &nm)
 /// placeholder element, ELEM_UNKNOWN, is returned as a placeholder for elements with unrecognized names.
 /// \param nm is the name of the element
 /// \return the associated id
-inline uint4 ElementId::find(const string &nm)
+inline uint4 ElementId::find(const std::string &nm)
 
 {
-  unordered_map<string,uint4>::const_iterator iter = lookupElementId.find(nm);
+  std::unordered_map<std::string,uint4>::const_iterator iter = lookupElementId.find(nm);
   if (iter != lookupElementId.end())
     return (*iter).second;
   return ELEM_UNKNOWN.id;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
index be9a570a0..621e2dda9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.cc
@@ -16,6 +16,8 @@
 #include "memstate.hh"
 #include "translate.hh"
 
+using namespace std;
+
 /// This is a static convenience routine for decoding a value from a sequence of bytes depending
 /// on the desired endianness
 /// \param ptr is the pointer to the bytes to decode
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.hh
index 6a260c466..273d66cab 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/memstate.hh
@@ -109,7 +109,7 @@ class MemoryImage : public MemoryBank {
 /// in which case, this memory bank behaves as if it were initially filled with zeros.
 class MemoryPageOverlay : public MemoryBank {
   MemoryBank *underlie;		///< Underlying memory object
-  map<uintb,uint1 *> page;	///< Overlayed pages
+  std::map<uintb,uint1 *> page;	///< Overlayed pages
 protected:
   virtual void insert(uintb addr,uintb val); ///< Overridden aligned word insert
   virtual uintb find(uintb addr) const;	///< Overridden aligned word find
@@ -129,8 +129,8 @@ class MemoryHashOverlay : public MemoryBank {
   MemoryBank *underlie;		///< Underlying memory bank
   int4 alignshift;		///< How many LSBs are thrown away from address when doing hash table lookup
   uintb collideskip;		///< How many slots to skip after a hashtable collision
-  vector<uintb> address;	///< The hashtable addresses
-  vector<uintb> value;		///< The hashtable values
+  std::vector<uintb> address;	///< The hashtable addresses
+  std::vector<uintb> value;		///< The hashtable values
 protected:
   virtual void insert(uintb addr,uintb val); ///< Overridden aligned word insert
   virtual uintb find(uintb addr) const;	///< Overridden aligned word find
@@ -148,7 +148,7 @@ class Translate;		// Forward declaration
 class MemoryState {
 protected:
   Translate *trans;		///< Architecture information about memory spaces
-  vector<MemoryBank *> memspace; ///< Memory banks associated with each address space
+  std::vector<MemoryBank *> memspace; ///< Memory banks associated with each address space
 public:
   MemoryState(Translate *t);	///< A constructor for MemoryState
   ~MemoryState(void) {}
@@ -157,8 +157,8 @@ class MemoryState {
   MemoryBank *getMemoryBank(AddrSpace *spc) const; ///< Get a memory bank associated with a particular space
   void setValue(AddrSpace *spc,uintb off,int4 size,uintb cval); ///< Set a value on the memory state
   uintb getValue(AddrSpace *spc,uintb off,int4 size) const; ///< Retrieve a memory value from the memory state
-  void setValue(const string &nm,uintb cval); ///< Set a value on a named register in the memory state
-  uintb getValue(const string &nm) const; ///< Retrieve a value from a named register in the memory state
+  void setValue(const std::string &nm,uintb cval); ///< Set a value on a named register in the memory state
+  uintb getValue(const std::string &nm) const; ///< Retrieve a value from a named register in the memory state
   void setValue(const VarnodeData *vn,uintb cval); ///< Set value on a given \b varnode
   uintb getValue(const VarnodeData *vn) const; ///< Get a value from a \b varnode
   void getChunk(uint1 *res,AddrSpace *spc,uintb off,int4 size) const; ///< Get a chunk of data from memory state
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
index cb41351e2..3a856760e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
@@ -16,6 +16,8 @@
 #include "merge.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 /// This instance assumes the identity of the given Varnode and the defining index is
 /// cached to facilitate quick sorting.
 /// \param v is the given Varnode
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.hh
index 18c9e0b15..df33d998f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.hh
@@ -49,7 +49,7 @@ class BlockVarnode {
   bool operator<(const BlockVarnode &op2) const { return (index < op2.index); } ///< Comparator
   Varnode *getVarnode(void) const { return vn; } ///< Get the Varnode represented by \b this
   int4 getIndex(void) const { return index; }	 ///< Get the Varnode's defining block index
-  static int4 findFront(int4 blocknum,const vector<BlockVarnode> &list);
+  static int4 findFront(int4 blocknum,const std::vector<BlockVarnode> &list);
 };
 
 class Funcdata;
@@ -79,8 +79,8 @@ class Funcdata;
 ///   - Merging Varnodes that hold the same data-type
 class Merge {
   Funcdata &data;		///< The function containing the Varnodes to be merged
-  map<HighEdge,bool> highedgemap; ///< A cache of intersection tests, sorted by HighVariable pair
-  vector<PcodeOp *> copyTrims;	///< COPY ops inserted to facilitate merges
+  std::map<HighEdge,bool> highedgemap; ///< A cache of intersection tests, sorted by HighVariable pair
+  std::vector<PcodeOp *> copyTrims;	///< COPY ops inserted to facilitate merges
   bool updateHigh(HighVariable *a); ///< Make sure given HighVariable's Cover is up-to-date
   void purgeHigh(HighVariable *high); ///< Remove cached intersection tests for a given HighVariable
   bool blockIntersection(HighVariable *a,HighVariable *b,int4 blk);
@@ -88,29 +88,29 @@ class Merge {
   static bool mergeTestAdjacent(HighVariable *high_out,HighVariable *high_in);
   static bool mergeTestSpeculative(HighVariable *high_out,HighVariable *high_in);
   static bool mergeTestBasic(Varnode *vn);
-  static void findSingleCopy(HighVariable *high,vector<Varnode *> &singlelist);
+  static void findSingleCopy(HighVariable *high,std::vector<Varnode *> &singlelist);
   static bool compareHighByBlock(const HighVariable *a,const HighVariable *b);
   static bool compareCopyByInVarnode(PcodeOp *op1,PcodeOp *op2);
   static bool shadowedVarnode(const Varnode *vn);
-  static void findAllIntoCopies(HighVariable *high,vector<PcodeOp *> &copyIns,bool filterTemps);
-  void collectCovering(vector<Varnode *> &vlist,HighVariable *high,PcodeOp *op);
-  bool collectCorrectable(const vector<Varnode *> &vlist,list<PcodeOp *> &oplist,vector<int4> &slotlist,
+  static void findAllIntoCopies(HighVariable *high,std::vector<PcodeOp *> &copyIns,bool filterTemps);
+  void collectCovering(std::vector<Varnode *> &vlist,HighVariable *high,PcodeOp *op);
+  bool collectCorrectable(const std::vector<Varnode *> &vlist,std::list<PcodeOp *> &oplist,std::vector<int4> &slotlist,
 			   PcodeOp *op);
   PcodeOp *allocateCopyTrim(Varnode *inVn,const Address &addr,PcodeOp *trimOp);
-  void snipReads(Varnode *vn,list<PcodeOp *> &markedop);
+  void snipReads(Varnode *vn,std::list<PcodeOp *> &markedop);
   void snipIndirect(PcodeOp *indop);
-  void eliminateIntersect(Varnode *vn,const vector<BlockVarnode> &blocksort);
+  void eliminateIntersect(Varnode *vn,const std::vector<BlockVarnode> &blocksort);
   void unifyAddress(VarnodeLocSet::const_iterator startiter,VarnodeLocSet::const_iterator enditer);
   void trimOpOutput(PcodeOp *op);
   void trimOpInput(PcodeOp *op,int4 slot);
   void mergeRangeMust(VarnodeLocSet::const_iterator startiter,VarnodeLocSet::const_iterator enditer);
   void mergeOp(PcodeOp *op);
   void mergeIndirect(PcodeOp *indop);
-  void mergeLinear(vector<HighVariable *> &highvec);
+  void mergeLinear(std::vector<HighVariable *> &highvec);
   bool merge(HighVariable *high1,HighVariable *high2,bool isspeculative);
   bool checkCopyPair(HighVariable *high,PcodeOp *domOp,PcodeOp *subOp);
-  void buildDominantCopy(HighVariable *high,vector<PcodeOp *> &copy,int4 pos,int4 size);
-  void markRedundantCopies(HighVariable *high,vector<PcodeOp *> &copy,int4 pos,int4 size);
+  void buildDominantCopy(HighVariable *high,std::vector<PcodeOp *> &copy,int4 pos,int4 size);
+  void markRedundantCopies(HighVariable *high,std::vector<PcodeOp *> &copy,int4 pos,int4 size);
   void processHighDominantCopy(HighVariable *high);
   void processHighRedundantCopy(HighVariable *high);
 public:
@@ -118,7 +118,7 @@ class Merge {
   bool intersection(HighVariable *a,HighVariable *b);
   bool inflateTest(Varnode *a,HighVariable *high);
   void inflate(Varnode *a,HighVariable *high);
-  bool mergeTest(HighVariable *high,vector<HighVariable *> &tmplist);
+  bool mergeTest(HighVariable *high,std::vector<HighVariable *> &tmplist);
 
   void mergeOpcode(OpCode opc);
   void mergeByDatatype(VarnodeLocSet::const_iterator startiter,VarnodeLocSet::const_iterator enditer);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
index 068393416..980300b23 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/op.cc
@@ -16,6 +16,8 @@
 #include "op.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 ElementId ELEM_IOP = ElementId("iop",113);
 ElementId ELEM_UNIMPL = ElementId("unimpl",114);
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/op.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/op.hh
index d93dcd3c1..2a1b32c8a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/op.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/op.hh
@@ -37,10 +37,10 @@ class IopSpace : public AddrSpace {
   IopSpace(AddrSpaceManager *m,const Translate *t,int4 ind);
   virtual void encodeAttributes(Encoder &encoder,uintb offset) const { encoder.writeString(ATTRIB_SPACE, "iop"); }
   virtual void encodeAttributes(Encoder &encoder,uintb offset,int4 size) const { encoder.writeString(ATTRIB_SPACE, "iop"); }
-  virtual void printRaw(ostream &s,uintb offset) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void printRaw(std::ostream &s,uintb offset) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
-  static const string NAME;			///< Reserved name for the iop space
+  static const std::string NAME;			///< Reserved name for the iop space
 };
 
 /// \brief Lowest level operation of the \b p-code language
@@ -119,11 +119,11 @@ class PcodeOp {
   mutable uint4 addlflags;	///< Additional boolean attributes for this op
   SeqNum start;	                ///< What instruction address is this attached to
   BlockBasic *parent;	        ///< Basic block in which this op is contained
-  list<PcodeOp *>::iterator basiciter;	///< Iterator within basic block
-  list<PcodeOp *>::iterator insertiter;	///< Position in alive/dead list
-  list<PcodeOp *>::iterator codeiter;	///< Position in opcode list
+  std::list<PcodeOp *>::iterator basiciter;	///< Iterator within basic block
+  std::list<PcodeOp *>::iterator insertiter;	///< Position in alive/dead list
+  std::list<PcodeOp *>::iterator codeiter;	///< Position in opcode list
   Varnode *output;		///< The one possible output Varnode of this op
-  vector<Varnode *> inrefs;	///< The ordered list of input Varnodes for this op
+  std::vector<Varnode *> inrefs;	///< The ordered list of input Varnodes for this op
 
   // Only used by Funcdata
   void setOpcode(TypeOp *t_op);	///< Set the opcode for this PcodeOp
@@ -140,7 +140,7 @@ class PcodeOp {
   void insertInput(int4 slot);	///< Make room for a new input Varnode at a specific position
   void setOrder(uintm ord) { start.setOrder(ord); } ///< Order this op within the ops for a single instruction
   void setParent(BlockBasic *p) { parent = p; }	///< Set the parent basic block of this op
-  void setBasicIter(list<PcodeOp *>::iterator iter) { basiciter = iter; } ///< Store the iterator into this op's basic block
+  void setBasicIter(std::list<PcodeOp *>::iterator iter) { basiciter = iter; } ///< Store the iterator into this op's basic block
 
 public:
   PcodeOp(int4 s,const SeqNum &sq); ///< Construct an unattached PcodeOp
@@ -155,11 +155,11 @@ class PcodeOp {
   const Address &getAddr(void) const { return start.getAddr(); } ///< Get the instruction address associated with this op
   uintm getTime(void) const { return start.getTime(); }	///< Get the time index indicating when this op was created
   const SeqNum &getSeqNum(void) const { return start; }	///< Get the sequence number associated with this op
-  list<PcodeOp *>::iterator getInsertIter(void) const { return insertiter; } ///< Get position within alive/dead list
-  list<PcodeOp *>::iterator getBasicIter(void) const { return basiciter; } ///< Get position within basic block
+  std::list<PcodeOp *>::iterator getInsertIter(void) const { return insertiter; } ///< Get position within alive/dead list
+  std::list<PcodeOp *>::iterator getBasicIter(void) const { return basiciter; } ///< Get position within basic block
   /// \brief Get the slot number of the indicated input varnode
   int4 getSlot(const Varnode *vn) const { int4 i,n; n=inrefs.size(); for(i=0;i<n;++i) if (inrefs[i]==vn) break; return i; }
-  int4 getRepeatSlot(const Varnode *vn,int4 firstSlot,list<PcodeOp *>::const_iterator iter) const;
+  int4 getRepeatSlot(const Varnode *vn,int4 firstSlot,std::list<PcodeOp *>::const_iterator iter) const;
   /// \brief Get the evaluation type of this op
   uint4 getEvalType(void) const { return (flags&(PcodeOp::unary|PcodeOp::binary|PcodeOp::special|PcodeOp::ternary)); }
   /// \brief Get type which indicates unusual halt in control-flow
@@ -229,9 +229,9 @@ class PcodeOp {
   PcodeOp *target(void) const;	///< Return starting op for instruction associated with this op
   uintb getNZMaskLocal(bool cliploop) const; ///< Calculate known zero bits for output to this op
   int4 compareOrder(const PcodeOp *bop) const; ///< Compare the control-flow order of this and \e bop
-  void printRaw(ostream &s) const { opcode->printRaw(s,this); }	///< Print raw info about this op to stream
-  const string &getOpName(void) const { return opcode->getName(); } ///< Return the name of this op
-  void printDebug(ostream &s) const; ///< Print debug description of this op to stream
+  void printRaw(std::ostream &s) const { opcode->printRaw(s,this); }	///< Print raw info about this op to stream
+  const std::string &getOpName(void) const { return opcode->getName(); } ///< Return the name of this op
+  void printDebug(std::ostream &s) const; ///< Print debug description of this op to stream
   void encode(Encoder &encoder) const; ///< Encode a description of \b this op to stream
 
   /// \brief Retrieve the PcodeOp encoded as the address \e addr
@@ -252,7 +252,7 @@ struct PcodeOpNode {
 };
 
 /// A map from sequence number (SeqNum) to PcodeOp
-typedef map<SeqNum,PcodeOp *> PcodeOpTree;
+typedef std::map<SeqNum,PcodeOp *> PcodeOpTree;
 
 /// \brief Container class for PcodeOps associated with a single function
 ///
@@ -263,13 +263,13 @@ typedef map<SeqNum,PcodeOp *> PcodeOpTree;
 /// Several lists group PcodeOps with important op-codes (like STORE and RETURN).
 class PcodeOpBank {
   PcodeOpTree optree;			///< The main sequence number sort
-  list<PcodeOp *> deadlist;		///< List of \e dead PcodeOps
-  list<PcodeOp *> alivelist;		///< List of \e alive PcodeOps
-  list<PcodeOp *> storelist;		///< List of STORE PcodeOps
-  list<PcodeOp *> loadlist;		///< list of LOAD PcodeOps
-  list<PcodeOp *> returnlist;		///< List of RETURN PcodeOps
-  list<PcodeOp *> useroplist;		///< List of user-defined PcodeOps
-  list<PcodeOp *> deadandgone;		///< List of retired PcodeOps
+  std::list<PcodeOp *> deadlist;		///< List of \e dead PcodeOps
+  std::list<PcodeOp *> alivelist;		///< List of \e alive PcodeOps
+  std::list<PcodeOp *> storelist;		///< List of STORE PcodeOps
+  std::list<PcodeOp *> loadlist;		///< list of LOAD PcodeOps
+  std::list<PcodeOp *> returnlist;		///< List of RETURN PcodeOps
+  std::list<PcodeOp *> useroplist;		///< List of user-defined PcodeOps
+  std::list<PcodeOp *> deadandgone;		///< List of retired PcodeOps
   uintm uniqid;				///< Counter for producing unique id's for each op
   void addToCodeList(PcodeOp *op);	///< Add given PcodeOp to specific op-code list
   void removeFromCodeList(PcodeOp *op);	///< Remove given PcodeOp from specific op-code list
@@ -308,22 +308,22 @@ class PcodeOpBank {
   PcodeOpTree::const_iterator end(const Address &addr) const;
 
   /// \brief Start of all PcodeOps marked as \e alive
-  list<PcodeOp *>::const_iterator beginAlive(void) const { return alivelist.begin(); }
+  std::list<PcodeOp *>::const_iterator beginAlive(void) const { return alivelist.begin(); }
 
   /// \brief End of all PcodeOps marked as \e alive
-  list<PcodeOp *>::const_iterator endAlive(void) const { return alivelist.end(); }
+  std::list<PcodeOp *>::const_iterator endAlive(void) const { return alivelist.end(); }
 
   /// \brief Start of all PcodeOps marked as \e dead
-  list<PcodeOp *>::const_iterator beginDead(void) const { return deadlist.begin(); }
+  std::list<PcodeOp *>::const_iterator beginDead(void) const { return deadlist.begin(); }
 
   /// \brief End of all PcodeOps marked as \e dead
-  list<PcodeOp *>::const_iterator endDead(void) const { return deadlist.end(); }
+  std::list<PcodeOp *>::const_iterator endDead(void) const { return deadlist.end(); }
 
   /// \brief Start of all PcodeOps sharing the given op-code
-  list<PcodeOp *>::const_iterator begin(OpCode opc) const;
+  std::list<PcodeOp *>::const_iterator begin(OpCode opc) const;
 
   /// \brief End of all PcodeOps sharing the given op-code
-  list<PcodeOp *>::const_iterator end(OpCode opc) const;
+  std::list<PcodeOp *>::const_iterator end(OpCode opc) const;
 };
 
 extern int4 functionalEqualityLevel(Varnode *vn1,Varnode *vn2,Varnode **res1,Varnode **res2);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.cc
index 3e0c39904..f3dcaed3c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.cc
@@ -16,6 +16,8 @@
 #include "opbehavior.hh"
 #include "translate.hh"
 
+using namespace std;
+
 /// This routine generates a vector of OpBehavior objects indexed by opcode
 /// \param inst is the vector of behaviors to be filled
 /// \param trans is the translator object needed by the floating point behaviors
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.hh
index 5061cb65f..ffec2e4ef 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/opbehavior.hh
@@ -26,7 +26,7 @@ class Translate;		// Forward declaration
 /// This exception is thrown when emulation evaluation of an operator fails for some reason.
 /// This can be thrown for either forward or reverse emulation
 struct EvaluationError : public LowlevelError {
-  EvaluationError(const string &s) : LowlevelError(s) {} ///< Initialize the error with an explanatory string
+  EvaluationError(const std::string &s) : LowlevelError(s) {} ///< Initialize the error with an explanatory string
 };
 
 /// \brief Class encapsulating the action/behavior of specific pcode opcodes
@@ -71,7 +71,7 @@ class OpBehavior {
   /// \brief Reverse the unary op-code operation, recovering the input value
   virtual uintb recoverInputUnary(int4 sizeout,uintb out,int4 sizein) const;
 
-  static void registerInstructions(vector<OpBehavior *> &inst,const Translate *trans); ///< Build all pcode behaviors
+  static void registerInstructions(std::vector<OpBehavior *> &inst,const Translate *trans); ///< Build all pcode behaviors
 };
 
 /// This kind of OpBehavior is associated with a particular opcode and is either unary or binary
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.cc
index d116fe62d..100236b1e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.cc
@@ -16,6 +16,8 @@
 #include "opcodes.hh"
 #include "types.h"
 
+using namespace std;
+
 /// \brief Names of operations associated with their opcode number
 ///
 /// Some of the names have been replaced with special placeholder
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.hh
index 14ec99772..45e98662e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/opcodes.hh
@@ -21,8 +21,6 @@
 
 #include <string>
 
-using namespace std;
-
 /// \brief The op-code defining a specific p-code operation (PcodeOp)
 ///
 /// These break up into categories:
@@ -128,7 +126,7 @@ enum OpCode {
 };
 
 extern const char *get_opname(OpCode opc);		///< Convert an OpCode to the name as a string
-extern OpCode get_opcode(const string &nm);		///< Convert a name string to the matching OpCode
+extern OpCode get_opcode(const std::string &nm);	///< Convert a name string to the matching OpCode
 
 extern OpCode get_booleanflip(OpCode opc,bool &reorder);	///< Get the complementary OpCode
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
index 0ee439e44..ab042112c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
@@ -18,6 +18,8 @@
 #include "flow.hh"
 #include "printc.hh"
 
+using namespace std;
+
 ElementId ELEM_ALIASBLOCK = ElementId("aliasblock",174);
 ElementId ELEM_ALLOWCONTEXTSET = ElementId("allowcontextset",175);
 ElementId ELEM_ANALYZEFORLOOPS = ElementId("analyzeforloops",176);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
index 474ee7071..a36f35d7e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
@@ -69,9 +69,9 @@ extern ElementId ELEM_WARNING;			///< Marshaling element \<warning>
 /// are run once during initialization of the Architecture object.
 class ArchOption {
 protected:
-  string name;		///< Name of the option
+  std::string name;		///< Name of the option
 public:
-  string getName(void) const { return name; }	///< Return the name of the option
+  std::string getName(void) const { return name; }	///< Return the name of the option
 
   /// \brief Apply a particular configuration option to the Architecture
   ///
@@ -84,9 +84,9 @@ class ArchOption {
   /// \param p2 is the second optional configuration string
   /// \param p3 is the third optional configuration string
   /// \return a confirmation/failure message
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const=0;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const=0;
   virtual ~ArchOption(void) {}
-  static bool onOrOff(const string &p);	///< Parse an "on" or "off" string
+  static bool onOrOff(const std::string &p);	///< Parse an "on" or "off" string
 };
 
 /// \brief A Dispatcher for possible ArchOption commands
@@ -100,12 +100,12 @@ class ArchOption {
 /// whose content is provided as the optional parameters to command.
 class OptionDatabase {
   Architecture *glb;				///< The Architecture affected by the contained ArchOption
-  map<uint4,ArchOption *> optionmap;		///< A map from option id to registered ArchOption instance
+  std::map<uint4,ArchOption *> optionmap;		///< A map from option id to registered ArchOption instance
   void registerOption(ArchOption *option);	///< Map from ArchOption name to its class instance
 public:
   OptionDatabase(Architecture *g);		///< Construct given the owning Architecture
   ~OptionDatabase(void);			///< Destructor
-  string set(uint4 nameId,const string &p1="",const string &p2="",const string &p3="");	///< Issue an option command
+  std::string set(uint4 nameId,const std::string &p1="",const std::string &p2="",const std::string &p3="");	///< Issue an option command
   void decodeOne(Decoder &decoder);		///< Parse and execute a single option element
   void decode(Decoder &decoder);		///< Execute a series of \e option \e commands parsed from a stream
 };  
@@ -113,211 +113,211 @@ class OptionDatabase {
 class OptionExtraPop : public ArchOption {
 public:
   OptionExtraPop(void) { name = "extrapop"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionReadOnly : public ArchOption {
 public:
   OptionReadOnly(void) { name = "readonly"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionDefaultPrototype : public ArchOption {
 public:
   OptionDefaultPrototype(void) { name = "defaultprototype"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionInferConstPtr : public ArchOption {
 public:
   OptionInferConstPtr(void) { name = "inferconstptr"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionForLoops : public ArchOption {
 public:
   OptionForLoops(void) { name = "analyzeforloops"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionInline : public ArchOption {
 public:
   OptionInline(void) { name = "inline"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionNoReturn : public ArchOption {
 public:
   OptionNoReturn(void) { name = "noreturn"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionStructAlign : public ArchOption {
 public:
   OptionStructAlign(void) { name = "structalign"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionWarning : public ArchOption {
 public:
   OptionWarning(void) { name = "warning"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionNullPrinting : public ArchOption {
 public:
   OptionNullPrinting(void) { name = "nullprinting"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionInPlaceOps : public ArchOption {
 public:
   OptionInPlaceOps(void) { name = "inplaceops"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionConventionPrinting : public ArchOption {
 public:
   OptionConventionPrinting(void) { name = "conventionprinting"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionNoCastPrinting : public ArchOption {
 public:
   OptionNoCastPrinting(void) { name = "nocastprinting"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionHideExtensions : public ArchOption {
 public:
   OptionHideExtensions(void) { name="hideextensions"; }		///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionMaxLineWidth : public ArchOption {
 public:
   OptionMaxLineWidth(void) { name = "maxlinewidth"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionIndentIncrement : public ArchOption {
 public:
   OptionIndentIncrement(void) { name = "indentincrement"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionCommentIndent : public ArchOption {
 public:
   OptionCommentIndent(void) { name = "commentindent"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionCommentStyle : public ArchOption {
 public:
   OptionCommentStyle(void) { name = "commentstyle"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionCommentHeader : public ArchOption {
 public:
   OptionCommentHeader(void) { name = "commentheader"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionCommentInstruction : public ArchOption {
 public:
  OptionCommentInstruction(void) { name = "commentinstruction"; }	///< Constructor
- virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+ virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionIntegerFormat : public ArchOption {
 public:
   OptionIntegerFormat(void) { name = "integerformat"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionSetAction : public ArchOption {
 public:
   OptionSetAction(void) { name = "setaction"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionCurrentAction : public ArchOption {
 public:
   OptionCurrentAction(void) { name = "currentaction"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionAllowContextSet : public ArchOption {
 public:
   OptionAllowContextSet(void) { name = "allowcontextset"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionIgnoreUnimplemented : public ArchOption {
 public:
   OptionIgnoreUnimplemented(void) { name = "ignoreunimplemented"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionErrorUnimplemented : public ArchOption {
 public:
   OptionErrorUnimplemented(void) { name = "errorunimplemented"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionErrorReinterpreted : public ArchOption {
 public:
   OptionErrorReinterpreted(void) { name = "errorreinterpreted"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionErrorTooManyInstructions : public ArchOption {
 public:
   OptionErrorTooManyInstructions(void) { name = "errortoomanyinstructions"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionProtoEval : public ArchOption {
 public:
   OptionProtoEval(void) { name = "protoeval"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionSetLanguage : public ArchOption {
 public:
   OptionSetLanguage(void) { name = "setlanguage"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionJumpLoad : public ArchOption {
 public:
   OptionJumpLoad(void) { name = "jumpload"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionToggleRule : public ArchOption {
 public:
   OptionToggleRule(void) { name = "togglerule"; } ///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionAliasBlock : public ArchOption {
 public:
   OptionAliasBlock(void) { name = "aliasblock"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionMaxInstruction : public ArchOption {
 public:
   OptionMaxInstruction(void) { name="maxinstruction"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 class OptionNamespaceStrategy : public ArchOption {
 public:
   OptionNamespaceStrategy(void) { name = "namespacestrategy"; }	///< Constructor
-  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+  virtual std::string apply(Architecture *glb,const std::string &p1,const std::string &p2,const std::string &p3) const;
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
index f64cb03ca..ca5d726c9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
@@ -16,6 +16,8 @@
 #include "override.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 ElementId ELEM_DEADCODEDELAY = ElementId("deadcodedelay",218);
 ElementId ELEM_FLOW = ElementId("flow",219);
 ElementId ELEM_FORCEGOTO = ElementId("forcegoto",220);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/override.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/override.hh
index 1a76e46e1..c4d780feb 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/override.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/override.hh
@@ -56,14 +56,14 @@ class Override {
     RETURN = 4			///< Replace primary BRANCH or CALL with a suitable RETURN operation
   };
 private:
-  map<Address,Address> forcegoto;	///< Force goto on jump at \b targetpc to \b destpc
-  vector<int4> deadcodedelay;		///< Delay count indexed by address space
-  map<Address,Address> indirectover;	///< Override indirect at \b call-point into direct to \b addr
-  map<Address,FuncProto *> protoover;	///< Override prototype at \b call-point
-  vector<Address> multistagejump;	///< Addresses of indirect jumps that need multistage recovery
-  map<Address,uint4> flowoverride;	///< Override the CALL <-> BRANCH
+  std::map<Address,Address> forcegoto;	///< Force goto on jump at \b targetpc to \b destpc
+  std::vector<int4> deadcodedelay;		///< Delay count indexed by address space
+  std::map<Address,Address> indirectover;	///< Override indirect at \b call-point into direct to \b addr
+  std::map<Address,FuncProto *> protoover;	///< Override prototype at \b call-point
+  std::vector<Address> multistagejump;	///< Addresses of indirect jumps that need multistage recovery
+  std::map<Address,uint4> flowoverride;	///< Override the CALL <-> BRANCH
   void clear(void);			///< Clear the entire set of overrides
-  static string generateDeadcodeDelayMessage(int4 index,Architecture *glb);
+  static std::string generateDeadcodeDelayMessage(int4 index,Architecture *glb);
 public:
   ~Override(void) { clear(); }		///< Destructor
   void insertForceGoto(const Address &targetpc,const Address &destpc);
@@ -81,12 +81,12 @@ class Override {
   void applyForceGoto(Funcdata &data) const;
   bool hasFlowOverride(void) const { return (!flowoverride.empty()); }	///< Are there any flow overrides
   uint4 getFlowOverride(const Address &addr) const;
-  void printRaw(ostream &s,Architecture *glb) const;
-  void generateOverrideMessages(vector<string> &messagelist,Architecture *glb) const;
+  void printRaw(std::ostream &s,Architecture *glb) const;
+  void generateOverrideMessages(std::vector<std::string> &messagelist,Architecture *glb) const;
   void encode(Encoder &encoder,Architecture *glb) const;
   void decode(Decoder &decoder,Architecture *glb);
-  static string typeToString(uint4 tp);			///< Convert a flow override type to a string
-  static uint4 stringToType(const string &nm);		///< Convert a string to a flow override type
+  static std::string typeToString(uint4 tp);			///< Convert a flow override type to a string
+  static uint4 stringToType(const std::string &nm);		///< Convert a string to a flow override type
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.cc
index 093a8b232..4ba724490 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.cc
@@ -15,6 +15,8 @@
  */
 #include "paramid.hh"
 
+using namespace std;
+
 ElementId ELEM_PARAMMEASURES = ElementId("parammeasures",106);
 ElementId ELEM_PROTO = ElementId("proto",107);
 ElementId ELEM_RANK = ElementId("rank",108);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.hh
index 7eb7d78c9..91aa7dfed 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/paramid.hh
@@ -55,25 +55,25 @@ class ParamMeasure {
   int4 numcalls;
   void walkforward( WalkState &state, PcodeOp *ignoreop, Varnode *vn );
   void walkbackward( WalkState &state, PcodeOp *ignoreop,Varnode *vn );
-  void updaterank( ParamRank rank_in,bool best ) { rank = (best==true) ? min( rank, rank_in ) : max( rank, rank_in ); }
+  void updaterank( ParamRank rank_in,bool best ) { rank = (best==true) ? std::min( rank, rank_in ) : std::max( rank, rank_in ); }
 public:
   ParamMeasure( const Address &addr, int4 sz, Datatype *dt, ParamIDIO io_in) {
     vndata.space=addr.getSpace(); vndata.offset=addr.getOffset(); vndata.size = sz; vntype=dt; io = io_in; rank=WORSTRANK; }
   void calculateRank(bool best,Varnode *basevn,PcodeOp *ignoreop);
   void encode( Encoder &encoder,ElementId &tag,bool moredetail ) const;
-  void savePretty( ostream &s,bool moredetail ) const;
+  void savePretty( std::ostream &s,bool moredetail ) const;
   int4 getMeasure(void) const { return (int4) rank; }
 };
 
 class ParamIDAnalysis
 {
   Funcdata *fd;
-  list<ParamMeasure> InputParamMeasures;
-  list<ParamMeasure> OutputParamMeasures;
+  std::list<ParamMeasure> InputParamMeasures;
+  std::list<ParamMeasure> OutputParamMeasures;
 public:
   ParamIDAnalysis( Funcdata *fd_in, bool justproto );
   void encode( Encoder &encoder, bool moredetail ) const;
-  void savePretty( ostream &s, bool moredetail ) const;
+  void savePretty( std::ostream &s, bool moredetail ) const;
 };
 
 #endif //ifndef __CPUI_PARAMID__
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/partmap.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/partmap.hh
index 41abc55a0..91851a005 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/partmap.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/partmap.hh
@@ -199,7 +199,6 @@ template<typename _linetype,typename _valuetype>
 #if 0
 
 #include <iostream>
-using namespace std;
 
 int main(int argc,char **argv)
 
@@ -212,16 +211,16 @@ int main(int argc,char **argv)
   data.split(3) = 4;
   data.split(3) = 3;
 
-  cout << data.getValue(6) << endl;
-  cout << data.getValue(8) << endl;
-  cout << data.getValue(4) << endl;
-  cout << data.getValue(1) << endl;
+  std::cout << data.getValue(6) << std::endl;
+  std::cout << data.getValue(8) << std::endl;
+  std::cout << data.getValue(4) << std::endl;
+  std::cout << data.getValue(1) << std::endl;
   
   partmap<int,unsigned int>::const_iterator iter;
 
   iter = data.begin(3);
   while(iter!=data.end()) {
-    cout << (*iter).second << endl;
+    std::cout << (*iter).second << std::endl;
     ++iter;
   }
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
index 133da8178..ce8a0f834 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.cc
@@ -15,6 +15,8 @@
  */
 #include "pcodecompile.hh"
 
+using namespace std;
+
 string Location::format(void) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.hh
index 3c7f2b26f..6b44c2af2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodecompile.hh
@@ -19,14 +19,14 @@
 #include "slghsymbol.hh"
 
 class Location {
-  string filename;
+  std::string filename;
   int4 lineno;
 public:
   Location(void) {}
-  Location(const string &fname, const int4 line) { filename = fname; lineno = line; }
-  string getFilename(void) const { return filename; }
+  Location(const std::string &fname, const int4 line) { filename = fname; lineno = line; }
+  std::string getFilename(void) const { return filename; }
   int4 getLineno(void) const { return lineno; }
-  string format(void) const;
+  std::string format(void) const;
 };
 
 struct StarQuality {
@@ -36,20 +36,20 @@ struct StarQuality {
 
 class ExprTree {		// A flattened expression tree
   friend class PcodeCompile;
-  vector<OpTpl *> *ops;	// flattened ops making up the expression
+  std::vector<OpTpl *> *ops;	// flattened ops making up the expression
   VarnodeTpl *outvn;		// Output varnode of the expression
 				// If the last op has an output, -outvn- is
 				// a COPY of that varnode
 public:
-  ExprTree(void) { ops = (vector<OpTpl *> *)0; outvn = (VarnodeTpl *)0; }
+  ExprTree(void) { ops = (std::vector<OpTpl *> *)0; outvn = (VarnodeTpl *)0; }
   ExprTree(VarnodeTpl *vn);
   ExprTree(OpTpl *op);
   ~ExprTree(void);
   void setOutput(VarnodeTpl *newout);
   VarnodeTpl *getOut(void) { return outvn; }
   const ConstTpl &getSize(void) const { return outvn->getSize(); }
-  static vector<OpTpl *> *appendParams(OpTpl *op,vector<ExprTree *> *param);
-  static vector<OpTpl *> *toVector(ExprTree *expr);
+  static std::vector<OpTpl *> *appendParams(OpTpl *op,std::vector<ExprTree *> *param);
+  static std::vector<OpTpl *> *toVector(ExprTree *expr);
 };
 
 class PcodeCompile {
@@ -65,8 +65,8 @@ class PcodeCompile {
   	  	  	  	  	  uniqspace=(AddrSpace *)0; local_labelcount=0; enforceLocalKey=false; }
   virtual ~PcodeCompile(void) {}
   virtual const Location *getLocation(SleighSymbol *sym) const=0;
-  virtual void reportError(const Location *loc, const string &msg)=0;
-  virtual void reportWarning(const Location *loc, const string &msg)=0;
+  virtual void reportError(const Location *loc, const std::string &msg)=0;
+  virtual void reportWarning(const Location *loc, const std::string &msg)=0;
   void resetLabelCount(void) { local_labelcount=0; }
   void setDefaultSpace(AddrSpace *spc) { defaultspace = spc; }
   void setConstantSpace(AddrSpace *spc) { constantspace = spc; }
@@ -75,30 +75,30 @@ class PcodeCompile {
   AddrSpace *getDefaultSpace(void) const { return defaultspace; }
   AddrSpace *getConstantSpace(void) const { return constantspace; }
   VarnodeTpl *buildTemporary(void);
-  LabelSymbol *defineLabel(string *name);
-  vector<OpTpl *> *placeLabel(LabelSymbol *sym);
-  vector<OpTpl *> *newOutput(bool usesLocalKey,ExprTree *rhs,string *varname,uint4 size=0);
-  void newLocalDefinition(string *varname,uint4 size=0);
+  LabelSymbol *defineLabel(std::string *name);
+  std::vector<OpTpl *> *placeLabel(LabelSymbol *sym);
+  std::vector<OpTpl *> *newOutput(bool usesLocalKey,ExprTree *rhs,std::string *varname,uint4 size=0);
+  void newLocalDefinition(std::string *varname,uint4 size=0);
   ExprTree *createOp(OpCode opc,ExprTree *vn);
   ExprTree *createOp(OpCode opc,ExprTree *vn1,ExprTree *vn2);
   ExprTree *createOpOut(VarnodeTpl *outvn,OpCode opc,ExprTree *vn1,ExprTree *vn2);
   ExprTree *createOpOutUnary(VarnodeTpl *outvn,OpCode opc,ExprTree *vn);
-  vector<OpTpl *> *createOpNoOut(OpCode opc,ExprTree *vn);
-  vector<OpTpl *> *createOpNoOut(OpCode opc,ExprTree *vn1,ExprTree *vn2);
-  vector<OpTpl *> *createOpConst(OpCode opc,uintb val);
+  std::vector<OpTpl *> *createOpNoOut(OpCode opc,ExprTree *vn);
+  std::vector<OpTpl *> *createOpNoOut(OpCode opc,ExprTree *vn1,ExprTree *vn2);
+  std::vector<OpTpl *> *createOpConst(OpCode opc,uintb val);
   ExprTree *createLoad(StarQuality *qual,ExprTree *ptr);
-  vector<OpTpl *> *createStore(StarQuality *qual,ExprTree *ptr,ExprTree *val);
-  ExprTree *createUserOp(UserOpSymbol *sym,vector<ExprTree *> *param);
-  vector<OpTpl *> *createUserOpNoOut(UserOpSymbol *sym,vector<ExprTree *> *param);
-  ExprTree *createVariadic(OpCode opc,vector<ExprTree *> *param);
+  std::vector<OpTpl *> *createStore(StarQuality *qual,ExprTree *ptr,ExprTree *val);
+  ExprTree *createUserOp(UserOpSymbol *sym,std::vector<ExprTree *> *param);
+  std::vector<OpTpl *> *createUserOpNoOut(UserOpSymbol *sym,std::vector<ExprTree *> *param);
+  ExprTree *createVariadic(OpCode opc,std::vector<ExprTree *> *param);
   void appendOp(OpCode opc,ExprTree *res,uintb constval,int4 constsz);
   VarnodeTpl *buildTruncatedVarnode(VarnodeTpl *basevn,uint4 bitoffset,uint4 numbits);
-  vector<OpTpl *> *assignBitRange(VarnodeTpl *vn,uint4 bitoffset,uint4 numbits,ExprTree *rhs);
+  std::vector<OpTpl *> *assignBitRange(VarnodeTpl *vn,uint4 bitoffset,uint4 numbits,ExprTree *rhs);
   ExprTree *createBitRange(SpecificSymbol *sym,uint4 bitoffset,uint4 numbits);
   VarnodeTpl *addressOf(VarnodeTpl *var,uint4 size);
-  static void force_size(VarnodeTpl *vt,const ConstTpl &size,const vector<OpTpl *> &ops);
-  static void matchSize(int4 j,OpTpl *op,bool inputonly,const vector<OpTpl *> &ops);
-  static void fillinZero(OpTpl *op,const vector<OpTpl *> &ops);
+  static void force_size(VarnodeTpl *vt,const ConstTpl &size,const std::vector<OpTpl *> &ops);
+  static void matchSize(int4 j,OpTpl *op,bool inputonly,const std::vector<OpTpl *> &ops);
+  static void fillinZero(OpTpl *op,const std::vector<OpTpl *> &ops);
   static bool propagateSize(ConstructTpl *ct);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
index 7a317f47f..d6678a5ca 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.cc
@@ -16,6 +16,8 @@
 #include "pcodeinject.hh"
 #include "architecture.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_DYNAMIC = AttributeId("dynamic",70);
 AttributeId ATTRIB_INCIDENTALCOPY = AttributeId("incidentalcopy",71);
 AttributeId ATTRIB_INJECT = AttributeId("inject",72);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
index d57215bc7..fac6c3f7d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeinject.hh
@@ -52,12 +52,12 @@ extern ElementId ELEM_SIZE_PCODE;	///< Marshaling element \<size_pcode>
 /// to the user-defined op.
 class InjectParameter {
   friend class InjectPayload;
-  string name;		///< Name of the parameter (for use in parsing p-code \e source)
+  std::string name;		///< Name of the parameter (for use in parsing p-code \e source)
   int4 index;		///< Unique index assigned (for cross referencing associated Varnode in the InjectContext)
   uint4 size;		///< Size of the parameter Varnode in bytes
 public:
-  InjectParameter(const string &nm,uint4 sz) :name(nm) { index = 0; size = sz; }	///< Constructor
-  const string &getName(void) const { return name; }	///< Get the parameter name
+  InjectParameter(const std::string &nm,uint4 sz) :name(nm) { index = 0; size = sz; }	///< Constructor
+  const std::string &getName(void) const { return name; }	///< Get the parameter name
   int4 getIndex(void) const { return index; }		///< Get the assigned index
   uint4 getSize(void) const { return size; }		///< Get the size of the parameter in bytes
 };
@@ -80,8 +80,8 @@ class InjectContext {
   Address baseaddr;			///< Address of instruction causing inject
   Address nextaddr;			///< Address of following instruction
   Address calladdr;			///< If the instruction being injected is a call, this is the address being called
-  vector<VarnodeData> inputlist;	///< Storage location for input parameters
-  vector<VarnodeData> output;		///< Storage location for output
+  std::vector<VarnodeData> inputlist;	///< Storage location for input parameters
+  std::vector<VarnodeData> output;		///< Storage location for output
   virtual ~InjectContext(void) {}	///< Destructor
   virtual void clear(void) { inputlist.clear(); output.clear(); }	///< Release resources (from last injection)
 
@@ -105,19 +105,19 @@ class InjectPayload {
     EXECUTABLEPCODE_TYPE = 4	///< Injection running as a stand-alone p-code script
   };
 protected:
-  string name;			///< Formal name of the payload
+  std::string name;			///< Formal name of the payload
   int4 type;			///< Type of this payload: CALLFIXUP_TYPE, CALLOTHERFIXUP_TYPE, etc.
   bool dynamic;			///< True if the injection is generated dynamically
   bool incidentalCopy;		///< True if injected COPYs are considered \e incidental
   int4 paramshift;		///< Number of parameters shifted in the original call
-  vector<InjectParameter> inputlist;		///< List of input parameters to this payload
-  vector<InjectParameter> output;		///< List of output parameters
-  static void decodeParameter(Decoder &decoder,string &name,uint4 &size);
+  std::vector<InjectParameter> inputlist;		///< List of input parameters to this payload
+  std::vector<InjectParameter> output;		///< List of output parameters
+  static void decodeParameter(Decoder &decoder,std::string &name,uint4 &size);
   void orderParameters(void);			///< Assign an index to parameters
   void decodePayloadAttributes(Decoder &decoder);	///< Parse the attributes of the current \<pcode> tag
   void decodePayloadParams(Decoder &decoder);		///< Parse any \<input> or \<output> children of current \<pcode> tag
 public:
-  InjectPayload(const string &nm,int4 tp) { name=nm; type=tp; paramshift=0; dynamic = false; incidentalCopy = false; }	///< Construct for use with decode
+  InjectPayload(const std::string &nm,int4 tp) { name=nm; type=tp; paramshift=0; dynamic = false; incidentalCopy = false; }	///< Construct for use with decode
   int4 getParamShift(void) const { return paramshift; }	///< Get the number of parameters shifted
   bool isDynamic(void) const { return dynamic; }	///< Return \b true if p-code in the injection is generated dynamically
   bool isIncidentalCopy(void) const { return incidentalCopy; }	///< Return \b true if any injected COPY is considered \e incidental
@@ -139,10 +139,10 @@ class InjectPayload {
   virtual void inject(InjectContext &context,PcodeEmit &emit) const=0;
 
   virtual void decode(Decoder &decoder)=0;		///< Decode \b this payload from a stream
-  virtual void printTemplate(ostream &s) const=0;	///< Print the p-code ops of the injection to a stream (for debugging)
-  string getName(void) const { return name; }		///< Return the name of the injection
+  virtual void printTemplate(std::ostream &s) const=0;	///< Print the p-code ops of the injection to a stream (for debugging)
+  std::string getName(void) const { return name; }		///< Return the name of the injection
   int4 getType(void) const { return type; }		///< Return the type of injection (CALLFIXUP_TYPE, CALLOTHERFIXUP_TYPE, etc.)
-  virtual string getSource(void) const=0;		///< Return a string describing the \e source of the injection (.cspec, prototype model, etc.)
+  virtual std::string getSource(void) const=0;		///< Return a string describing the \e source of the injection (.cspec, prototype model, etc.)
 };
 
 /// \brief A snippet of p-code that can be executed outside of normal analysis
@@ -156,18 +156,18 @@ class InjectPayload {
 /// and return a value from a single output parameter.
 class ExecutablePcode : public InjectPayload {
   Architecture *glb;			///< The Architecture owning \b this snippet
-  string source;			///< Description of the source of \b this snippet
+  std::string source;			///< Description of the source of \b this snippet
   bool built;				///< Whether build() method has run, setting up the emulator
   EmulateSnippet emulator;		///< The emulator
-  vector<uintb> inputList;		///< Temporary ids of input varnodes
-  vector<uintb> outputList;		///< Temporary ids of output varnodes
+  std::vector<uintb> inputList;		///< Temporary ids of input varnodes
+  std::vector<uintb> outputList;		///< Temporary ids of output varnodes
   PcodeEmit *emitter;			///< Emitter (allocated temporarily) for initializing the emulator
   void build(void);			///< Initialize the Emulate object with the snippet p-code
 public:
-  ExecutablePcode(Architecture *g,const string &src,const string &nm);	///< Constructor
+  ExecutablePcode(Architecture *g,const std::string &src,const std::string &nm);	///< Constructor
   virtual ~ExecutablePcode(void) { if (emitter != (PcodeEmit *)0) delete emitter; }
-  virtual string getSource(void) const { return source; }
-  uintb evaluate(const vector<uintb> &input);		///< Evaluate the snippet on the given inputs
+  virtual std::string getSource(void) const { return source; }
+  uintb evaluate(const std::vector<uintb> &input);		///< Evaluate the snippet on the given inputs
 };
 
 /// \brief A collection of p-code injection payloads
@@ -186,19 +186,19 @@ class PcodeInjectLibrary {
 protected:
   Architecture *glb;			///< The Architecture to which the injection payloads apply
   uint4 tempbase;			///< Offset within \e unique space for allocating temporaries within a payload
-  vector<InjectPayload *> injection;	///< Registered injections
-  map<string,int4> callFixupMap;	///< Map of registered call-fixup names to injection id
-  map<string,int4> callOtherFixupMap;	///< Map of registered callother-fixup names to injection id
-  map<string,int4> callMechFixupMap;	///< Map of registered mechanism names to injection id
-  map<string,int4> scriptMap;		///< Map of registered script names to ExecutablePcode id
-  vector<string> callFixupNames;	///< Map from injectid to call-fixup name
-  vector<string> callOtherTarget;	///< Map from injectid to callother-fixup target-op name
-  vector<string> callMechTarget;	///< Map from injectid to call-mech name
-  vector<string> scriptNames;		///< Map from injectid to script name
-  void registerCallFixup(const string &fixupName,int4 injectid/* , vector<string> targets */);
-  void registerCallOtherFixup(const string &fixupName,int4 injectid);
-  void registerCallMechanism(const string &fixupName,int4 injectid);
-  void registerExeScript(const string &scriptName,int4 injectid);
+  std::vector<InjectPayload *> injection;	///< Registered injections
+  std::map<std::string,int4> callFixupMap;	///< Map of registered call-fixup names to injection id
+  std::map<std::string,int4> callOtherFixupMap;	///< Map of registered callother-fixup names to injection id
+  std::map<std::string,int4> callMechFixupMap;	///< Map of registered mechanism names to injection id
+  std::map<std::string,int4> scriptMap;		///< Map of registered script names to ExecutablePcode id
+  std::vector<std::string> callFixupNames;	///< Map from injectid to call-fixup name
+  std::vector<std::string> callOtherTarget;	///< Map from injectid to callother-fixup target-op name
+  std::vector<std::string> callMechTarget;	///< Map from injectid to call-mech name
+  std::vector<std::string> scriptNames;		///< Map from injectid to script name
+  void registerCallFixup(const std::string &fixupName,int4 injectid/* , std::vector<std::string> targets */);
+  void registerCallOtherFixup(const std::string &fixupName,int4 injectid);
+  void registerCallMechanism(const std::string &fixupName,int4 injectid);
+  void registerExeScript(const std::string &scriptName,int4 injectid);
 
   /// \brief Allocate a new InjectPayload object
   ///
@@ -208,7 +208,7 @@ class PcodeInjectLibrary {
   /// \param name is the formal name of the payload
   /// \param type is the formal type (CALLFIXUP_TYPE, CALLOTHERFIXUP_TYPE, etc.) of the payload
   /// \return the id associated with the new InjectPayload object
-  virtual int4 allocateInject(const string &sourceName,const string &name,int4 type)=0;
+  virtual int4 allocateInject(const std::string &sourceName,const std::string &name,int4 type)=0;
 
   ///\brief Finalize a payload within the library, once the payload is initialized
   ///
@@ -221,12 +221,12 @@ class PcodeInjectLibrary {
   PcodeInjectLibrary(Architecture *g,uint4 tmpbase) { glb = g; tempbase = tmpbase; }	///< Constructor
   virtual ~PcodeInjectLibrary(void);				///< Destructor
   uint4 getUniqueBase(void) const { return tempbase; }		///< Get the (current) offset for building temporary registers
-  int4 getPayloadId(int4 type,const string &nm) const;		///< Map name and type to the payload id
+  int4 getPayloadId(int4 type,const std::string &nm) const;		///< Map name and type to the payload id
   InjectPayload *getPayload(int4 id) const { return injection[id]; }	///< Get the InjectPayload by id
-  string getCallFixupName(int4 injectid) const;			///< Get the call-fixup name associated with an id
-  string getCallOtherTarget(int4 injectid) const;		///< Get the callother-fixup name associated with an id
-  string getCallMechanismName(int4 injectid) const;		///< Get the call mechanism name associated with an id
-  int4 decodeInject(const string &src,const string &suffix,int4 tp,Decoder &decoder);
+  std::string getCallFixupName(int4 injectid) const;			///< Get the call-fixup name associated with an id
+  std::string getCallOtherTarget(int4 injectid) const;		///< Get the callother-fixup name associated with an id
+  std::string getCallMechanismName(int4 injectid) const;		///< Get the call mechanism name associated with an id
+  int4 decodeInject(const std::string &src,const std::string &suffix,int4 tp,Decoder &decoder);
 
   /// \brief A method for parsing p-code generated externally for use in debugging
   ///
@@ -242,7 +242,7 @@ class PcodeInjectLibrary {
   /// \param name is the formal name of the new payload
   /// \param snippetstring is the compilable snippet of p-code \e source
   /// \return the id of the new payload
-  virtual int4 manualCallFixup(const string &name,const string &snippetstring)=0;
+  virtual int4 manualCallFixup(const std::string &name,const std::string &snippetstring)=0;
 
   /// \brief Manually add a callother-fixup payload given a compilable snippet of p-code \e source
   ///
@@ -253,8 +253,8 @@ class PcodeInjectLibrary {
   /// \param inname is the ordered list of input symbol names
   /// \param snippet is the compilable snippet of p-code \e source
   /// \return the id of the new payload
-  virtual int4 manualCallOtherFixup(const string &name,const string &outname,const vector<string> &inname,
-				    const string &snippet)=0;
+  virtual int4 manualCallOtherFixup(const std::string &name,const std::string &outname,const std::vector<std::string> &inname,
+				    const std::string &snippet)=0;
 
   /// \brief Retrieve a reusable context object for \b this library
   ///
@@ -268,7 +268,7 @@ class PcodeInjectLibrary {
   /// Behaviors are pulled from the underlying architecture in order to initialize
   /// the Emulate object which services the \e p-code \e script payloads.
   /// \return the array of OpBehavior objects indexed by op-code
-  virtual const vector<OpBehavior *> &getBehaviors(void)=0;
+  virtual const std::vector<OpBehavior *> &getBehaviors(void)=0;
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
index c562c0f83..4d67e8a6e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
@@ -89,6 +89,8 @@
 
 #include "pcodeparse.hh"
 
+using namespace std;
+
   //#define YYERROR_VERBOSE
   extern int yylex(void);
   static PcodeSnippet *pcode;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.hh
index 587604237..cca442307 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.hh
@@ -49,21 +49,21 @@ class PcodeLexer {
   int4 tokpos;
   bool endofstream;
   bool endofstreamsent;
-  istream *s;
-  string curidentifier;
+  std::istream *s;
+  std::string curidentifier;
   uintb curnum;
   void starttoken(void) { curtoken[0] = curchar; tokpos = 1; }
   void advancetoken(void) { curtoken[tokpos++] = curchar; }
   bool isIdent(char c) const { return (isalnum(c)||(c=='_')||(c=='.')); }
   bool isHex(char c) const { return isxdigit(c); }
   bool isDec(char c) const { return isdigit(c); }
-  int4 findIdentifier(const string &str) const;
+  int4 findIdentifier(const std::string &str) const;
   int4 moveState(void);
 public:
-  PcodeLexer(void) { s = (istream *)0; }
-  void initialize(istream *t);
+  PcodeLexer(void) { s = (std::istream *)0; }
+  void initialize(std::istream *t);
   int4 getNextToken(void);
-  const string &getIdentifier(void) const { return curidentifier; }
+  const std::string &getIdentifier(void) const { return curidentifier; }
   uintb getNumber(void) const { return curnum; }
 };
 
@@ -73,7 +73,7 @@ class PcodeSnippet : public PcodeCompile {
   SymbolTree tree;		// Symbols in the local scope of the snippet  (temporaries)
   uint4 tempbase;
   int4 errorcount;
-  string firsterror;
+  std::string firsterror;
   ConstructTpl *result;
   virtual uint4 allocateTemp(void);
   virtual void addSymbol(SleighSymbol *sym);
@@ -83,16 +83,16 @@ class PcodeSnippet : public PcodeCompile {
   ConstructTpl *releaseResult(void) { ConstructTpl *res = result; result = (ConstructTpl *)0; return res; }
   virtual ~PcodeSnippet(void);
   virtual const Location *getLocation(SleighSymbol *sym) const { return (const Location *)0; }
-  virtual void reportError(const Location *loc, const string &msg);
-  virtual void reportWarning(const Location *loc, const string &msg) {}
+  virtual void reportError(const Location *loc, const std::string &msg);
+  virtual void reportWarning(const Location *loc, const std::string &msg) {}
   bool hasErrors(void) const { return (errorcount != 0); }
-  const string getErrorMessage(void) const { return firsterror; }
+  const std::string getErrorMessage(void) const { return firsterror; }
   void setUniqueBase(uint4 val) { tempbase = val; }
   uint4 getUniqueBase(void) const { return tempbase; }
   void clear(void);
   int lex(void);
-  bool parseStream(istream& s);
-  void addOperand(const string &name,int4 index);
+  bool parseStream(std::istream& s);
+  void addOperand(const std::string &name,int4 index);
 };
 
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
index c858fa148..46480a5ad 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
@@ -16,6 +16,8 @@
 %{
 #include "pcodeparse.hh"
 
+using namespace std;
+
   //#define YYERROR_VERBOSE
   extern int yylex(void);
   static PcodeSnippet *pcode;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.cc
index 317d4dbf1..5221185f8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.cc
@@ -16,6 +16,8 @@
 #include "pcoderaw.hh"
 #include "translate.hh"
 
+using namespace std;
+
 /// Build this VarnodeData from an \<addr>, \<register>, or \<varnode> element.
 /// \param decoder is the stream decoder
 void VarnodeData::decode(Decoder &decoder)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.hh
index fd70a956e..bab636fcc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcoderaw.hh
@@ -106,7 +106,7 @@ class PcodeOpRaw {
   OpBehavior *behave;		///< The opcode for this operation
   SeqNum seq;	                ///< Identifying address and index of this operation
   VarnodeData *out;		///< Output varnode triple
-  vector<VarnodeData *> in;	///< Raw varnode inputs to this op
+  std::vector<VarnodeData *> in;	///< Raw varnode inputs to this op
 public:
   void setBehavior(OpBehavior *be); ///< Set the opcode for this op
   OpBehavior *getBehavior(void) const; ///< Retrieve the behavior for this op
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
index 635941885..e1267e610 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
@@ -16,6 +16,8 @@
 #include "prefersplit.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 ElementId ELEM_PREFERSPLIT = ElementId("prefersplit",225);
 
 bool PreferSplitRecord::operator<(const PreferSplitRecord &op2) const
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.hh
index 9654ceedd..7e517620c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.hh
@@ -38,8 +38,8 @@ class PreferSplitManager {
     SplitInstance(Varnode *v,int4 off) { vn = v; splitoffset = off; hi = (Varnode *)0; lo = (Varnode *)0; }
   };
   Funcdata *data;
-  const vector<PreferSplitRecord> *records;
-  vector<PcodeOp *> tempsplits; // Copies of temporaries that need additional splitting
+  const std::vector<PreferSplitRecord> *records;
+  std::vector<PcodeOp *> tempsplits; // Copies of temporaries that need additional splitting
   void fillinInstance(SplitInstance *inst,bool bigendian,bool sethi,bool setlo);
   void createCopyOps(SplitInstance *ininst,SplitInstance *outinst,PcodeOp *op,bool istemp);
   bool testDefiningCopy(SplitInstance *inst,PcodeOp *def,bool &istemp);
@@ -61,9 +61,9 @@ class PreferSplitManager {
   bool testTemporary(SplitInstance *inst);
   void splitTemporary(SplitInstance *inst);
 public:
-  void init(Funcdata *fd,const vector<PreferSplitRecord> *rec);
+  void init(Funcdata *fd,const std::vector<PreferSplitRecord> *rec);
   const PreferSplitRecord *findRecord(Varnode *vn) const;
-  static void initialize(vector<PreferSplitRecord> &records);
+  static void initialize(std::vector<PreferSplitRecord> &records);
   void split(void);
   void splitAdditional(void);
 };
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
index 388708030..fa631ccf1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
@@ -16,6 +16,8 @@
 #include "prettyprint.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_BLOCKREF = AttributeId("blockref",35);
 AttributeId ATTRIB_CLOSE = AttributeId("close",36);
 AttributeId ATTRIB_COLOR = AttributeId("color",37);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.hh
index cc81dad23..046ac8b40 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.hh
@@ -92,7 +92,7 @@ extern ElementId ELEM_VARIABLE;		///< Marshaling element \<variable>
 /// For an implementation that actually does pretty printing, see EmitPrettyPrint.
 class Emit {
 public:
-  static const string EMPTY_STRING;	///< An empty string
+  static const std::string EMPTY_STRING;	///< An empty string
 protected:
   int4 indentlevel;			///< Current indent level (in fixed width characters)
   int4 parenlevel;			///< Current depth of parentheses
@@ -228,7 +228,7 @@ class Emit {
   /// \param hl indicates how the identifier should be highlighted
   /// \param vn is the Varnode representing the variable within the syntax tree
   /// \param op is a p-code operation related to the use of the variable (may be null)
-  virtual void tagVariable(const string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op)=0;
+  virtual void tagVariable(const std::string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op)=0;
 
   /// \brief Emit an operation token
   ///
@@ -237,7 +237,7 @@ class Emit {
   /// \param name is the character data for the emitted representation
   /// \param hl indicates how the token should be highlighted
   /// \param op is the PcodeOp object associated with the operation with the syntax tree
-  virtual void tagOp(const string &name,syntax_highlight hl,const PcodeOp *op)=0;
+  virtual void tagOp(const std::string &name,syntax_highlight hl,const PcodeOp *op)=0;
 
   /// \brief Emit a function identifier
   ///
@@ -247,7 +247,7 @@ class Emit {
   /// \param hl indicates how the identifier should be highlighted
   /// \param fd is the function
   /// \param op is the CALL operation associated within the syntax tree or null for a declaration
-  virtual void tagFuncName(const string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op)=0;
+  virtual void tagFuncName(const std::string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op)=0;
 
   /// \brief Emit a data-type identifier
   ///
@@ -256,7 +256,7 @@ class Emit {
   /// \param name is the character data for the identifier
   /// \param hl indicates how the identifier should be highlighted
   /// \param ct is the data-type description object
-  virtual void tagType(const string &name,syntax_highlight hl,const Datatype *ct)=0;
+  virtual void tagType(const std::string &name,syntax_highlight hl,const Datatype *ct)=0;
 
   /// \brief Emit an identifier for a field within a structured data-type
   ///
@@ -267,7 +267,7 @@ class Emit {
   /// \param ct is the data-type associated with the field
   /// \param off is the (byte) offset of the field within its structured data-type
   /// \param op is the PcodeOp associated with the field (usually PTRSUB or SUBPIECE)
-  virtual void tagField(const string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op)=0;
+  virtual void tagField(const std::string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op)=0;
 
   /// \brief Emit a comment string as part of the generated source code
   ///
@@ -278,7 +278,7 @@ class Emit {
   /// \param hl indicates how the comment should be highlighted
   /// \param spc is the address space of the address where the comment is attached
   /// \param off is the offset of the address where the comment is attached
-  virtual void tagComment(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off)=0;
+  virtual void tagComment(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off)=0;
 
   /// \brief Emit a code label identifier
   ///
@@ -288,7 +288,7 @@ class Emit {
   /// \param hl indicates how the label should be highlighted
   /// \param spc is the address space of the code address being labeled
   /// \param off is the offset of the code address being labeled
-  virtual void tagLabel(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off)=0;
+  virtual void tagLabel(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off)=0;
 
   /// \brief Emit other (more unusual) syntax as part of source code generation
   ///
@@ -296,7 +296,7 @@ class Emit {
   /// spaces, semi-colons, braces, and other punctuation.
   /// \param data is the character data of the syntax being emitted
   /// \param hl indicates how the syntax should be highlighted
-  virtual void print(const string &data,syntax_highlight hl=no_color)=0;
+  virtual void print(const std::string &data,syntax_highlight hl=no_color)=0;
 
   /// \brief Emit an open parenthesis
   ///
@@ -305,7 +305,7 @@ class Emit {
   /// \param paren is the open parenthesis character to emit
   /// \param id is an id to associate with the parenthesis
   /// \return an id associated with the parenthesis
-  virtual int4 openParen(const string &paren,int4 id=0)=0;
+  virtual int4 openParen(const std::string &paren,int4 id=0)=0;
 
   /// \brief Emit a close parenthesis
   ///
@@ -313,7 +313,7 @@ class Emit {
   /// was started by the matching open parenthesis.
   /// \param paren is the close parenthesis character to emit
   /// \param id is the id associated with the matching open parenthesis (as returned by openParen)
-  virtual void closeParen(const string &paren,int4 id)=0;
+  virtual void closeParen(const std::string &paren,int4 id)=0;
 
   /// \brief Start a group of things that are printed together
   ///
@@ -327,8 +327,8 @@ class Emit {
   /// \param id is the id associated with the group (as returned by openGroup)
   virtual void closeGroup(int4 id) {}
   virtual void clear(void) { parenlevel = 0; indentlevel=0; pendPrint=(PendPrint *)0; }	///< Reset the emitter to its initial state
-  virtual void setOutputStream(ostream *t)=0;			///< Set the output stream for the emitter
-  virtual ostream *getOutputStream(void) const=0;		///< Get the current output stream
+  virtual void setOutputStream(std::ostream *t)=0;			///< Set the output stream for the emitter
+  virtual std::ostream *getOutputStream(void) const=0;		///< Get the current output stream
   virtual void spaces(int4 num,int4 bump=0);
 
   /// \brief Start a new indent level
@@ -380,7 +380,7 @@ class Emit {
   /// If the pretty printer forces a line break in the middle of a comment, this
   /// string is emitted to provide proper syntax and indenting to continue the comment.
   /// \param fill is the set of fill characters
-  virtual void setCommentFill(const string &fill) {}
+  virtual void setCommentFill(const std::string &fill) {}
 
   /// \brief Determine if \b this is an XML markup emitter
   ///
@@ -442,10 +442,10 @@ class Emit {
 /// that does both pretty printing and markup.
 class EmitMarkup : public Emit {
 protected:
-  ostream *s;				///< Stream being emitted to
+  std::ostream *s;				///< Stream being emitted to
   Encoder *encoder;			///< How markup is encoded to the output stream
 public:
-  EmitMarkup(void) : Emit() { s = (ostream *)0; encoder = (Encoder *)0; }		///< Constructor
+  EmitMarkup(void) : Emit() { s = (std::ostream *)0; encoder = (Encoder *)0; }		///< Constructor
 
   virtual ~EmitMarkup(void);
   virtual int4 beginDocument(void);
@@ -464,18 +464,18 @@ class EmitMarkup : public Emit {
   virtual void endStatement(int4 id);
   virtual int4 beginFuncProto(void);
   virtual void endFuncProto(int4 id);
-  virtual void tagVariable(const string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op);
-  virtual void tagOp(const string &name,syntax_highlight hl,const PcodeOp *op);
-  virtual void tagFuncName(const string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op);
-  virtual void tagType(const string &name,syntax_highlight hl,const Datatype *ct);
-  virtual void tagField(const string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op);
-  virtual void tagComment(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
-  virtual void tagLabel(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
-  virtual void print(const string &data,syntax_highlight hl=no_color);
-  virtual int4 openParen(const string &paren,int4 id=0);
-  virtual void closeParen(const string &paren,int4 id);
-  virtual void setOutputStream(ostream *t);
-  virtual ostream *getOutputStream(void) const { return s; }
+  virtual void tagVariable(const std::string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op);
+  virtual void tagOp(const std::string &name,syntax_highlight hl,const PcodeOp *op);
+  virtual void tagFuncName(const std::string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op);
+  virtual void tagType(const std::string &name,syntax_highlight hl,const Datatype *ct);
+  virtual void tagField(const std::string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op);
+  virtual void tagComment(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
+  virtual void tagLabel(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
+  virtual void print(const std::string &data,syntax_highlight hl=no_color);
+  virtual int4 openParen(const std::string &paren,int4 id=0);
+  virtual void closeParen(const std::string &paren,int4 id);
+  virtual void setOutputStream(std::ostream *t);
+  virtual std::ostream *getOutputStream(void) const { return s; }
   virtual bool emitsMarkup(void) const { return true; }
 };
 
@@ -485,9 +485,9 @@ class EmitMarkup : public Emit {
 /// straight to the final output stream.  It can be used as the low-level back-end
 /// for EmitPrettyPrint.
 class EmitNoMarkup : public Emit {
-  ostream *s;				///< The stream to output tokens to
+  std::ostream *s;				///< The stream to output tokens to
 public:
-  EmitNoMarkup(void) : Emit() { s = (ostream *)0; }		///< Constructor
+  EmitNoMarkup(void) : Emit() { s = (std::ostream *)0; }		///< Constructor
   virtual int4 beginDocument(void) { return 0; }
   virtual void endDocument(int4 id) {}
   virtual int4 beginFunction(const Funcdata *fd) { return 0; }
@@ -495,9 +495,9 @@ class EmitNoMarkup : public Emit {
   virtual int4 beginBlock(const FlowBlock *bl) { return 0; }
   virtual void endBlock(int4 id) {}
   virtual void tagLine(void) {
-    *s << endl; for(int4 i=indentlevel;i>0;--i) *s << ' '; }
+    *s << std::endl; for(int4 i=indentlevel;i>0;--i) *s << ' '; }
   virtual void tagLine(int4 indent) {
-    *s << endl; for(int4 i=indent;i>0;--i) *s << ' '; }
+    *s << std::endl; for(int4 i=indent;i>0;--i) *s << ' '; }
   virtual int4 beginReturnType(const Varnode *vn) { return 0; }
   virtual void endReturnType(int4 id) {}
   virtual int4 beginVarDecl(const Symbol *sym) { return 0; }
@@ -506,28 +506,28 @@ class EmitNoMarkup : public Emit {
   virtual void endStatement(int4 id) {}
   virtual int4 beginFuncProto(void) { return 0; }
   virtual void endFuncProto(int4 id) {}
-  virtual void tagVariable(const string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op) {
+  virtual void tagVariable(const std::string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op) {
     *s << name; }
-  virtual void tagOp(const string &name,syntax_highlight hl,const PcodeOp *op) {
+  virtual void tagOp(const std::string &name,syntax_highlight hl,const PcodeOp *op) {
     *s << name; }
-  virtual void tagFuncName(const string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op) {
+  virtual void tagFuncName(const std::string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op) {
     *s << name; }
-  virtual void tagType(const string &name,syntax_highlight hl,const Datatype *ct) {
+  virtual void tagType(const std::string &name,syntax_highlight hl,const Datatype *ct) {
     *s << name; }
-  virtual void tagField(const string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op) {
+  virtual void tagField(const std::string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op) {
     *s << name; }
-  virtual void tagComment(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off) {
+  virtual void tagComment(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off) {
     *s << name; }
-  virtual void tagLabel(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off) {
+  virtual void tagLabel(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off) {
     *s << name; }
-  virtual void print(const string &data,syntax_highlight hl=no_color) {
+  virtual void print(const std::string &data,syntax_highlight hl=no_color) {
     *s << data; }
-  virtual int4 openParen(const string &paren,int4 id=0) {
+  virtual int4 openParen(const std::string &paren,int4 id=0) {
     *s << paren; parenlevel += 1; return id; }
-  virtual void closeParen(const string &paren,int4 id) {
+  virtual void closeParen(const std::string &paren,int4 id) {
     *s << paren; parenlevel -= 1; }
-  virtual void setOutputStream(ostream *t) { s = t; }
-  virtual ostream *getOutputStream(void) const { return s; }
+  virtual void setOutputStream(std::ostream *t) { s = t; }
+  virtual std::ostream *getOutputStream(void) const { return s; }
   virtual bool emitsMarkup(void) const { return false; }
 };
 
@@ -594,7 +594,7 @@ class TokenSplit {
 private:
   tag_type tagtype;		///< Type of token
   printclass delimtype;		///< The general class of the token
-  string tok;			///< Characters of token (if any)
+  std::string tok;			///< Characters of token (if any)
   EmitMarkup::syntax_highlight hl;	///< Highlighting for token
   // Additional markup elements for token
   const PcodeOp *op;		///< Pcode-op associated with \b this token
@@ -709,7 +709,7 @@ class TokenSplit {
   /// \param h indicates how the identifier should be highlighted
   /// \param v is the Varnode representing the variable within the syntax tree
   /// \param o is a p-code operation related to the use of the variable (may be null)
-  void tagVariable(const string &name,EmitMarkup::syntax_highlight h,const Varnode *v,const PcodeOp *o) {
+  void tagVariable(const std::string &name,EmitMarkup::syntax_highlight h,const Varnode *v,const PcodeOp *o) {
     tok = name; size = tok.size();
     tagtype=vari_t; delimtype=tokenstring; hl=h; ptr_second.vn=v; op=o; }
 
@@ -718,7 +718,7 @@ class TokenSplit {
   /// \param name is the character data for the emitted representation
   /// \param h indicates how the token should be highlighted
   /// \param o is the PcodeOp object associated with the operation with the syntax tree
-  void tagOp(const string &name,EmitMarkup::syntax_highlight h,const PcodeOp *o) {
+  void tagOp(const std::string &name,EmitMarkup::syntax_highlight h,const PcodeOp *o) {
     tok = name; size = tok.size();
     tagtype=op_t; delimtype=tokenstring; hl=h; op=o; }
 
@@ -728,7 +728,7 @@ class TokenSplit {
   /// \param h indicates how the identifier should be highlighted
   /// \param f is the function
   /// \param o is the CALL operation associated within the syntax tree or null for a declaration
-  void tagFuncName(const string &name,EmitMarkup::syntax_highlight h,const Funcdata *f,const PcodeOp *o) {
+  void tagFuncName(const std::string &name,EmitMarkup::syntax_highlight h,const Funcdata *f,const PcodeOp *o) {
     tok = name; size = tok.size();
     tagtype=fnam_t; delimtype=tokenstring; hl=h; ptr_second.fd=f; op=o; }
 
@@ -737,7 +737,7 @@ class TokenSplit {
   /// \param name is the character data for the identifier
   /// \param h indicates how the identifier should be highlighted
   /// \param ct is the data-type description object
-  void tagType(const string &name,EmitMarkup::syntax_highlight h,const Datatype *ct) {
+  void tagType(const std::string &name,EmitMarkup::syntax_highlight h,const Datatype *ct) {
     tok = name; size = tok.size();
     tagtype=type_t; delimtype=tokenstring; hl=h; ptr_second.ct=ct; }
 
@@ -748,7 +748,7 @@ class TokenSplit {
   /// \param ct is the data-type associated with the field
   /// \param o is the (byte) offset of the field within its structured data-type
   /// \param inOp is the PcodeOp associated with the field (usually PTRSUB or SUBPIECE)
-  void tagField(const string &name,EmitMarkup::syntax_highlight h,const Datatype *ct,int4 o,const PcodeOp *inOp) {
+  void tagField(const std::string &name,EmitMarkup::syntax_highlight h,const Datatype *ct,int4 o,const PcodeOp *inOp) {
     tok = name; size = tok.size();
     tagtype=field_t; delimtype=tokenstring; hl=h; ptr_second.ct=ct; off=(uintb)o; op=inOp; }
 
@@ -758,7 +758,7 @@ class TokenSplit {
   /// \param h indicates how the comment should be highlighted
   /// \param s is the address space of the address where the comment is attached
   /// \param o is the offset of the address where the comment is attached
-  void tagComment(const string &name,EmitMarkup::syntax_highlight h,const AddrSpace *s,uintb o) {
+  void tagComment(const std::string &name,EmitMarkup::syntax_highlight h,const AddrSpace *s,uintb o) {
     tok = name; size = tok.size(); ptr_second.spc=s; off=o;
     tagtype=comm_t; delimtype=tokenstring; hl=h; }
 
@@ -768,7 +768,7 @@ class TokenSplit {
   /// \param h indicates how the label should be highlighted
   /// \param s is the address space of the code address being labeled
   /// \param o is the offset of the code address being labeled
-  void tagLabel(const string &name,EmitMarkup::syntax_highlight h,const AddrSpace *s,uintb o) {
+  void tagLabel(const std::string &name,EmitMarkup::syntax_highlight h,const AddrSpace *s,uintb o) {
     tok = name; size = tok.size(); ptr_second.spc=s; off=o;
     tagtype=label_t; delimtype=tokenstring; hl=h; }
 
@@ -776,7 +776,7 @@ class TokenSplit {
   ///
   /// \param data is the character data of the syntax being emitted
   /// \param h indicates how the syntax should be highlighted
-  void print(const string &data,EmitMarkup::syntax_highlight h) {
+  void print(const std::string &data,EmitMarkup::syntax_highlight h) {
     tok = data; size=tok.size();
     tagtype=synt_t; delimtype=tokenstring; hl=h; }
 
@@ -784,7 +784,7 @@ class TokenSplit {
   ///
   /// \param paren is the open parenthesis character to emit
   /// \param id is an id to associate with the parenthesis
-  void openParen(const string &paren,int4 id) {
+  void openParen(const std::string &paren,int4 id) {
     tok = paren; size = 1;
     tagtype=opar_t; delimtype=tokenstring; count=id; }
 
@@ -792,7 +792,7 @@ class TokenSplit {
   ///
   /// \param paren is the close parenthesis character to emit
   /// \param id is the id associated with the matching open parenthesis (as returned by openParen)
-  void closeParen(const string &paren,int4 id) {
+  void closeParen(const std::string &paren,int4 id) {
     tok = paren; size = 1;
     tagtype=cpar_t; delimtype=tokenstring; count=id; }
 
@@ -858,7 +858,7 @@ class TokenSplit {
   tag_type getTag(void) const { return tagtype; }	///< Get \b this tag type
 #ifdef PRETTY_DEBUG
   int4 getCount(void) const { return count; }		///< Get the delimiter id
-  void printDebug(ostream &s) const;			///< Print \b this token to stream for debugging
+  void printDebug(std::ostream &s) const;			///< Print \b this token to stream for debugging
 #endif
 };
 
@@ -968,17 +968,17 @@ void circularqueue<_type>::expand(int4 amount)
 /// stream and may add markup.
 class EmitPrettyPrint : public Emit {
 #ifdef PRETTY_DEBUG
-  vector<int4> checkid;
+  std::vector<int4> checkid;
 #endif
   Emit *lowlevel;		///< The low-level emitter
-  vector<int4> indentstack;	///< Space available for currently active nesting levels
+  std::vector<int4> indentstack;	///< Space available for currently active nesting levels
   int4 spaceremain;		///< Space remaining in current line
   int4 maxlinesize;		///< Maximum number of characters allowed in a line
   int4 leftotal;		///< # of characters committed from the current line
   int4 rightotal;		///< # of characters yet to be committed from the current line
   bool needbreak;   		///< \b true if break needed before next token
   bool commentmode;		///< \b true if in the middle of a comment
-  string commentfill;		///< Used to fill comments if line breaks are forced
+  std::string commentfill;		///< Used to fill comments if line breaks are forced
   circularqueue<int4> scanqueue; ///< References to current \e open and \e whitespace tokens
   circularqueue<TokenSplit> tokqueue;	///< The full stream of tokens
   void expand(void);		///< Expand the stream buffer
@@ -1010,21 +1010,21 @@ class EmitPrettyPrint : public Emit {
   virtual void endStatement(int4 id);
   virtual int4 beginFuncProto(void);
   virtual void endFuncProto(int4 id);
-  virtual void tagVariable(const string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op);
-  virtual void tagOp(const string &name,syntax_highlight hl,const PcodeOp *op);
-  virtual void tagFuncName(const string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op);
-  virtual void tagType(const string &name,syntax_highlight hl,const Datatype *ct);
-  virtual void tagField(const string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op);
-  virtual void tagComment(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
-  virtual void tagLabel(const string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
-  virtual void print(const string &data,syntax_highlight hl=no_color);
-  virtual int4 openParen(const string &paren,int4 id=0);
-  virtual void closeParen(const string &paren,int4 id);
+  virtual void tagVariable(const std::string &name,syntax_highlight hl,const Varnode *vn,const PcodeOp *op);
+  virtual void tagOp(const std::string &name,syntax_highlight hl,const PcodeOp *op);
+  virtual void tagFuncName(const std::string &name,syntax_highlight hl,const Funcdata *fd,const PcodeOp *op);
+  virtual void tagType(const std::string &name,syntax_highlight hl,const Datatype *ct);
+  virtual void tagField(const std::string &name,syntax_highlight hl,const Datatype *ct,int4 off,const PcodeOp *op);
+  virtual void tagComment(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
+  virtual void tagLabel(const std::string &name,syntax_highlight hl,const AddrSpace *spc,uintb off);
+  virtual void print(const std::string &data,syntax_highlight hl=no_color);
+  virtual int4 openParen(const std::string &paren,int4 id=0);
+  virtual void closeParen(const std::string &paren,int4 id);
   virtual int4 openGroup(void);
   virtual void closeGroup(int4 id);
   virtual void clear(void);
-  virtual void setOutputStream(ostream *t) { lowlevel->setOutputStream(t); }
-  virtual ostream *getOutputStream(void) const { return lowlevel->getOutputStream(); }
+  virtual void setOutputStream(std::ostream *t) { lowlevel->setOutputStream(t); }
+  virtual std::ostream *getOutputStream(void) const { return lowlevel->getOutputStream(); }
   virtual void spaces(int4 num,int4 bump=0);
   virtual int4 startIndent(void);
   virtual void stopIndent(int4 id);
@@ -1033,7 +1033,7 @@ class EmitPrettyPrint : public Emit {
   virtual void flush(void);
   virtual void setMaxLineSize(int4 val);
   virtual int4 getMaxLineSize(void) const { return maxlinesize; }
-  virtual void setCommentFill(const string &fill) { commentfill = fill; }
+  virtual void setCommentFill(const std::string &fill) { commentfill = fill; }
   virtual bool emitsMarkup(void) const { return lowlevel->emitsMarkup(); }
   virtual void resetDefaults(void);
   void setMarkup(bool val);	///< Toggle whether the low-level emitter emits markup or not
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
index 5c90024a2..bd433b898 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
@@ -16,6 +16,8 @@
 #include "printc.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 // Operator tokens for expressions
 //                        token #in prec assoc   optype       space bump
 OpToken PrintC::hidden = { "", "", 1, 70, false, OpToken::hiddenfunction, 0, 0, (OpToken *)0 };
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
index 6c7d79988..186c79f86 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.hh
@@ -46,7 +46,7 @@ struct PartialSymbolEntry {
   const OpToken *token;		///< Operator used to drill-down to the field
   const TypeField *field;	///< The component object describing the field
   const Datatype *parent;	///< The parent data-type owning the field
-  string fieldname;		///< The name of the field
+  std::string fieldname;		///< The name of the field
   EmitMarkup::syntax_highlight hilite;	///< Highlight information for the field token
 };
 
@@ -114,31 +114,31 @@ class PrintC : public PrintLanguage {
   static OpToken array_expr;		///< Array adornment for a type declaration
   static OpToken enum_cat;		///< The \e concatenation operator for enumerated values
 public:
-  static const string EMPTY_STRING;	///< An empty token
-  static const string OPEN_CURLY;	///< "{" token
-  static const string CLOSE_CURLY;	///< "}" token
-  static const string SEMICOLON;	///< ";" token
-  static const string COLON;		///< ":" token
-  static const string EQUALSIGN;	///< "=" token
-  static const string COMMA;		///< "," token
-  static const string DOTDOTDOT;	///< "..." token
-  static const string KEYWORD_VOID;	///< "void" keyword
-  static const string KEYWORD_TRUE;	///< "true" keyword
-  static const string KEYWORD_FALSE;	///< "false" keyword
-  static const string KEYWORD_IF;	///< "if" keyword
-  static const string KEYWORD_ELSE;	///< "else" keyword
-  static const string KEYWORD_DO;	///< "do" keyword
-  static const string KEYWORD_WHILE;	///< "while" keyword
-  static const string KEYWORD_FOR;	///< "for" keyword
-  static const string KEYWORD_GOTO;	///< "goto" keyword
-  static const string KEYWORD_BREAK;	///< "break" keyword
-  static const string KEYWORD_CONTINUE;	///< "continue" keyword
-  static const string KEYWORD_CASE;	///< "case" keyword
-  static const string KEYWORD_SWITCH;	///< "switch" keyword
-  static const string KEYWORD_DEFAULT;	///< "default" keyword
-  static const string KEYWORD_RETURN;	///< "return" keyword
-  static const string KEYWORD_NEW;	///< "new" keyword
-  static const string typePointerRelToken;	///< The token to print indicating PTRSUB relative to a TypePointerRel
+  static const std::string EMPTY_STRING;	///< An empty token
+  static const std::string OPEN_CURLY;	///< "{" token
+  static const std::string CLOSE_CURLY;	///< "}" token
+  static const std::string SEMICOLON;	///< ";" token
+  static const std::string COLON;		///< ":" token
+  static const std::string EQUALSIGN;	///< "=" token
+  static const std::string COMMA;		///< "," token
+  static const std::string DOTDOTDOT;	///< "..." token
+  static const std::string KEYWORD_VOID;	///< "void" keyword
+  static const std::string KEYWORD_TRUE;	///< "true" keyword
+  static const std::string KEYWORD_FALSE;	///< "false" keyword
+  static const std::string KEYWORD_IF;	///< "if" keyword
+  static const std::string KEYWORD_ELSE;	///< "else" keyword
+  static const std::string KEYWORD_DO;	///< "do" keyword
+  static const std::string KEYWORD_WHILE;	///< "while" keyword
+  static const std::string KEYWORD_FOR;	///< "for" keyword
+  static const std::string KEYWORD_GOTO;	///< "goto" keyword
+  static const std::string KEYWORD_BREAK;	///< "break" keyword
+  static const std::string KEYWORD_CONTINUE;	///< "continue" keyword
+  static const std::string KEYWORD_CASE;	///< "case" keyword
+  static const std::string KEYWORD_SWITCH;	///< "switch" keyword
+  static const std::string KEYWORD_DEFAULT;	///< "default" keyword
+  static const std::string KEYWORD_RETURN;	///< "return" keyword
+  static const std::string KEYWORD_NEW;	///< "new" keyword
+  static const std::string typePointerRelToken;	///< The token to print indicating PTRSUB relative to a TypePointerRel
 protected:
   bool option_NULL;		///< Set to \b true if we should emit NULL keyword
   bool option_inplace_ops;	///< Set to \b true if we should use '+=' '&=' etc.
@@ -146,12 +146,12 @@ class PrintC : public PrintLanguage {
   bool option_nocasts;		///< Don't print a cast if \b true
   bool option_unplaced;		///< Set to \b true if we should display unplaced comments
   bool option_hide_exts;	///< Set to \b true if we should hide implied extension operations
-  string nullToken;		///< Token to use for 'null'
-  string sizeSuffix;		///< Characters to print to indicate a \e long integer token
+  std::string nullToken;		///< Token to use for 'null'
+  std::string sizeSuffix;		///< Characters to print to indicate a \e long integer token
   CommentSorter commsorter;	///< Container/organizer for comments in the current function
 
   // Routines that are specific to C/C++
-  void buildTypeStack(const Datatype *ct,vector<const Datatype *> &typestack);	///< Prepare to push components of a data-type declaration
+  void buildTypeStack(const Datatype *ct,std::vector<const Datatype *> &typestack);	///< Prepare to push components of a data-type declaration
   void pushPrototypeInputs(const FuncProto *proto);				///< Push input parameters
   void pushSymbolScope(const Symbol *symbol);			///< Push tokens resolving a symbol's scope
   void emitSymbolScope(const Symbol *symbol);			///< Emit tokens resolving a symbol's scope
@@ -190,8 +190,8 @@ class PrintC : public PrintLanguage {
   void opFunc(const PcodeOp *op);			///< Push a \e functional expression based on the given p-code op to the RPN stack
   void opTypeCast(const PcodeOp *op);			///< Push the given p-code op using type-cast syntax to the RPN stack
   void opHiddenFunc(const PcodeOp *op);			///< Push the given p-code op as a hidden token
-  static void printCharHexEscape(ostream &s,int4 val);	///< Print value as an escaped hex sequence
-  bool printCharacterConstant(ostream &s,const Address &addr,Datatype *charType) const;
+  static void printCharHexEscape(std::ostream &s,int4 val);	///< Print value as an escaped hex sequence
+  bool printCharacterConstant(std::ostream &s,const Address &addr,Datatype *charType) const;
   int4 getHiddenThisSlot(const PcodeOp *op,FuncProto *fc);	///< Get position of "this" pointer needing to be hidden
   void resetDefaultsPrintC(void);			///< Set default values for options specific to PrintC
   virtual void pushConstant(uintb val,const Datatype *ct,
@@ -212,10 +212,10 @@ class PrintC : public PrintLanguage {
 			    const PcodeOp *op);
   virtual void push_float(uintb val,int4 sz,const Varnode *vn,
 			  const PcodeOp *op);
-  virtual void printUnicode(ostream &s,int4 onechar) const;
+  virtual void printUnicode(std::ostream &s,int4 onechar) const;
   virtual void pushType(const Datatype *ct);
-  virtual string genericFunctionName(const Address &addr);
-  virtual string genericTypeName(const Datatype *ct);
+  virtual std::string genericFunctionName(const Address &addr);
+  virtual std::string genericTypeName(const Datatype *ct);
 
   virtual void emitExpression(const PcodeOp *op);
   virtual void emitVarDecl(const Symbol *sym);
@@ -226,7 +226,7 @@ class PrintC : public PrintLanguage {
   virtual bool checkPrintNegation(const Varnode *vn);
   void pushTypePointerRel(const PcodeOp *op);
 public:
-  PrintC(Architecture *g,const string &nm="c-language");	///< Constructor
+  PrintC(Architecture *g,const std::string &nm="c-language");	///< Constructor
   void setNULLPrinting(bool val) { option_NULL = val; }		///< Toggle the printing of a 'NULL' token
   void setInplaceOps(bool val) { option_inplace_ops = val; }	///< Toggle the printing of \e in-place operators
   void setConvention(bool val) { option_convention = val; }	///< Toggle whether calling conventions are printed
@@ -239,7 +239,7 @@ class PrintC : public PrintLanguage {
   virtual void resetDefaults(void);
   virtual void initializeFromArchitecture(void);
   virtual void adjustTypeOperators(void);
-  virtual void setCommentStyle(const string &nm);
+  virtual void setCommentStyle(const std::string &nm);
   virtual void docTypeDefinitions(const TypeFactory *typegrp);
   virtual void docAllGlobals(void);
   virtual void docSingleGlobal(const Symbol *sym);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
index 473bab08a..a193e8688 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.cc
@@ -16,6 +16,8 @@
 #include "printjava.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 OpToken PrintJava::instanceof = { "instanceof", "", 2, 60, true, OpToken::binary, 1, 0, (OpToken *)0 };
 
 // Constructing this registers the capability
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.hh
index f3f200d11..d95adf12a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printjava.hh
@@ -57,9 +57,9 @@ class PrintJava : public PrintC {
   static bool isArrayType(const Datatype *ct);		///< Does the given data-type reference a java array
   static bool needZeroArray(const Varnode *vn);		///< Do we need '[0]' syntax.
   void resetDefaultsPrintJava(void);			///< Set options that are specific to Java
-  virtual void printUnicode(ostream &s,int4 onechar) const;
+  virtual void printUnicode(std::ostream &s,int4 onechar) const;
 public:
-  PrintJava(Architecture *g,const string &nm="java-language");	///< Constructor
+  PrintJava(Architecture *g,const std::string &nm="java-language");	///< Constructor
   virtual void resetDefaults(void);
   virtual void docFunction(const Funcdata *fd);
   virtual void pushTypeStart(const Datatype *ct,bool noident);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
index f43d3e6f3..8f7a3c03b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
@@ -17,6 +17,8 @@
 #include "printlanguage.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 const string PrintLanguage::OPEN_PAREN = "(";
 const string PrintLanguage::CLOSE_PAREN = ")";
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
index ea7a1efa5..71178da2d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
@@ -38,12 +38,12 @@ class ResolvedUnion;
 /// which must be derived from PrintLanguage.  The factory method for the capability to override
 /// is buildLanguage().
 class PrintLanguageCapability : public CapabilityPoint {
-  static vector<PrintLanguageCapability *> thelist;	///< The static array of registered high-level languages
+  static std::vector<PrintLanguageCapability *> thelist;	///< The static array of registered high-level languages
 protected:
-  string name;			///< Unique identifier for language capability
+  std::string name;			///< Unique identifier for language capability
   bool isdefault;		///< Set to \b true to treat \b this as the default language
 public:
-  const string &getName(void) const { return name; }	///< Get the high-level language name
+  const std::string &getName(void) const { return name; }	///< Get the high-level language name
   virtual void initialize(void);
 
   /// \brief Build the main PrintLanguage object corresponding to \b this capability
@@ -54,7 +54,7 @@ class PrintLanguageCapability : public CapabilityPoint {
   virtual PrintLanguage *buildLanguage(Architecture *glb)=0;
 
   static PrintLanguageCapability *getDefault(void);	///< Retrieve the default language capability
-  static PrintLanguageCapability *findCapability(const string &name);	///< Find a language capability by name
+  static PrintLanguageCapability *findCapability(const std::string &name);	///< Find a language capability by name
 };
 
 class BlockGraph;
@@ -90,8 +90,8 @@ class OpToken {
     space,			///< No explicitly printed token
     hiddenfunction		///< Operation that isn't explicitly printed
   };
-  string print1;		///< Printing characters for the token
-  string print2;		///< (terminating) characters for the token
+  std::string print1;		///< Printing characters for the token
+  std::string print2;		///< (terminating) characters for the token
   int4 stage;			///< Additional elements consumed from the RPN stack when emitting this token
   int4 precedence;		///< Precedence level of this token (higher binds more tightly)
   bool associative;		///< True if the operator is associative
@@ -135,8 +135,8 @@ class OpToken {
 /// stack to provide a printing context mechanism for derived classes.
 class PrintLanguage {
 public:
-  static const string OPEN_PAREN;	///< "(" token
-  static const string CLOSE_PAREN;	///< ")" token
+  static const std::string OPEN_PAREN;	///< "(" token
+  static const std::string CLOSE_PAREN;	///< ")" token
 
   /// \brief Possible context sensitive modifiers to how tokens get emitted
   enum modifiers {
@@ -205,7 +205,7 @@ class PrintLanguage {
   /// The term \e variable has a broader meaning than just a Varnode. An Atom can also be a data-type
   /// name, a function name, or a structure field etc.
   struct Atom {
-    const string &name;		///< The actual printed characters of the token
+    const std::string &name;		///< The actual printed characters of the token
     tagtype type;		///< The type of Atom
     EmitMarkup::syntax_highlight highlight;	///< The type of highlighting to use when emitting the token
     const PcodeOp *op;		///< A p-code operation associated with the token
@@ -217,39 +217,39 @@ class PrintLanguage {
     int4 offset;        	///< The offset (within the parent structure) for a \e field token
 
     /// \brief Construct a token with no associated data-flow annotations
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl)
       : name(nm) { type = t; highlight = hl; }
 
     /// \brief Construct a token for a data-type name
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const Datatype *c)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const Datatype *c)
       : name(nm) { type = t; highlight = hl; ptr_second.ct = c; }
 
     /// \brief Construct a token for a field name
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const Datatype *c,int4 off,const PcodeOp *o)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const Datatype *c,int4 off,const PcodeOp *o)
       : name(nm) { type = t; highlight = hl; ptr_second.ct = c; offset = off; op = o; }
 
     /// \brief Construct a token with an associated PcodeOp
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o)
       : name(nm) { type = t; highlight = hl; op = o; }
 
     /// \brief Construct a token with an associated PcodeOp and Varnode
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o,const Varnode *v)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o,const Varnode *v)
       : name(nm) { type=t; highlight = hl; ptr_second.vn = v; op = o; }
 
     /// \brief Construct a token for a function name
-    Atom(const string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o,const Funcdata *f)
+    Atom(const std::string &nm,tagtype t,EmitMarkup::syntax_highlight hl,const PcodeOp *o,const Funcdata *f)
       : name(nm) { type=t; highlight = hl; op = o; ptr_second.fd = f; }
   };
 private:
-  string name;				///< The name of the high-level language
-  vector<uint4> modstack;		///< Printing modification stack
-  vector<const Scope *> scopestack;	///< The symbol scope stack
-  vector<ReversePolish> revpol;		///< The Reverse Polish Notation (RPN) token stack
-  vector<NodePending> nodepend;		///< Data-flow nodes waiting to be pushed onto the RPN stack
+  std::string name;				///< The name of the high-level language
+  std::vector<uint4> modstack;		///< Printing modification stack
+  std::vector<const Scope *> scopestack;	///< The symbol scope stack
+  std::vector<ReversePolish> revpol;		///< The Reverse Polish Notation (RPN) token stack
+  std::vector<NodePending> nodepend;		///< Data-flow nodes waiting to be pushed onto the RPN stack
   int4 pending;				///< Number of data-flow nodes waiting to be pushed
   int4 line_commentindent;		///< Number of characters a comment line should be indented
-  string commentstart;			///< Delimiter characters for the start of a comment
-  string commentend;			///< Delimiter characters (if any) for the end of a comment
+  std::string commentstart;			///< Delimiter characters for the start of a comment
+  std::string commentend;			///< Delimiter characters (if any) for the end of a comment
 protected:
   Architecture *glb;			///< The Architecture owning the language emitter
   const Scope *curscope;		///< The current symbol scope
@@ -281,7 +281,7 @@ class PrintLanguage {
   void emitOp(const ReversePolish &entry);				///< Send an operator token from the RPN to the emitter
   void emitAtom(const Atom &atom);					///< Send an variable token from the RPN to the emitter
   static bool unicodeNeedsEscape(int4 codepoint);			///< Determine if the given codepoint needs to be escaped
-  bool escapeCharacterData(ostream &s,const uint1 *buf,int4 count,int4 charsize,bool bigend) const;
+  bool escapeCharacterData(std::ostream &s,const uint1 *buf,int4 count,int4 charsize,bool bigend) const;
   void recurse(void);							///< Emit from the RPN stack as much as possible
   void opBinary(const OpToken *tok,const PcodeOp *op);			///< Push a binary operator onto the RPN stack
   void opUnary(const OpToken *tok,const PcodeOp *op);			///< Push a unary operator onto the RPN stack
@@ -293,7 +293,7 @@ class PrintLanguage {
   /// For most languages, this prints the character surrounded by single quotes.
   /// \param s is the output stream
   /// \param onechar is the unicode code point of the character to print
-  virtual void printUnicode(ostream &s,int4 onechar) const=0;
+  virtual void printUnicode(std::ostream &s,int4 onechar) const=0;
 
   /// \brief Push a data-type name onto the RPN expression stack.
   ///
@@ -419,16 +419,16 @@ class PrintLanguage {
   /// \return \b true if the value can be easily inverted
   virtual bool checkPrintNegation(const Varnode *vn)=0;
 public:
-  PrintLanguage(Architecture *g,const string &nm);			///< Constructor
+  PrintLanguage(Architecture *g,const std::string &nm);			///< Constructor
   virtual ~PrintLanguage(void);						///< Destructor
-  const string &getName(void) const { return name; }			///< Get the language name
+  const std::string &getName(void) const { return name; }			///< Get the language name
   CastStrategy *getCastStrategy(void) const { return castStrategy; }	///< Get the casting strategy for the language
-  ostream *getOutputStream(void) const { return emit->getOutputStream(); }	///< Get the output stream being emitted to
-  void setOutputStream(ostream *t) { emit->setOutputStream(t); }	///< Set the output stream to emit to
+  std::ostream *getOutputStream(void) const { return emit->getOutputStream(); }	///< Get the output stream being emitted to
+  void setOutputStream(std::ostream *t) { emit->setOutputStream(t); }	///< Set the output stream to emit to
   void setMaxLineSize(int4 mls) { emit->setMaxLineSize(mls); }		///< Set the maximum number of characters per line
   void setIndentIncrement(int4 inc) { emit->setIndentIncrement(inc); }	///< Set the number of characters to indent per level of code nesting
   void setLineCommentIndent(int4 val);					///< Set the number of characters to indent comment lines
-  void setCommentDelimeter(const string &start,const string &stop,
+  void setCommentDelimeter(const std::string &start,const std::string &stop,
 			   bool usecommentfill);			///< Establish comment delimiters for the language
   uint4 getInstructionComment(void) const { return instr_comment_type; }	///< Get the type of comments suitable within the body of a function
   void setInstructionComment(uint4 val) { instr_comment_type = val; }	///< Set the type of comments suitable within the body of a function
@@ -443,14 +443,14 @@ class PrintLanguage {
   virtual void adjustTypeOperators(void)=0;			///< Set basic data-type information for p-code operators
   virtual void resetDefaults(void);				///< Set printing options to their default value
   virtual void clear(void);					///< Clear the RPN stack and the low-level emitter
-  virtual void setIntegerFormat(const string &nm);		///< Set the default integer format
+  virtual void setIntegerFormat(const std::string &nm);		///< Set the default integer format
 
   /// \brief Set the way comments are displayed in decompiler output
   ///
   /// This method can either be provided a formal name or a \e sample of the initial delimiter,
   /// then it will choose from among the schemes it knows
   /// \param nm is the configuration description
-  virtual void setCommentStyle(const string &nm)=0;
+  virtual void setCommentStyle(const std::string &nm)=0;
 
   /// \brief Emit definitions of data-types
   ///
@@ -556,7 +556,7 @@ class PrintLanguage {
   virtual void opPopcountOp(const PcodeOp *op)=0;			///< Emit a POPCOUNT operator
 
   static int4 mostNaturalBase(uintb val); 			///< Determine the most natural base for an integer
-  static void formatBinary(ostream &s,uintb val);		///< Print a number in binary form
+  static void formatBinary(std::ostream &s,uintb val);		///< Print a number in binary form
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.cc
index d98998426..3d17317f8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.cc
@@ -16,6 +16,8 @@
 #include "rangeutil.hh"
 #include "block.hh"
 
+using namespace std;
+
 const char CircleRange::arrange[] = "gcgbegdagggggggeggggcgbggggggggcdfgggggggegdggggbgggfggggcgbegda";
 
 /// All the instantiations where left == right represent the same set. We
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.hh
index e4f37b063..f046fba21 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.hh
@@ -95,7 +95,7 @@ class CircleRange {
 			  int4 inSize,int4 outSize,int4 maxStep);
   void widen(const CircleRange &op2,bool leftIsStable);	///< Widen the unstable bound to match containing range
   int4 translate2Op(OpCode &opc,uintb &c,int4 &cslot) const;	///< Translate range to a comparison op
-  void printRaw(ostream &s) const;		///< Write a text representation of \b this to stream
+  void printRaw(std::ostream &s) const;		///< Write a text representation of \b this to stream
 };
 
 class Partition;		// Forward declaration
@@ -134,7 +134,7 @@ class ValueSet {
   bool rightIsStable;	///< Set to \b true if right boundary of range didn't change (last iteration)
   Varnode *vn;		///< Varnode whose set this represents
   CircleRange range;	///< Range of values or offsets in this set
-  vector<Equation> equations;	///< Any equations associated with this value set
+  std::vector<Equation> equations;	///< Any equations associated with this value set
   Partition *partHead;	///< If Varnode is a component head, pointer to corresponding Partition
   ValueSet *next;	///< Next ValueSet to iterate
   bool doesEquationApply(int4 num,int4 slot) const;	///< Does the indicated equation apply for the given input slot
@@ -152,7 +152,7 @@ class ValueSet {
   const CircleRange &getRange(void) const { return range; }	///< Get the actual range of values
   bool isLeftStable(void) const { return leftIsStable; }	///< Return \b true if the left boundary hasn't been changing
   bool isRightStable(void) const { return rightIsStable; }	///< Return \b true if the right boundary hasn't been changing
-  void printRaw(ostream &s) const;		///< Write a text description of \b to the given stream
+  void printRaw(std::ostream &s) const;		///< Write a text description of \b to the given stream
 };
 
 /// \brief A range of nodes (within the weak topological ordering) that are iterated together
@@ -191,7 +191,7 @@ class ValueSetRead {
   bool isLeftStable(void) const { return leftIsStable; }	///< Return \b true if the left boundary hasn't been changing
   bool isRightStable(void) const { return rightIsStable; }	///< Return \b true if the right boundary hasn't been changing
   void compute(void);			///< Compute \b this value set
-  void printRaw(ostream &s) const;	///< Write a text description of \b to the given stream
+  void printRaw(std::ostream &s) const;	///< Write a text description of \b to the given stream
 };
 
 /// \brief Class holding a particular widening strategy for the ValueSetSolver iteration algorithm
@@ -277,21 +277,21 @@ class ValueSetSolver {
   /// there is support for a simulated root node. This class acts as an iterator over the outgoing
   /// edges of a particular ValueSet in the graph.
   class ValueSetEdge {
-    const vector<ValueSet *> *rootEdges;		///< The list of nodes attached to the simulated root node (or NULL)
+    const std::vector<ValueSet *> *rootEdges;		///< The list of nodes attached to the simulated root node (or NULL)
     int4 rootPos;					///< The iterator position for the simulated root node
     Varnode *vn;					///< The Varnode attached to a normal ValueSet node (or NULL)
-    list<PcodeOp *>::const_iterator iter;		///< The iterator position for a normal ValueSet node
+    std::list<PcodeOp *>::const_iterator iter;		///< The iterator position for a normal ValueSet node
   public:
-    ValueSetEdge(ValueSet *node,const vector<ValueSet *> &roots);
+    ValueSetEdge(ValueSet *node,const std::vector<ValueSet *> &roots);
     ValueSet *getNext(void);
   };
 
-  list<ValueSet> valueNodes;		///< Storage for all the current value sets
-  map<SeqNum,ValueSetRead> readNodes;	///< Additional, after iteration, add-on value sets
+  std::list<ValueSet> valueNodes;		///< Storage for all the current value sets
+  std::map<SeqNum,ValueSetRead> readNodes;	///< Additional, after iteration, add-on value sets
   Partition orderPartition;		///< Value sets in iteration order
-  list<Partition> recordStorage;	///< Storage for the Partitions establishing components
-  vector<ValueSet *> rootNodes;		///< Values treated as inputs
-  vector<ValueSet *> nodeStack;		///< Stack used to generate the topological ordering
+  std::list<Partition> recordStorage;	///< Storage for the Partitions establishing components
+  std::vector<ValueSet *> rootNodes;		///< Values treated as inputs
+  std::vector<ValueSet *> nodeStack;		///< Stack used to generate the topological ordering
   int4 depthFirstIndex;			///< (Global) depth first numbering for topological ordering
   int4 numIterations;			///< Count of individual ValueSet iterations
   int4 maxIterations;			///< Maximum number of iterations before forcing termination
@@ -307,20 +307,20 @@ class ValueSetSolver {
   void applyConstraints(Varnode *vn,int4 type,const CircleRange &range,PcodeOp *cbranch);
   void constraintsFromPath(int4 type,CircleRange &lift,Varnode *startVn,Varnode *endVn,PcodeOp *cbranch);
   void constraintsFromCBranch(PcodeOp *cbranch);		///< Generate constraints arising from the given branch
-  void generateConstraints(const vector<Varnode *> &worklist,const vector<PcodeOp *> &reads);	///< Generate constraints given a system of Varnodes
+  void generateConstraints(const std::vector<Varnode *> &worklist,const std::vector<PcodeOp *> &reads);	///< Generate constraints given a system of Varnodes
   bool checkRelativeConstant(Varnode *vn,int4 &typeCode,uintb &value) const;	///< Check if the given Varnode is a \e relative constant
   void generateRelativeConstraint(PcodeOp *compOp,PcodeOp *cbranch);	///< Try to find a \e relative constraint
 public:
-  void establishValueSets(const vector<Varnode *> &sinks,const vector<PcodeOp *> &reads,Varnode *stackReg,bool indirectAsCopy);
+  void establishValueSets(const std::vector<Varnode *> &sinks,const std::vector<PcodeOp *> &reads,Varnode *stackReg,bool indirectAsCopy);
   int4 getNumIterations(void) const { return numIterations; }	///< Get the current number of iterations
   void solve(int4 max,Widener &widener);			///< Iterate the ValueSet system until it stabilizes
-  list<ValueSet>::const_iterator beginValueSets(void) const { return valueNodes.begin(); }	///< Start of all ValueSets in the system
-  list<ValueSet>::const_iterator endValueSets(void) const { return valueNodes.end(); }	///< End of all ValueSets in the system
-  map<SeqNum,ValueSetRead>::const_iterator beginValueSetReads(void) const { return readNodes.begin(); }	///< Start of ValueSetReads
-  map<SeqNum,ValueSetRead>::const_iterator endValueSetReads(void) const { return readNodes.end(); }	///< End of ValueSetReads
+  std::list<ValueSet>::const_iterator beginValueSets(void) const { return valueNodes.begin(); }	///< Start of all ValueSets in the system
+  std::list<ValueSet>::const_iterator endValueSets(void) const { return valueNodes.end(); }	///< End of all ValueSets in the system
+  std::map<SeqNum,ValueSetRead>::const_iterator beginValueSetReads(void) const { return readNodes.begin(); }	///< Start of ValueSetReads
+  std::map<SeqNum,ValueSetRead>::const_iterator endValueSetReads(void) const { return readNodes.end(); }	///< End of ValueSetReads
   const ValueSetRead &getValueSetRead(const SeqNum &seq) { return (*readNodes.find(seq)).second; }	///< Get ValueSetRead by SeqNum
 #ifdef CPUI_DEBUG
-  void dumpValueSets(ostream &s) const;
+  void dumpValueSets(std::ostream &s) const;
 #endif
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
index 3b83cf3ce..aab606e5d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
@@ -15,6 +15,8 @@
  */
 #include "raw_arch.hh"
 
+using namespace std;
+
 ElementId ELEM_RAW_SAVEFILE = ElementId("raw_savefile",237);
 
 // Constructing this object registers the capability
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.hh
index 490abf901..23580df2f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.hh
@@ -32,8 +32,8 @@ class RawBinaryArchitectureCapability : public ArchitectureCapability {
   RawBinaryArchitectureCapability &operator=(const RawBinaryArchitectureCapability &op2);	///< Not implemented
 public:
   virtual ~RawBinaryArchitectureCapability(void);
-  virtual Architecture *buildArchitecture(const string &filename,const string &target,ostream *estream);
-  virtual bool isFileMatch(const string &filename) const;
+  virtual Architecture *buildArchitecture(const std::string &filename,const std::string &target,std::ostream *estream);
+  virtual bool isFileMatch(const std::string &filename) const;
   virtual bool isXmlMatch(Document *doc) const;
 };
 
@@ -46,7 +46,7 @@ class RawBinaryArchitecture : public SleighArchitecture {
 public:
   virtual void encode(Encoder &encoder) const;
   virtual void restoreXml(DocumentStorage &store);
-  RawBinaryArchitecture(const string &fname,const string &targ,ostream *estream);	///< Constructor
+  RawBinaryArchitecture(const std::string &fname,const std::string &targ,std::ostream *estream);	///< Constructor
   virtual ~RawBinaryArchitecture(void) {}
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
index 7e8030ae8..01fd7b8c1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
@@ -18,6 +18,8 @@
 #include "subflow.hh"
 #include "rangeutil.hh"
 
+using namespace std;
+
 /// \class RuleEarlyRemoval
 /// \brief Get rid of unused PcodeOp objects where we can guarantee the output is unused
 int4 RuleEarlyRemoval::applyOp(PcodeOp *op,Funcdata &data)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.hh
index 0412b8b72..71b9b1d16 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.hh
@@ -52,9 +52,9 @@ class AddTreeState {
   uintb ptrmask;		///< Mask for modulo calculations in ptr space
   uintb offset;			///< Number of bytes we dig into the base data-type
   uintb correct;		///< Number of bytes being double counted
-  vector<Varnode *> multiple;	///< Varnodes which are multiples of size
-  vector<intb> coeff;		///< Associated constant multiple
-  vector<Varnode *> nonmult;	///< Varnodes which are not multiples
+  std::vector<Varnode *> multiple;	///< Varnodes which are multiples of size
+  std::vector<intb> coeff;		///< Associated constant multiple
+  std::vector<Varnode *> nonmult;	///< Varnodes which are not multiples
   PcodeOp *distributeOp;	///< A CPUI_INT_MULT op that needs to be distributed
   uintb multsum;		///< Sum of multiple constants
   uintb nonmultsum;		///< Sum of non-multiple constants
@@ -82,7 +82,7 @@ class AddTreeState {
 
 class RuleEarlyRemoval : public Rule {
 public:
-  RuleEarlyRemoval(const string &g) : Rule(g, 0, "earlyremoval") {}	///< Constructor
+  RuleEarlyRemoval(const std::string &g) : Rule(g, 0, "earlyremoval") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleEarlyRemoval(getGroup());
@@ -92,180 +92,180 @@ class RuleEarlyRemoval : public Rule {
 };
 // class RuleAddrForceRelease : public Rule {
 // public:
-//   RuleAddrForceRelease(const string &g) : Rule(g, 0, "addrforcerelease") {}	///< Constructor
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   RuleAddrForceRelease(const std::string &g) : Rule(g, 0, "addrforcerelease") {}	///< Constructor
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 class RuleCollectTerms : public Rule {
   static Varnode *getMultCoeff(Varnode *vn,uintb &coef);	///< Get the multiplicative coefficient
 public:
-  RuleCollectTerms(const string &g) : Rule(g, 0, "collect_terms") {}	///< Constructor
+  RuleCollectTerms(const std::string &g) : Rule(g, 0, "collect_terms") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleCollectTerms(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSelectCse : public Rule {
 public:
-  RuleSelectCse(const string &g) : Rule(g,0,"selectcse") {}	///< Constructor
+  RuleSelectCse(const std::string &g) : Rule(g,0,"selectcse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSelectCse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePiece2Zext : public Rule {
 public:
-  RulePiece2Zext(const string &g) : Rule(g, 0, "piece2zext") {}	///< Constructor
+  RulePiece2Zext(const std::string &g) : Rule(g, 0, "piece2zext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePiece2Zext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePiece2Sext : public Rule {
 public:
-  RulePiece2Sext(const string &g) : Rule(g, 0, "piece2sext") {}	///< Constructor
+  RulePiece2Sext(const std::string &g) : Rule(g, 0, "piece2sext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePiece2Sext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleBxor2NotEqual : public Rule {
 public:
-  RuleBxor2NotEqual(const string &g) : Rule(g, 0, "bxor2notequal") {}	///< Constructor
+  RuleBxor2NotEqual(const std::string &g) : Rule(g, 0, "bxor2notequal") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleBxor2NotEqual(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleOrMask : public Rule {
 public:
-  RuleOrMask(const string &g) : Rule(g, 0, "ormask") {}	///< Constructor
+  RuleOrMask(const std::string &g) : Rule(g, 0, "ormask") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleOrMask(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleAndMask : public Rule {
 public:
-  RuleAndMask(const string &g) : Rule(g, 0, "andmask") {}	///< Constructor
+  RuleAndMask(const std::string &g) : Rule(g, 0, "andmask") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndMask(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleOrConsume : public Rule {
 public:
-  RuleOrConsume(const string &g) : Rule(g, 0, "orconsume") {}	///< Constructor
+  RuleOrConsume(const std::string &g) : Rule(g, 0, "orconsume") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleOrConsume(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleOrCollapse : public Rule {
 public:
-  RuleOrCollapse(const string &g) : Rule(g, 0, "orcollapse") {}	///< Constructor
+  RuleOrCollapse(const std::string &g) : Rule(g, 0, "orcollapse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleOrCollapse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleAndOrLump : public Rule {
 public:
-  RuleAndOrLump(const string &g) : Rule(g, 0, "andorlump") {}	///< Constructor
+  RuleAndOrLump(const std::string &g) : Rule(g, 0, "andorlump") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndOrLump(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleNegateIdentity : public Rule {
 public:
-  RuleNegateIdentity(const string &g) : Rule(g, 0, "negateidentity") {}	///< Constructor
+  RuleNegateIdentity(const std::string &g) : Rule(g, 0, "negateidentity") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleNegateIdentity(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShiftBitops : public Rule {
 public:
-  RuleShiftBitops(const string &g) : Rule(g, 0, "shiftbitops") {}	///< Constructor
+  RuleShiftBitops(const std::string &g) : Rule(g, 0, "shiftbitops") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShiftBitops(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleRightShiftAnd : public Rule {
 public:
-  RuleRightShiftAnd(const string &g) : Rule(g, 0, "rightshiftand") {}	///< Constructor
+  RuleRightShiftAnd(const std::string &g) : Rule(g, 0, "rightshiftand") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleRightShiftAnd(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleIntLessEqual : public Rule {
 public:
-  RuleIntLessEqual(const string &g) : Rule(g, 0, "intlessequal") {}	///< Constructor
+  RuleIntLessEqual(const std::string &g) : Rule(g, 0, "intlessequal") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleIntLessEqual(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleEquality : public Rule {
 public:
-  RuleEquality(const string &g) : Rule(g, 0, "equality") {}	///< Constructor
+  RuleEquality(const std::string &g) : Rule(g, 0, "equality") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleEquality(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 // Reversible rules
 class RuleTermOrder : public Rule {
 public:
-  RuleTermOrder(const string &g) : Rule(g, 0, "termorder") {}	///< Constructor
+  RuleTermOrder(const std::string &g) : Rule(g, 0, "termorder") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTermOrder(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePullsubMulti : public Rule {
 public:
-  RulePullsubMulti(const string &g) : Rule(g, 0, "pullsub_multi") {}	///< Constructor
+  RulePullsubMulti(const std::string &g) : Rule(g, 0, "pullsub_multi") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePullsubMulti(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static void minMaxUse(Varnode *vn,int4 &maxByte,int4 &minByte);
   static void replaceDescendants(Varnode *origVn,Varnode *newVn,int4 maxByte,int4 minByte,Funcdata &data);
@@ -275,389 +275,389 @@ class RulePullsubMulti : public Rule {
 };
 class RulePullsubIndirect : public Rule {
 public:
-  RulePullsubIndirect(const string &g) : Rule(g, 0, "pullsub_indirect") {}	///< Constructor
+  RulePullsubIndirect(const std::string &g) : Rule(g, 0, "pullsub_indirect") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePullsubIndirect(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePushMulti : public Rule {
   static PcodeOp *findSubstitute(Varnode *in1,Varnode *in2,BlockBasic *bb,PcodeOp *earliest);
 public:
-  RulePushMulti(const string &g) : Rule(g, 0, "push_multi") {}	///< Constructor
+  RulePushMulti(const std::string &g) : Rule(g, 0, "push_multi") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePushMulti(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleNotDistribute : public Rule {
 public:
-  RuleNotDistribute(const string &g) : Rule(g, 0, "notdistribute") {}	///< Constructor
+  RuleNotDistribute(const std::string &g) : Rule(g, 0, "notdistribute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleNotDistribute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleHighOrderAnd : public Rule {
 public:
-  RuleHighOrderAnd(const string &g) : Rule(g, 0, "highorderand") {}	///< Constructor
+  RuleHighOrderAnd(const std::string &g) : Rule(g, 0, "highorderand") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleHighOrderAnd(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleAndDistribute : public Rule {
 public:
-  RuleAndDistribute(const string &g) : Rule(g, 0, "anddistribute") {}	///< Constructor
+  RuleAndDistribute(const std::string &g) : Rule(g, 0, "anddistribute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndDistribute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLessOne : public Rule {
 public:
-  RuleLessOne(const string &g) : Rule(g, 0, "lessone") {}	///< Constructor
+  RuleLessOne(const std::string &g) : Rule(g, 0, "lessone") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLessOne(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleRangeMeld : public Rule {
 public:
-  RuleRangeMeld(const string &g) : Rule(g, 0, "rangemeld") {}	///< Constructor
+  RuleRangeMeld(const std::string &g) : Rule(g, 0, "rangemeld") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleRangeMeld(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };  
 class RuleFloatRange : public Rule {
 public:
-  RuleFloatRange(const string &g) : Rule(g, 0, "floatrange") {}	///< Constructor
+  RuleFloatRange(const std::string &g) : Rule(g, 0, "floatrange") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleFloatRange(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };  
 class RuleAndCommute : public Rule {
 public:
-  RuleAndCommute(const string &g) : Rule(g, 0, "andcommute") {}	///< Constructor
+  RuleAndCommute(const std::string &g) : Rule(g, 0, "andcommute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndCommute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };  
 class RuleAndPiece : public Rule {
 public:
-  RuleAndPiece(const string &g) : Rule(g, 0, "andpiece") {}	///< Constructor
+  RuleAndPiece(const std::string &g) : Rule(g, 0, "andpiece") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndPiece(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };  
 class RuleAndCompare : public Rule {
 public:
-  RuleAndCompare(const string &g) : Rule(g, 0, "andcompare") {}	///< Constructor
+  RuleAndCompare(const std::string &g) : Rule(g, 0, "andcompare") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAndCompare(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleDoubleSub : public Rule {
 public:
-  RuleDoubleSub(const string &g) : Rule(g, 0, "doublesub") {}	///< Constructor
+  RuleDoubleSub(const std::string &g) : Rule(g, 0, "doublesub") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleSub(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };  
 class RuleDoubleShift : public Rule {
 public:
-  RuleDoubleShift(const string &g) : Rule(g, 0, "doubleshift") {}	///< Constructor
+  RuleDoubleShift(const std::string &g) : Rule(g, 0, "doubleshift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleDoubleArithShift : public Rule {
 public:
-  RuleDoubleArithShift(const string &g) : Rule(g, 0, "doublearithshift") {}	///< Constructor
+  RuleDoubleArithShift(const std::string &g) : Rule(g, 0, "doublearithshift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDoubleArithShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleConcatShift : public Rule {
 public:
-  RuleConcatShift(const string &g) : Rule(g, 0, "concatshift") {}	///< Constructor
+  RuleConcatShift(const std::string &g) : Rule(g, 0, "concatshift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConcatShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLeftRight : public Rule {
 public:
-  RuleLeftRight(const string &g) : Rule(g, 0, "leftright") {}	///< Constructor
+  RuleLeftRight(const std::string &g) : Rule(g, 0, "leftright") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLeftRight(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShiftCompare : public Rule {
 public:
-  RuleShiftCompare(const string &g) : Rule(g, 0, "shiftcompare") {}	///< Constructor
+  RuleShiftCompare(const std::string &g) : Rule(g, 0, "shiftcompare") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShiftCompare(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 // class RuleShiftLess : public Rule {
 // public:
-//   RuleShiftLess(const string &g) : Rule(g, 0, "shiftless") {}	///< Constructor
+//   RuleShiftLess(const std::string &g) : Rule(g, 0, "shiftless") {}	///< Constructor
 //   virtual Rule *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Rule *)0;
 //     return new RuleShiftLess(getGroup());
 //   }
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 class RuleLessEqual : public Rule {
 public:
-  RuleLessEqual(const string &g) : Rule(g, 0, "lessequal") {}	///< Constructor
+  RuleLessEqual(const std::string &g) : Rule(g, 0, "lessequal") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLessEqual(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLessNotEqual : public Rule {
 public:
-  RuleLessNotEqual(const string &g) : Rule(g, 0, "lessnotequal") {}	///< Constructor
+  RuleLessNotEqual(const std::string &g) : Rule(g, 0, "lessnotequal") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLessNotEqual(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleTrivialArith : public Rule {
 public:
-  RuleTrivialArith(const string &g) : Rule(g, 0, "trivialarith") {}	///< Constructor
+  RuleTrivialArith(const std::string &g) : Rule(g, 0, "trivialarith") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTrivialArith(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleTrivialBool : public Rule {
 public:
-  RuleTrivialBool(const string &g) : Rule(g, 0, "trivialbool") {}	///< Constructor
+  RuleTrivialBool(const std::string &g) : Rule(g, 0, "trivialbool") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTrivialBool(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleZextEliminate : public Rule {
 public:
-  RuleZextEliminate(const string &g) : Rule(g, 0, "zexteliminate") {}	///< Constructor
+  RuleZextEliminate(const std::string &g) : Rule(g, 0, "zexteliminate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleZextEliminate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSlessToLess : public Rule {
 public:
-  RuleSlessToLess(const string &g) : Rule(g, 0, "slesstoless") {}	///< Constructor
+  RuleSlessToLess(const std::string &g) : Rule(g, 0, "slesstoless") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSlessToLess(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleZextSless : public Rule {
 public:
-  RuleZextSless(const string &g) : Rule(g, 0, "zextsless") {}	///< Constructor
+  RuleZextSless(const std::string &g) : Rule(g, 0, "zextsless") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleZextSless(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleBitUndistribute : public Rule {
 public:
-  RuleBitUndistribute(const string &g) : Rule(g, 0, "bitundistribute") {}	///< Constructor
+  RuleBitUndistribute(const std::string &g) : Rule(g, 0, "bitundistribute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleBitUndistribute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleBooleanNegate : public Rule {
 public:
-  RuleBooleanNegate(const string &g) : Rule(g, 0, "booleannegate") {}	///< Constructor
+  RuleBooleanNegate(const std::string &g) : Rule(g, 0, "booleannegate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleBooleanNegate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleBoolZext : public Rule {
 public:
-  RuleBoolZext(const string &g) : Rule(g, 0, "boolzext") {}	///< Constructor
+  RuleBoolZext(const std::string &g) : Rule(g, 0, "boolzext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleBoolZext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLogic2Bool : public Rule {
 public:
-  RuleLogic2Bool(const string &g) : Rule(g, 0, "logic2bool") {}	///< Constructor
+  RuleLogic2Bool(const std::string &g) : Rule(g, 0, "logic2bool") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLogic2Bool(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleIndirectCollapse : public Rule {
 public:
-  RuleIndirectCollapse(const string &g) : Rule(g, 0, "indirectcollapse") {}	///< Constructor
+  RuleIndirectCollapse(const std::string &g) : Rule(g, 0, "indirectcollapse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleIndirectCollapse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleMultiCollapse : public Rule {
 public:
-  RuleMultiCollapse(const string &g) : Rule(g, 0, "multicollapse") {}	///< Constructor
+  RuleMultiCollapse(const std::string &g) : Rule(g, 0, "multicollapse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleMultiCollapse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSborrow : public Rule {
 public:
-  RuleSborrow(const string &g) : Rule(g, 0, "sborrow") {}	///< Constructor
+  RuleSborrow(const std::string &g) : Rule(g, 0, "sborrow") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSborrow(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleTrivialShift : public Rule {
 public:
-  RuleTrivialShift(const string &g) : Rule(g, 0, "trivialshift") {}	///< Constructor
+  RuleTrivialShift(const std::string &g) : Rule(g, 0, "trivialshift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTrivialShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSignShift : public Rule {
 public:
-  RuleSignShift(const string &g) : Rule(g, 0, "signshift") {}		///< Constructor
+  RuleSignShift(const std::string &g) : Rule(g, 0, "signshift") {}		///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleTestSign : public Rule {
-  void findComparisons(Varnode *vn,vector<PcodeOp *> &res);
+  void findComparisons(Varnode *vn,std::vector<PcodeOp *> &res);
 public:
-  RuleTestSign(const string &g) : Rule(g, 0, "testsign") {}		///< Constructor
+  RuleTestSign(const std::string &g) : Rule(g, 0, "testsign") {}		///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTestSign(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleIdentityEl : public Rule {
 public:
-  RuleIdentityEl(const string &g) : Rule(g, 0, "identityel") {}	///< Constructor
+  RuleIdentityEl(const std::string &g) : Rule(g, 0, "identityel") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleIdentityEl(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShift2Mult : public Rule {
 public:
-  RuleShift2Mult(const string &g) : Rule(g, 0, "shift2mult") {}	///< Constructor
+  RuleShift2Mult(const std::string &g) : Rule(g, 0, "shift2mult") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShift2Mult(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShiftPiece : public Rule {
 public:
-  RuleShiftPiece(const string &g) : Rule(g, 0, "shiftpiece") {}	///< Constructor
+  RuleShiftPiece(const std::string &g) : Rule(g, 0, "shiftpiece") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShiftPiece(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleCollapseConstants : public Rule {
 public:
-  RuleCollapseConstants(const string &g) : Rule(g, 0, "collapseconstants") {}	///< Constructor
+  RuleCollapseConstants(const std::string &g) : Rule(g, 0, "collapseconstants") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleCollapseConstants(getGroup());
@@ -667,17 +667,17 @@ class RuleCollapseConstants : public Rule {
 };
 class RuleTransformCpool : public Rule {
 public:
-  RuleTransformCpool(const string &g) : Rule(g, 0, "transformcpool") {}	///< Constructor
+  RuleTransformCpool(const std::string &g) : Rule(g, 0, "transformcpool") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleTransformCpool(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePropagateCopy : public Rule {
 public:
-  RulePropagateCopy(const string &g) : Rule(g, 0, "propagatecopy") {}	///< Constructor
+  RulePropagateCopy(const std::string &g) : Rule(g, 0, "propagatecopy") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePropagateCopy(getGroup());
@@ -687,62 +687,62 @@ class RulePropagateCopy : public Rule {
 };
 class Rule2Comp2Mult : public Rule {
 public:
-  Rule2Comp2Mult(const string &g) : Rule(g,0,"2comp2mult") {}	///< Constructor
+  Rule2Comp2Mult(const std::string &g) : Rule(g,0,"2comp2mult") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new Rule2Comp2Mult(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleCarryElim : public Rule {
 public:
-  RuleCarryElim(const string &g) : Rule(g, 0, "carryelim") {}	///< Constructor
+  RuleCarryElim(const std::string &g) : Rule(g, 0, "carryelim") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleCarryElim(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSub2Add : public Rule {
 public:
-  RuleSub2Add(const string &g) : Rule(g, 0, "sub2add") {}	///< Constructor
+  RuleSub2Add(const std::string &g) : Rule(g, 0, "sub2add") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSub2Add(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleXorCollapse : public Rule {
 public:
-  RuleXorCollapse(const string &g) : Rule(g, 0, "xorcollapse") {}	///< Constructor
+  RuleXorCollapse(const std::string &g) : Rule(g, 0, "xorcollapse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleXorCollapse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleAddMultCollapse : public Rule {
 public:
-  RuleAddMultCollapse(const string &g) : Rule(g, 0, "addmultcollapse") {}	///< Constructor
+  RuleAddMultCollapse(const std::string &g) : Rule(g, 0, "addmultcollapse") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAddMultCollapse(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 // class RuleUndistribute : public Rule {
 // public:
-//   RuleUndistribute(const string &g) : Rule(g, 0, "undistribute") {}	///< Constructor
+//   RuleUndistribute(const std::string &g) : Rule(g, 0, "undistribute") {}	///< Constructor
 //   virtual Rule *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Rule *)0;
 //     return new RuleUndistribute(Group());
 //   }
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 class RuleLoadVarnode : public Rule {
@@ -751,463 +751,463 @@ class RuleLoadVarnode : public Rule {
   static AddrSpace *vnSpacebase(Architecture *glb,Varnode *vn,uintb &val,AddrSpace *spc);
   static AddrSpace *checkSpacebase(Architecture *glb,PcodeOp *op,uintb &offoff);
 public:
-  RuleLoadVarnode(const string &g) : Rule(g, 0, "loadvarnode") {}	///< Constructor
+  RuleLoadVarnode(const std::string &g) : Rule(g, 0, "loadvarnode") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLoadVarnode(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleStoreVarnode : public Rule {
 public:
-  RuleStoreVarnode(const string &g) : Rule(g, 0, "storevarnode") {}	///< Constructor
+  RuleStoreVarnode(const std::string &g) : Rule(g, 0, "storevarnode") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleStoreVarnode(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 // class RuleShadowVar : public Rule {
 // public:
-//   RuleShadowVar(const string &g) : Rule(g, 0, "shadowvar") {}	///< Constructor
+//   RuleShadowVar(const std::string &g) : Rule(g, 0, "shadowvar") {}	///< Constructor
 //   virtual Rule *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Rule *)0;
 //     return new RuleShadowVar(getGroup());
 //   }
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 class RuleSubExtComm : public Rule {
 public:
-  RuleSubExtComm(const string &g) : Rule(g,0,"subextcomm") {}	///< Constructor
+  RuleSubExtComm(const std::string &g) : Rule(g,0,"subextcomm") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubExtComm(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSubCommute : public Rule {
 public:
-  RuleSubCommute(const string &g) : Rule(g, 0, "subcommute") {}	///< Constructor
+  RuleSubCommute(const std::string &g) : Rule(g, 0, "subcommute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubCommute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static bool cancelExtensions(PcodeOp *longform,PcodeOp *subOp,Varnode *ext0In,Varnode *ext1In,Funcdata &data);
 };
 class RuleConcatCommute : public Rule {
 public:
-  RuleConcatCommute(const string &g) : Rule(g, 0, "concatcommute") {}	///< Constructor
+  RuleConcatCommute(const std::string &g) : Rule(g, 0, "concatcommute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConcatCommute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 // class RuleIndirectConcat : public Rule {
 // public:
-//   RuleIndirectConcat(const string &g) : Rule(g, 0, "indirectconcat") {}	///< Constructor
+//   RuleIndirectConcat(const std::string &g) : Rule(g, 0, "indirectconcat") {}	///< Constructor
 //   virtual Rule *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Rule *)0;
 //     return new RuleIndirectConcat(getGroup());
 //   }
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 class RuleConcatZext : public Rule {
 public:
-  RuleConcatZext(const string &g) : Rule(g, 0, "concatzext") {}	///< Constructor
+  RuleConcatZext(const std::string &g) : Rule(g, 0, "concatzext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConcatZext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleZextCommute : public Rule {
 public:
-  RuleZextCommute(const string &g) : Rule(g, 0, "zextcommute") {}	///< Constructor
+  RuleZextCommute(const std::string &g) : Rule(g, 0, "zextcommute") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleZextCommute(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleZextShiftZext : public Rule {
 public:
-  RuleZextShiftZext(const string &g) : Rule(g, 0, "zextshiftzext") {}	///< Constructor
+  RuleZextShiftZext(const std::string &g) : Rule(g, 0, "zextshiftzext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleZextShiftZext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShiftAnd : public Rule {
 public:
-  RuleShiftAnd(const string &g) : Rule(g, 0, "shiftand") {}	///< Constructor
+  RuleShiftAnd(const std::string &g) : Rule(g, 0, "shiftand") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShiftAnd(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleConcatZero : public Rule {
 public:
-  RuleConcatZero(const string &g) : Rule(g, 0, "concatzero") {}	///< Constructor
+  RuleConcatZero(const std::string &g) : Rule(g, 0, "concatzero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConcatZero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleConcatLeftShift : public Rule {
 public:
-  RuleConcatLeftShift(const string &g) : Rule(g, 0, "concatleftshift") {}	///< Constructor
+  RuleConcatLeftShift(const std::string &g) : Rule(g, 0, "concatleftshift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConcatLeftShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSubZext : public Rule {
 public:
-  RuleSubZext(const string &g) : Rule(g, 0, "subzext") {}	///< Constructor
+  RuleSubZext(const std::string &g) : Rule(g, 0, "subzext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubZext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSubCancel : public Rule {
 public:
-  RuleSubCancel(const string &g) : Rule(g, 0, "subcancel") {}	///< Constructor
+  RuleSubCancel(const std::string &g) : Rule(g, 0, "subcancel") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubCancel(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleShiftSub : public Rule {
 public:
-  RuleShiftSub(const string &g) : Rule(g, 0, "shiftsub") {}	///< Constructor
+  RuleShiftSub(const std::string &g) : Rule(g, 0, "shiftsub") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleShiftSub(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleHumptyDumpty : public Rule {
 public:
-  RuleHumptyDumpty(const string &g) : Rule(g, 0, "humptydumpty") {}	///< Constructor
+  RuleHumptyDumpty(const std::string &g) : Rule(g, 0, "humptydumpty") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleHumptyDumpty(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleDumptyHump : public Rule {
 public:
-  RuleDumptyHump(const string &g) : Rule(g, 0, "dumptyhump") {}	///< Constructor
+  RuleDumptyHump(const std::string &g) : Rule(g, 0, "dumptyhump") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDumptyHump(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleHumptyOr : public Rule {
 public:
-  RuleHumptyOr(const string &g) : Rule(g, 0, "humptyor") {}	///< Constructor
+  RuleHumptyOr(const std::string &g) : Rule(g, 0, "humptyor") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleHumptyOr(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleEmbed : public Rule {
 public:
-  RuleEmbed(const string &g) : Rule(g, 0, "embed") {}	///< Constructor
+  RuleEmbed(const std::string &g) : Rule(g, 0, "embed") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleEmbed(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSwitchSingle : public Rule {
 public:
-  RuleSwitchSingle(const string &g) : Rule(g,0,"switchsingle") {}	///< Constructor
+  RuleSwitchSingle(const std::string &g) : Rule(g,0,"switchsingle") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSwitchSingle(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleCondNegate : public Rule {
 public:
-  RuleCondNegate(const string &g) : Rule(g, 0, "condnegate") {}	///< Constructor
+  RuleCondNegate(const std::string &g) : Rule(g, 0, "condnegate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleCondNegate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleBoolNegate : public Rule {
 public:
-  RuleBoolNegate(const string &g) : Rule(g, 0, "boolnegate") {}	///< Constructor
+  RuleBoolNegate(const std::string &g) : Rule(g, 0, "boolnegate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleBoolNegate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLess2Zero : public Rule {
 public:
-  RuleLess2Zero(const string &g) : Rule(g, 0, "less2zero") {}	///< Constructor
+  RuleLess2Zero(const std::string &g) : Rule(g, 0, "less2zero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLess2Zero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleLessEqual2Zero : public Rule {
 public:
-  RuleLessEqual2Zero(const string &g) : Rule(g, 0, "lessequal2zero") {}	///< Constructor
+  RuleLessEqual2Zero(const std::string &g) : Rule(g, 0, "lessequal2zero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleLessEqual2Zero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleSLess2Zero : public Rule {
   static Varnode *getHiBit(PcodeOp *op);
 public:
-  RuleSLess2Zero(const string &g) : Rule(g, 0, "sless2zero") {}	///< Constructor
+  RuleSLess2Zero(const std::string &g) : Rule(g, 0, "sless2zero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSLess2Zero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleEqual2Zero : public Rule {
 public:
-  RuleEqual2Zero(const string &g) : Rule(g, 0, "equal2zero") {}	///< Constructor
+  RuleEqual2Zero(const std::string &g) : Rule(g, 0, "equal2zero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleEqual2Zero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RuleEqual2Constant : public Rule {
 public:
-  RuleEqual2Constant(const string &g) : Rule(g, 0, "equal2constant") {}	///< Constructor
+  RuleEqual2Constant(const std::string &g) : Rule(g, 0, "equal2constant") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleEqual2Constant(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePtrArith : public Rule {
   static bool verifyPreferredPointer(PcodeOp *op,int4 slot);
 public:
-  RulePtrArith(const string &g) : Rule(g, 0, "ptrarith") {}	///< Constructor
+  RulePtrArith(const std::string &g) : Rule(g, 0, "ptrarith") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePtrArith(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static int4 evaluatePointerExpression(PcodeOp *op,int4 slot);
 };
 class RuleStructOffset0 : public Rule {
 public:
-  RuleStructOffset0(const string &g) : Rule(g, 0, "structoffset0") {}	///< Constructor
+  RuleStructOffset0(const std::string &g) : Rule(g, 0, "structoffset0") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleStructOffset0(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePushPtr : public Rule {
   static Varnode *buildVarnodeOut(Varnode *vn,PcodeOp *op,Funcdata &data);
-  static void collectDuplicateNeeds(vector<PcodeOp *> &reslist,Varnode *vn);
+  static void collectDuplicateNeeds(std::vector<PcodeOp *> &reslist,Varnode *vn);
 public:
-  RulePushPtr(const string &g) : Rule(g, 0, "pushptr") {}	///< Constructor
+  RulePushPtr(const std::string &g) : Rule(g, 0, "pushptr") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePushPtr(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static void duplicateNeed(PcodeOp *op,Funcdata &data);
 };
 class RulePtraddUndo : public Rule {
 public:
-  RulePtraddUndo(const string &g) : Rule(g, 0, "ptraddundo") {}	///< Constructor
+  RulePtraddUndo(const std::string &g) : Rule(g, 0, "ptraddundo") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePtraddUndo(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 class RulePtrsubUndo : public Rule {
 public:
-  RulePtrsubUndo(const string &g) : Rule(g, 0, "ptrsubundo") {}	///< Constructor
+  RulePtrsubUndo(const std::string &g) : Rule(g, 0, "ptrsubundo") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePtrsubUndo(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 // Cleanup rules
 class RuleMultNegOne : public Rule {
 public:
-  RuleMultNegOne(const string &g) : Rule( g, 0, "multnegone") {}	///< Constructor
+  RuleMultNegOne(const std::string &g) : Rule( g, 0, "multnegone") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleMultNegOne(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleAddUnsigned : public Rule {
 public:
-  RuleAddUnsigned(const string &g) : Rule( g, 0, "addunsigned") {}	///< Constructor
+  RuleAddUnsigned(const std::string &g) : Rule( g, 0, "addunsigned") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleAddUnsigned(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class Rule2Comp2Sub : public Rule {
 public:
-  Rule2Comp2Sub(const string &g) : Rule( g, 0, "2comp2sub") {}	///< Constructor
+  Rule2Comp2Sub(const std::string &g) : Rule( g, 0, "2comp2sub") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new Rule2Comp2Sub(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubRight : public Rule {
 public:
-  RuleSubRight(const string &g) : Rule( g, 0, "subright") {}	///< Constructor
+  RuleSubRight(const std::string &g) : Rule( g, 0, "subright") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubRight(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RulePtrsubCharConstant : public Rule {
   bool pushConstFurther(Funcdata &data,TypePointer *outtype,PcodeOp *op,int4 slot,uintb val);
 public:
-  RulePtrsubCharConstant(const string &g) : Rule( g, 0, "ptrsubcharconstant") {}	///< Constructor
+  RulePtrsubCharConstant(const std::string &g) : Rule( g, 0, "ptrsubcharconstant") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePtrsubCharConstant(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleExtensionPush : public Rule {
 public:
-  RuleExtensionPush(const string &g) : Rule( g, 0, "extensionpush") {}		///< Constructor
+  RuleExtensionPush(const std::string &g) : Rule( g, 0, "extensionpush") {}		///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleExtensionPush(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubNormal : public Rule {
 public:
-  RuleSubNormal(const string &g) : Rule( g, 0, "subnormal") {}	///< Constructor
+  RuleSubNormal(const std::string &g) : Rule( g, 0, "subnormal") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubNormal(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 // class RuleRightShiftSub : public Rule {
 // public:
-//   RuleRightShiftSub(const string &g) : Rule( g, 0, "rightshiftsub") {}	///< Constructor
+//   RuleRightShiftSub(const std::string &g) : Rule( g, 0, "rightshiftsub") {}	///< Constructor
 //   virtual Rule *clone(const ActionGroupList &grouplist) const {
 //     if (!grouplist.contains(getGroup())) return (Rule *)0;
 //     return new RuleRightShiftSub(Group());
 //   }
-//   virtual void getOpList(vector<uint4> &oplist) const;
+//   virtual void getOpList(std::vector<uint4> &oplist) const;
 //   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 // };
 
 class RulePositiveDiv : public Rule {
 public:
-  RulePositiveDiv(const string &g) : Rule( g, 0, "positivediv") {}	///< Constructor
+  RulePositiveDiv(const std::string &g) : Rule( g, 0, "positivediv") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePositiveDiv(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleDivTermAdd : public Rule {
 public:
-  RuleDivTermAdd(const string &g) : Rule( g, 0, "divtermadd") {}	///< Constructor
+  RuleDivTermAdd(const std::string &g) : Rule( g, 0, "divtermadd") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDivTermAdd(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static PcodeOp *findSubshift(PcodeOp *op,int4 &n,OpCode &shiftopc);
 };
 
 class RuleDivTermAdd2 : public Rule {
 public:
-  RuleDivTermAdd2(const string &g) : Rule( g, 0, "divtermadd2") {}	///< Constructor
+  RuleDivTermAdd2(const std::string &g) : Rule( g, 0, "divtermadd2") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDivTermAdd2(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
@@ -1216,102 +1216,102 @@ class RuleDivOpt : public Rule {
   static void moveSignBitExtraction(Varnode *firstVn,Varnode *replaceVn,Funcdata &data);
   static bool checkFormOverlap(PcodeOp *op);	///< If form rooted at given PcodeOp is superseded by an overlapping form
 public:
-  RuleDivOpt(const string &g) : Rule( g, 0, "divopt") {}	///< Constructor
+  RuleDivOpt(const std::string &g) : Rule( g, 0, "divopt") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDivOpt(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static Varnode *findForm(PcodeOp *op,int4 &n,uintb &y,int4 &xsize,OpCode &extopc);
 };
 
 class RuleSignDiv2 : public Rule {
 public:
-  RuleSignDiv2(const string &g) : Rule( g, 0, "signdiv2") {}	///< Constructor
+  RuleSignDiv2(const std::string &g) : Rule( g, 0, "signdiv2") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignDiv2(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleDivChain : public Rule {
 public:
-  RuleDivChain(const string &g) : Rule( g, 0, "divchain") {}	///< Constructor
+  RuleDivChain(const std::string &g) : Rule( g, 0, "divchain") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleDivChain(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSignForm : public Rule {
 public:
-  RuleSignForm(const string &g) : Rule( g, 0, "signform") {}	///< Constructor
+  RuleSignForm(const std::string &g) : Rule( g, 0, "signform") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignForm(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSignForm2 : public Rule {
 public:
-  RuleSignForm2(const string &g) : Rule( g, 0, "signform2") {}	///< Constructor
+  RuleSignForm2(const std::string &g) : Rule( g, 0, "signform2") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignForm2(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSignNearMult : public Rule {
 public:
-  RuleSignNearMult(const string &g) : Rule( g, 0, "signnearmult") {}	///< Constructor
+  RuleSignNearMult(const std::string &g) : Rule( g, 0, "signnearmult") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignNearMult(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleModOpt: public Rule {
 public:
-  RuleModOpt(const string &g) : Rule( g, 0, "modopt") {}	///< Constructor
+  RuleModOpt(const std::string &g) : Rule( g, 0, "modopt") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleModOpt(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSignMod2nOpt : public Rule {
 public:
-  RuleSignMod2nOpt(const string &g) : Rule( g, 0, "signmod2nopt") {}	///< Constructor
+  RuleSignMod2nOpt(const std::string &g) : Rule( g, 0, "signmod2nopt") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignMod2nOpt(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static Varnode *checkSignExtraction(Varnode *outVn);
 };
 
 class RuleSignMod2Opt : public Rule {
 public:
-  RuleSignMod2Opt(const string &g) : Rule( g, 0, "signmod2opt") {}	///< Constructor
+  RuleSignMod2Opt(const std::string &g) : Rule( g, 0, "signmod2opt") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignMod2Opt(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
@@ -1319,56 +1319,56 @@ class RuleSignMod2nOpt2 : public Rule {
   static Varnode *checkMultiequalForm(PcodeOp *op,uintb npow);
   static Varnode *checkSignExtForm(PcodeOp *op);
 public:
-  RuleSignMod2nOpt2(const string &g) : Rule( g, 0, "signmod2nopt2") {}	///< Constructor
+  RuleSignMod2nOpt2(const std::string &g) : Rule( g, 0, "signmod2nopt2") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSignMod2nOpt2(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSegment : public Rule {
 public:
-  RuleSegment(const string &g) : Rule( g, 0, "segment") {}	///< Constructor
+  RuleSegment(const std::string &g) : Rule( g, 0, "segment") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSegment(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarAnd : public Rule {
 public:
-  RuleSubvarAnd(const string &g) : Rule( g, 0, "subvar_and") {}	///< Constructor
+  RuleSubvarAnd(const std::string &g) : Rule( g, 0, "subvar_and") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarAnd(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarSubpiece : public Rule {
 public:
-  RuleSubvarSubpiece(const string &g) : Rule( g, 0, "subvar_subpiece") {}	///< Constructor
+  RuleSubvarSubpiece(const std::string &g) : Rule( g, 0, "subvar_subpiece") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarSubpiece(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSplitFlow : public Rule {
 public:
-  RuleSplitFlow(const string &g) : Rule( g, 0, "splitflow") {}	///< Constructor
+  RuleSplitFlow(const std::string &g) : Rule( g, 0, "splitflow") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSplitFlow(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
@@ -1380,80 +1380,80 @@ class RulePtrFlow : public Rule {
   bool propagateFlowToReads(Varnode *vn);
   Varnode *truncatePointer(AddrSpace *spc,PcodeOp *op,Varnode *vn,int4 slot,Funcdata &data);
 public:
-  RulePtrFlow(const string &g,Architecture *conf);	///< Constructor
+  RulePtrFlow(const std::string &g,Architecture *conf);	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePtrFlow(getGroup(),glb);
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarCompZero : public Rule {
 public:
-  RuleSubvarCompZero(const string &g) : Rule( g, 0, "subvar_compzero") {}	///< Constructor
+  RuleSubvarCompZero(const std::string &g) : Rule( g, 0, "subvar_compzero") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarCompZero(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarShift : public Rule {
 public:
-  RuleSubvarShift(const string &g) : Rule( g, 0, "subvar_shift") {}	///< Constructor
+  RuleSubvarShift(const std::string &g) : Rule( g, 0, "subvar_shift") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarShift(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarZext : public Rule {
 public:
-  RuleSubvarZext(const string &g) : Rule( g, 0, "subvar_zext") {}	///< Constructor
+  RuleSubvarZext(const std::string &g) : Rule( g, 0, "subvar_zext") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarZext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleSubvarSext : public Rule {
   int4 isaggressive;			///< Is it guaranteed the root is a sub-variable needing to be trimmed
 public:
-  RuleSubvarSext(const string &g) : Rule( g, 0, "subvar_sext") { isaggressive = false; }	///< Constructor
+  RuleSubvarSext(const std::string &g) : Rule( g, 0, "subvar_sext") { isaggressive = false; }	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubvarSext(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   virtual void reset(Funcdata &data);
 };
 
 class RuleSubfloatConvert : public Rule {
 public:
-  RuleSubfloatConvert(const string &g) : Rule( g, 0, "subfloat_convert") {}	///< Constructor
+  RuleSubfloatConvert(const std::string &g) : Rule( g, 0, "subfloat_convert") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleSubfloatConvert(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleNegateNegate : public Rule {
 public:
-  RuleNegateNegate(const string &g) : Rule( g, 0, "negatenegate") {}	///< Constructor
+  RuleNegateNegate(const std::string &g) : Rule( g, 0, "negatenegate") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleNegateNegate(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
@@ -1476,56 +1476,56 @@ class RuleConditionalMove : public Rule {
   };
   static Varnode *constructNegate(Varnode *vn,PcodeOp *op,Funcdata &data);
 public:
-  RuleConditionalMove(const string &g) : Rule( g, 0, "conditionalmove") {}	///< Constructor
+  RuleConditionalMove(const std::string &g) : Rule( g, 0, "conditionalmove") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleConditionalMove(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleFloatCast : public Rule {
 public:
-  RuleFloatCast(const string &g) : Rule( g, 0, "floatcast") {}	///< Constructor
+  RuleFloatCast(const std::string &g) : Rule( g, 0, "floatcast") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleFloatCast(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleIgnoreNan : public Rule {
 public:
-  RuleIgnoreNan(const string &g) : Rule( g, 0, "ignorenan") {}	///< Constructor
+  RuleIgnoreNan(const std::string &g) : Rule( g, 0, "ignorenan") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleIgnoreNan(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleFuncPtrEncoding : public Rule {
 public:
-  RuleFuncPtrEncoding(const string &g) : Rule( g, 0, "funcptrencoding") {}	///< Constructor
+  RuleFuncPtrEncoding(const std::string &g) : Rule( g, 0, "funcptrencoding") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleFuncPtrEncoding(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleThreeWayCompare : public Rule {
 public:
-  RuleThreeWayCompare(const string &g) : Rule( g, 0, "threewaycomp") {}	///< Constructor
+  RuleThreeWayCompare(const std::string &g) : Rule( g, 0, "threewaycomp") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleThreeWayCompare(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static PcodeOp *detectThreeWay(PcodeOp *op,bool &isPartial);
   static int4 testCompareEquivalence(PcodeOp *lessop,PcodeOp *lessequalop);
@@ -1533,24 +1533,24 @@ class RuleThreeWayCompare : public Rule {
 
 class RulePopcountBoolXor : public Rule {
 public:
-  RulePopcountBoolXor(const string &g) : Rule( g, 0, "popcountboolxor") {}	///< Constructor
+  RulePopcountBoolXor(const std::string &g) : Rule( g, 0, "popcountboolxor") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePopcountBoolXor(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
   static Varnode *getBooleanResult(Varnode *vn,int4 bitPos,int4 &constRes);
 };
 
 class RuleOrMultiBool : public Rule {
 public:
-  RuleOrMultiBool(const string &g) : Rule( g, 0, "ormultibool") {}	///< Constructor
+  RuleOrMultiBool(const std::string &g) : Rule( g, 0, "ormultibool") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleOrMultiBool(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
@@ -1558,23 +1558,23 @@ class RulePiecePathology : public Rule {
   static bool isPathology(Varnode *vn,Funcdata &data);
   static int4 tracePathologyForward(PcodeOp *op,Funcdata &data);
 public:
-  RulePiecePathology(const string &g) : Rule( g, 0, "piecepathology") {}	///< Constructor
+  RulePiecePathology(const std::string &g) : Rule( g, 0, "piecepathology") {}	///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RulePiecePathology(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
 class RuleXorSwap : public Rule {
 public:
-  RuleXorSwap(const string &g) : Rule(g,0,"xorswap") {}		///< Constructor
+  RuleXorSwap(const std::string &g) : Rule(g,0,"xorswap") {}		///< Constructor
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0;
     return new RuleXorSwap(getGroup());
   }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
index af4e191c7..eeb7cc1f7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.cc
@@ -17,6 +17,8 @@
 #include "rulecompile.hh"
 #include "ruleparse.hh"
 
+using namespace std;
+
 RuleCompile *rulecompile;
 extern int4 ruleparsedebug;
 extern int4 ruleparseparse(void);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.hh
index 8cce8fc2f..23c656384 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/rulecompile.hh
@@ -20,8 +20,8 @@
 
 class RuleLexer {
   static int4 identlist[256];	// 1 is identifier, 2 is digit, 4=namechar
-  map<string,int4> keywordmap;
-  istream *s;
+  std::map<std::string,int4> keywordmap;
+  std::istream *s;
   char identifier[256];
   int4 identlength;
   int4 lookahead[4];
@@ -53,7 +53,7 @@ class RuleLexer {
   void initKeywords(void);
 public:
   RuleLexer(void);
-  void initialize(istream &t);
+  void initialize(std::istream &t);
   int4 getLineNo(void) { return lineno; }
   int4 nextToken(void);
 };
@@ -61,22 +61,22 @@ class RuleLexer {
 class DummyTranslate : public Translate {
 public:
   virtual void initialize(DocumentStorage &store) {}
-  virtual const VarnodeData &getRegister(const string &nm) const { throw LowlevelError("Cannot add register to DummyTranslate"); }
-  virtual string getRegisterName(AddrSpace *base,uintb off,int4 size) const { return ""; }
-  virtual void getAllRegisters(map<VarnodeData,string> &reglist) const {}
-  virtual void getUserOpNames(vector<string> &res) const {}
+  virtual const VarnodeData &getRegister(const std::string &nm) const { throw LowlevelError("Cannot add register to DummyTranslate"); }
+  virtual std::string getRegisterName(AddrSpace *base,uintb off,int4 size) const { return ""; }
+  virtual void getAllRegisters(std::map<VarnodeData,std::string> &reglist) const {}
+  virtual void getUserOpNames(std::vector<std::string> &res) const {}
   virtual int4 instructionLength(const Address &baseaddr) const { return -1; }
   virtual int4 oneInstruction(PcodeEmit &emit,const Address &baseaddr) const { return -1; }
   virtual int4 printAssembly(AssemblyEmit &emit,const Address &baseaddr) const { return -1; }
 };
 
 class RuleCompile {
-  ostream *error_stream;
+  std::ostream *error_stream;
   int4 errors;
   RuleLexer lexer;
-  map<string,int4> namemap;
+  std::map<std::string,int4> namemap;
   ConstraintGroup *finalrule;
-  vector<OpBehavior *> inst;
+  std::vector<OpBehavior *> inst;
 public:
   RuleCompile(void);
   ~RuleCompile(void);
@@ -86,9 +86,9 @@ class RuleCompile {
   void setFullRule(ConstraintGroup *full) { finalrule = full; }
   ConstraintGroup *getRule(void) { return finalrule; }
   ConstraintGroup *releaseRule(void) { ConstraintGroup *res = finalrule; finalrule = (ConstraintGroup *)0; return res; }
-  const map<string,int4> &getNameMap(void) const { return namemap; }
+  const std::map<std::string,int4> &getNameMap(void) const { return namemap; }
 
-  int4 findIdentifier(string *nm);
+  int4 findIdentifier(std::string *nm);
 
   ConstraintGroup *newOp(int4 id);
   ConstraintGroup *newVarnode(int4 id);
@@ -106,7 +106,7 @@ class RuleCompile {
   ConstraintGroup *varDescend(ConstraintGroup *base,int4 opid);
   ConstraintGroup *varUniqueDescend(ConstraintGroup *base,int4 opid);
 
-  ConstraintGroup *opCodeConstraint(ConstraintGroup *base,vector<OpCode> *oplist);
+  ConstraintGroup *opCodeConstraint(ConstraintGroup *base,std::vector<OpCode> *oplist);
   ConstraintGroup *opCompareConstraint(ConstraintGroup *base,int4 opid,OpCode opc);
   ConstraintGroup *varCompareConstraint(ConstraintGroup *base,int4 varid,OpCode opc);
   ConstraintGroup *constCompareConstraint(ConstraintGroup *base,int4 constid,OpCode opc);
@@ -128,30 +128,30 @@ class RuleCompile {
   RHSConstant *constAbsolute(int8 *val);
   RHSConstant *constBinaryExpression(RHSConstant *ex1,OpCode opc,RHSConstant *ex2);
   RHSConstant *constVarnodeSize(int4 varindex);
-  RHSConstant *dotIdentifier(int4 id,string *str);
+  RHSConstant *dotIdentifier(int4 id,std::string *str);
 
   int4 nextToken(void) { return lexer.nextToken(); }
 
-  void setErrorStream(ostream &t) { error_stream = &t; }
-  void run(istream &s,bool debug);
+  void setErrorStream(std::ostream &t) { error_stream = &t; }
+  void run(std::istream &s,bool debug);
   void postProcess(void);
-  int4 postProcessRule(vector<OpCode> &opcodelist);
-  static ConstraintGroup *buildUnifyer(const string &rule,const vector<string> &idlist,vector<int4> &res);
+  int4 postProcessRule(std::vector<OpCode> &opcodelist);
+  static ConstraintGroup *buildUnifyer(const std::string &rule,const std::vector<std::string> &idlist,std::vector<int4> &res);
 };
 
 class RuleGeneric : public Rule { // A user configurable rule, (a rule read in from a file)
-  vector<OpCode> starterops;
+  std::vector<OpCode> starterops;
   int4 opinit;			// Index of initialized op
   ConstraintGroup *constraint;
   UnifyState state;
 public:
-  RuleGeneric(const string &g,const string &nm,const vector<OpCode> &sops,int4 opi,ConstraintGroup *c);
+  RuleGeneric(const std::string &g,const std::string &nm,const std::vector<OpCode> &sops,int4 opi,ConstraintGroup *c);
   virtual ~RuleGeneric(void) { delete constraint; }
   virtual Rule *clone(const ActionGroupList &grouplist) const {
     if (!grouplist.contains(getGroup())) return (Rule *)0; return new RuleGeneric(getGroup(),getName(),starterops,opinit,(ConstraintGroup *)constraint->clone()); }
-  virtual void getOpList(vector<uint4> &oplist) const;
+  virtual void getOpList(std::vector<uint4> &oplist) const;
   virtual int4 applyOp(PcodeOp *op,Funcdata &data);
-  static RuleGeneric *build(const string &nm,const string &gp,const string &content);
+  static RuleGeneric *build(const std::string &nm,const std::string &gp,const std::string &content);
 };
 
 /*
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleparse.y
index 3d3ced687..aceb52b9a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleparse.y
@@ -17,6 +17,8 @@
 #ifdef CPUI_RULECOMPILE
 #include "rulecompile.hh"
 
+using namespace std;
+
 #define YYERROR_VERBOSE
 
 extern RuleCompile *rulecompile;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
index 1c9ab7560..a791a3348 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
@@ -16,6 +16,8 @@
 #include "semantics.hh"
 #include "translate.hh"
 
+using namespace std;
+
 ConstTpl::ConstTpl(const_type tp)
 
 {				// Constructor for relative jump constants and uniques
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
index 1fbd169c9..de1f10961 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
@@ -43,8 +43,8 @@ class ConstTpl {
   } value;
   uintb value_real;
   v_field select;		// Which part of handle to use as constant
-  static void printHandleSelector(ostream &s,v_field val);
-  static v_field readHandleSelector(const string &name);
+  static void printHandleSelector(std::ostream &s,v_field val);
+  static v_field readHandleSelector(const std::string &name);
 public:
   ConstTpl(void) { type = real; value_real = 0; select = v_space; }
   ConstTpl(const ConstTpl &op2) {
@@ -65,12 +65,12 @@ class ConstTpl {
   v_field getSelect(void) const { return select; }
   uintb fix(const ParserWalker &walker) const;
   AddrSpace *fixSpace(const ParserWalker &walker) const;
-  void transfer(const vector<HandleTpl *> &params);
+  void transfer(const std::vector<HandleTpl *> &params);
   bool isZero(void) const { return ((type==real)&&(value_real==0)); }
-  void changeHandleIndex(const vector<int4> &handmap);
+  void changeHandleIndex(const std::vector<int4> &handmap);
   void fillinSpace(FixedHandle &hand,const ParserWalker &walker) const;
   void fillinOffset(FixedHandle &hand,const ParserWalker &walker) const;
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,const AddrSpaceManager *manage);
 };
 
@@ -88,7 +88,7 @@ class VarnodeTpl {
   const ConstTpl &getOffset(void) const { return offset; }
   const ConstTpl &getSize(void) const { return size; }
   bool isDynamic(const ParserWalker &walker) const;
-  int4 transfer(const vector<HandleTpl *> &params);
+  int4 transfer(const std::vector<HandleTpl *> &params);
   bool isZeroSize(void) const { return size.isZero(); }
   bool operator<(const VarnodeTpl &op2) const;
   void setOffset(uintb constVal) { offset = ConstTpl(ConstTpl::real,constVal); }
@@ -98,9 +98,9 @@ class VarnodeTpl {
   void setUnnamed(bool val) { unnamed_flag = val; }
   bool isLocalTemp(void) const;
   bool isRelative(void) const { return (offset.getType() == ConstTpl::j_relative); }
-  void changeHandleIndex(const vector<int4> &handmap);
+  void changeHandleIndex(const std::vector<int4> &handmap);
   bool adjustTruncation(int4 sz,bool isbigendian);
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,const AddrSpaceManager *manage);
 };
 
@@ -129,15 +129,15 @@ class HandleTpl {
   void setPtrOffset(uintb val) { ptroffset = ConstTpl(ConstTpl::real,val); }
   void setTempOffset(uintb val) { temp_offset = ConstTpl(ConstTpl::real,val); }
   void fix(FixedHandle &hand,const ParserWalker &walker) const;
-  void changeHandleIndex(const vector<int4> &handmap);
-  void saveXml(ostream &s) const;
+  void changeHandleIndex(const std::vector<int4> &handmap);
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,const AddrSpaceManager *manage);
 };
 
 class OpTpl {
   VarnodeTpl *output;
   OpCode opc;
-  vector<VarnodeTpl *> input;
+  std::vector<VarnodeTpl *> input;
 public:
   OpTpl(void) {}
   OpTpl(OpCode oc) { opc = oc; output = (VarnodeTpl *)0; }
@@ -153,8 +153,8 @@ class OpTpl {
   void addInput(VarnodeTpl *vt) { input.push_back(vt); }
   void setInput(VarnodeTpl *vt,int4 slot) { input[slot] = vt; }
   void removeInput(int4 index);
-  void changeHandleIndex(const vector<int4> &handmap);
-  void saveXml(ostream &s) const;
+  void changeHandleIndex(const std::vector<int4> &handmap);
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,const AddrSpaceManager *manage);
 };
 
@@ -163,27 +163,27 @@ class ConstructTpl {
 protected:
   uint4 delayslot;
   uint4 numlabels;		// Number of label templates
-  vector<OpTpl *> vec;
+  std::vector<OpTpl *> vec;
   HandleTpl *result;
-  void setOpvec(vector<OpTpl *> &opvec) { vec = opvec; }
+  void setOpvec(std::vector<OpTpl *> &opvec) { vec = opvec; }
   void setNumLabels(uint4 val) { numlabels = val; }
 public:
   ConstructTpl(void) { delayslot=0; numlabels=0; result = (HandleTpl *)0; }
   ~ConstructTpl(void);
   uint4 delaySlot(void) const { return delayslot; }
   uint4 numLabels(void) const { return numlabels; }
-  const vector<OpTpl *> &getOpvec(void) const { return vec; }
+  const std::vector<OpTpl *> &getOpvec(void) const { return vec; }
   HandleTpl *getResult(void) const { return result; }
   bool addOp(OpTpl *ot);
-  bool addOpList(const vector<OpTpl *> &oplist);
+  bool addOpList(const std::vector<OpTpl *> &oplist);
   void setResult(HandleTpl *t) { result = t; }
-  int4 fillinBuild(vector<int4> &check,AddrSpace *const_space);
+  int4 fillinBuild(std::vector<int4> &check,AddrSpace *const_space);
   bool buildOnly(void) const;
-  void changeHandleIndex(const vector<int4> &handmap);
+  void changeHandleIndex(const std::vector<int4> &handmap);
   void setInput(VarnodeTpl *vn,int4 index,int4 slot);
   void setOutput(VarnodeTpl *vn,int4 index);
-  void deleteOps(const vector<int4> &indices);
-  void saveXml(ostream &s,int4 sectionid) const;
+  void deleteOps(const std::vector<int4> &indices);
+  void saveXml(std::ostream &s,int4 sectionid) const;
   int4 restoreXml(const Element *el,const AddrSpaceManager *manage);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
index 0fd86e645..b33cf85d2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.cc
@@ -16,6 +16,8 @@
 #include "sleigh.hh"
 #include "loadimage.hh"
 
+using namespace std;
+
 PcodeCacher::PcodeCacher(void)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.hh
index 74fc5cbf8..c003c55f4 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh.hh
@@ -57,9 +57,9 @@ class PcodeCacher {
   VarnodeData *poolstart;		///< Start of the pool of VarnodeData objects
   VarnodeData *curpool;			///< First unused VarnodeData
   VarnodeData *endpool;			///< End of the pool of VarnodeData objects
-  vector<PcodeData> issued;		///< P-code ops issued for the current instruction
-  list<RelativeRecord> label_refs;	///< References to labels
-  vector<uintb> labels;			///< Locations of labels
+  std::vector<PcodeData> issued;		///< P-code ops issued for the current instruction
+  std::list<RelativeRecord> label_refs;	///< References to labels
+  std::vector<uintb> labels;			///< Locations of labels
   VarnodeData *expandPool(uint4 size);	///< Expand the memory pool
 public:
   PcodeCacher(void);		///< Constructor
@@ -173,8 +173,8 @@ class Sleigh : public SleighBase {
   virtual ~Sleigh(void);				///< Destructor
   void reset(LoadImage *ld,ContextDatabase *c_db);	///< Reset the engine for a new program
   virtual void initialize(DocumentStorage &store);
-  virtual void registerContext(const string &name,int4 sbit,int4 ebit);
-  virtual void setContextDefault(const string &nm,uintm val);
+  virtual void registerContext(const std::string &name,int4 sbit,int4 ebit);
+  virtual void setContextDefault(const std::string &nm,uintm val);
   virtual void allowContextSet(bool val) const;
   virtual int4 instructionLength(const Address &baseaddr) const;
   virtual int4 oneInstruction(PcodeEmit &emit,const Address &baseaddr) const;
@@ -327,8 +327,8 @@ class Sleigh : public SleighBase {
 
   // Set up the loadimage
   // Providing an executable name and architecture
-  string loadimagename = "x86testcode";
-  string bfdtarget= "default";
+  std::string loadimagename = "x86testcode";
+  std::string bfdtarget= "default";
 
   loader = new LoadImageBfd(loadimagename,bfdtarget);
   loader->open();       // Load the executable from file
@@ -345,7 +345,7 @@ class Sleigh : public SleighBase {
   this.
 
   \code
-  string sleighfilename = "specfiles/x86.sla";
+  std::string sleighfilename = "specfiles/x86.sla";
   DocumentStorage docstorage;
   Element *sleighroot = docstorage.openDocument(sleighfilename)->getRoot();
   docstorage.registerTag(sleighroot);
@@ -365,7 +365,7 @@ class Sleigh : public SleighBase {
   \code
   class AssemblyRaw : public AssemblyEmit {
   public:
-    virtual void dump(const Address &addr,const string &mnem,const string &body) {
+    virtual void dump(const Address &addr,const std::string &mnem,const std::string &body) {
       addr.printRaw(cout);
       cout << ": " << mnem << ' ' << body << endl;
     }
@@ -484,9 +484,9 @@ class Sleigh : public SleighBase {
   \code
   class MyLoadImage : public LoadImage {
   public:
-    MyLoadImage(const string &nm) : Loadimage(nm) {}
+    MyLoadImage(const std::string &nm) : Loadimage(nm) {}
     virtual void loadFill(uint1 *ptr,int4 size,const Address &addr);
-    virtual string getArchType(void) const { return "mytype"; }
+    virtual std::string getArchType(void) const { return "mytype"; }
     virtual void adjustVma(long adjust) {}
   };
   \endcode
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
index c0518ec0e..5660525e2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
@@ -16,6 +16,8 @@
 #include "sleigh_arch.hh"
 #include "inject_sleigh.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_DEPRECATED = AttributeId("deprecated",136);
 AttributeId ATTRIB_ENDIAN = AttributeId("endian",137);
 AttributeId ATTRIB_PROCESSOR = AttributeId("processor",138);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.hh
index 6bb57b81a..0f0535d22 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.hh
@@ -42,15 +42,15 @@ extern ElementId ELEM_LANGUAGE_DEFINITIONS;	///< Marshaling element \<language_d
 ///
 /// This class describes a compiler specification file as referenced by the Sleigh language subsystem.
 class CompilerTag {
-  string name;          ///< (Human readable) name of the compiler
-  string spec;          ///< cspec file for this compiler
-  string id;            ///< Unique id for this compiler
+  std::string name;          ///< (Human readable) name of the compiler
+  std::string spec;          ///< cspec file for this compiler
+  std::string id;            ///< Unique id for this compiler
 public:
   CompilerTag(void) {}	///< Constructor
   void decode(Decoder &decoder);	///< Restore the record from an XML stream
-  const string &getName(void) const { return name; }	///< Get the human readable name of the spec
-  const string &getSpec(void) const { return spec; }	///< Get the file-name
-  const string &getId(void) const { return id; }	///< Get the string used as part of \e language \e id
+  const std::string &getName(void) const { return name; }	///< Get the human readable name of the spec
+  const std::string &getSpec(void) const { return spec; }	///< Get the file-name
+  const std::string &getId(void) const { return id; }	///< Get the string used as part of \e language \e id
 };
 
 /// \brief Contents of the \<language> tag in a .ldefs file
@@ -62,32 +62,32 @@ class CompilerTag {
 /// a single processor, as described by a single SLEIGH file and processor spec.  Multiple
 /// compiler specifications can be given for the single processor.
 class LanguageDescription {
-  string processor;		///< Name of processor
+  std::string processor;		///< Name of processor
   bool isbigendian;		///< Set to \b true if this processor is \e big-endian
   int4 size;			///< Size of address bus in bits
-  string variant;		///< Name of processor variant or "default"
-  string version;		///< Version of the specification
-  string slafile;		///< Name of .sla file for processor
-  string processorspec;		///< Name of .pspec file
-  string id;			///< Unique id for this language
-  string description;		///< Human readable description of this language
+  std::string variant;		///< Name of processor variant or "default"
+  std::string version;		///< Version of the specification
+  std::string slafile;		///< Name of .sla file for processor
+  std::string processorspec;		///< Name of .pspec file
+  std::string id;			///< Unique id for this language
+  std::string description;		///< Human readable description of this language
   bool deprecated;		///< Set to \b true if the specification is considered \e deprecated
-  vector<CompilerTag> compilers;	///< List of compiler specifications compatible with this processor
-  vector<TruncationTag> truncations;	///< Address space truncations required by this processor
+  std::vector<CompilerTag> compilers;	///< List of compiler specifications compatible with this processor
+  std::vector<TruncationTag> truncations;	///< Address space truncations required by this processor
 public:
   LanguageDescription(void) {}					///< Constructor
   void decode(Decoder &decoder);				///< Parse \b this description from a stream
-  const string &getProcessor(void) const { return processor; }	///< Get the name of the processor
+  const std::string &getProcessor(void) const { return processor; }	///< Get the name of the processor
   bool isBigEndian(void) const { return isbigendian; }		///< Return \b true if the processor is big-endian
   int4 getSize(void) const { return size; }			///< Get the size of the address bus
-  const string &getVariant(void) const { return variant; }	///< Get the processor variant
-  const string &getVersion(void) const { return version; }	///< Get the processor version
-  const string &getSlaFile(void) const { return slafile; }	///< Get filename of the SLEIGH specification
-  const string &getProcessorSpec(void) const { return processorspec; }	///< Get the filename of the processor specification
-  const string &getId(void) const { return id; }		///< Get the \e language \e id string associated with this processor
-  const string &getDescription(void) const { return description; }	///< Get a description of the processor
+  const std::string &getVariant(void) const { return variant; }	///< Get the processor variant
+  const std::string &getVersion(void) const { return version; }	///< Get the processor version
+  const std::string &getSlaFile(void) const { return slafile; }	///< Get filename of the SLEIGH specification
+  const std::string &getProcessorSpec(void) const { return processorspec; }	///< Get the filename of the processor specification
+  const std::string &getId(void) const { return id; }		///< Get the \e language \e id string associated with this processor
+  const std::string &getDescription(void) const { return description; }	///< Get a description of the processor
   bool isDeprecated(void) const { return deprecated; }		///< Return \b true if this specification is deprecated
-  const CompilerTag &getCompiler(const string &nm) const;	///< Get compiler specification of the given name
+  const CompilerTag &getCompiler(const std::string &nm) const;	///< Get compiler specification of the given name
   int4 numCompilers(void) const { return compilers.size(); }	///< Get the number of compiler records
   const CompilerTag &getCompiler(int4 i) const { return compilers[i]; }	///< Get the i-th compiler record
   int4 numTruncations(void) const { return truncations.size(); }	///< Get the number of truncation records
@@ -104,38 +104,38 @@ class LanguageDescription {
 /// Generally a \e language \e id (i.e. x86:LE:64:default) is provided, then this
 /// object is able to automatically load in configuration and construct the Translate object.
 class SleighArchitecture : public Architecture {
-  static map<int4,Sleigh *> translators;		///< Map from language index to instantiated translators
-  static vector<LanguageDescription> description;	///< List of languages we know about
+  static std::map<int4,Sleigh *> translators;		///< Map from language index to instantiated translators
+  static std::vector<LanguageDescription> description;	///< List of languages we know about
   int4 languageindex;					///< Index (within LanguageDescription array) of the active language
-  string filename;					///< Name of active load-image file
-  string target;					///< The \e language \e id of the active load-image
-  static void loadLanguageDescription(const string &specfile,ostream &errs);
+  std::string filename;					///< Name of active load-image file
+  std::string target;					///< The \e language \e id of the active load-image
+  static void loadLanguageDescription(const std::string &specfile,std::ostream &errs);
   bool isTranslateReused(void);				///< Test if last Translate object can be reused
 protected:
-  ostream *errorstream;					///< Error stream associated with \b this SleighArchitecture
+  std::ostream *errorstream;					///< Error stream associated with \b this SleighArchitecture
   // buildLoader must be filled in by derived class
-  static void collectSpecFiles(ostream &errs);		///< Gather specification files in normal locations
+  static void collectSpecFiles(std::ostream &errs);		///< Gather specification files in normal locations
   virtual Translate *buildTranslator(DocumentStorage &store);
   virtual PcodeInjectLibrary *buildPcodeInjectLibrary(void);
   virtual void buildSpecFile(DocumentStorage &store);
   virtual void modifySpaces(Translate *trans);
   virtual void resolveArchitecture(void);
 public:
-  SleighArchitecture(const string &fname,const string &targ,ostream *estream);	///< Construct given executable file
-  const string &getFilename(void) const { return filename; }	///< Get the executable filename
-  const string &getTarget(void) const { return target; }	///< Get the \e language \e id of the active processor
+  SleighArchitecture(const std::string &fname,const std::string &targ,std::ostream *estream);	///< Construct given executable file
+  const std::string &getFilename(void) const { return filename; }	///< Get the executable filename
+  const std::string &getTarget(void) const { return target; }	///< Get the \e language \e id of the active processor
   void encodeHeader(Encoder &encoder) const;			///< Encode basic attributes of the active executable
   void restoreXmlHeader(const Element *el);			///< Restore from basic attributes of an executable
-  virtual void printMessage(const string &message) const { *errorstream << message << endl; }
+  virtual void printMessage(const std::string &message) const { *errorstream << message << std::endl; }
   virtual ~SleighArchitecture(void);
-  virtual string getDescription(void) const;
+  virtual std::string getDescription(void) const;
 
-  static string normalizeProcessor(const string &nm);		///< Try to recover a \e language \e id processor field
-  static string normalizeEndian(const string &nm);		///< Try to recover a \e language \e id endianess field
-  static string normalizeSize(const string &nm);		///< Try to recover a \e language \e id size field
-  static string normalizeArchitecture(const string &nm);	///< Try to recover a \e language \e id string
-  static void scanForSleighDirectories(const string &rootpath);
-  static const vector<LanguageDescription> &getDescriptions(void);	///< Get list of all known language descriptions
+  static std::string normalizeProcessor(const std::string &nm);		///< Try to recover a \e language \e id processor field
+  static std::string normalizeEndian(const std::string &nm);		///< Try to recover a \e language \e id endianess field
+  static std::string normalizeSize(const std::string &nm);		///< Try to recover a \e language \e id size field
+  static std::string normalizeArchitecture(const std::string &nm);	///< Try to recover a \e language \e id string
+  static void scanForSleighDirectories(const std::string &rootpath);
+  static const std::vector<LanguageDescription> &getDescriptions(void);	///< Get list of all known language descriptions
   static void shutdown(void);					///< Shutdown all Translate objects and free global resources.
   static FileManage specpaths;					///< Known directories that contain .ldefs files.
 };
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
index 6b170df8e..4511dbb65 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.cc
@@ -15,6 +15,8 @@
  */
 #include "sleighbase.hh"
 
+using namespace std;
+
 const int4 SleighBase::SLA_FORMAT_VERSION = 3;
 
 const uint4 SleighBase::MAX_UNIQUE_SIZE = 128;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.hh
index 560c5a203..0f96de8c6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighbase.hh
@@ -36,16 +36,16 @@ class SourceFileIndexer {
   SourceFileIndexer() {leastUnusedIndex = 0;}
   ~SourceFileIndexer(void) { }
   ///Returns the index of the file.  If the file is not in the index it is added.
-  int4 index(const string filename);
-  int4 getIndex(const string);	///< get the index of a file.  Error if the file is not in the index.
-  string getFilename(int4);	///< get the filename corresponding to an index
+  int4 index(const std::string filename);
+  int4 getIndex(const std::string);	///< get the index of a file.  Error if the file is not in the index.
+  std::string getFilename(int4);	///< get the filename corresponding to an index
   void restoreXml(const Element *el);	///< read a stored index mapping from an XML file
-  void saveXml(ostream&) const;		///< save the index mapping to an XML file
+  void saveXml(std::ostream&) const;		///< save the index mapping to an XML file
 
 private:
   int4 leastUnusedIndex;  ///< one-up count for assigning indices to files
-  map<int4, string> indexToFile;  ///< map from indices to files
-  map<string, int4> fileToIndex;  ///< map from files to indices
+  std::map<int4, std::string> indexToFile;  ///< map from indices to files
+  std::map<std::string, int4> fileToIndex;  ///< map from files to indices
 };
 
 /// \brief Common core of classes that read or write SLEIGH specification files natively.
@@ -56,8 +56,8 @@ class SourceFileIndexer {
 ///   - Building and writing out SLEIGH specification files
 class SleighBase : public Translate {
   static const int4 SLA_FORMAT_VERSION;	///< Current version of the .sla file read/written by SleighBash
-  vector<string> userop;		///< Names of user-define p-code ops for \b this Translate object
-  map<VarnodeData,string> varnode_xref;	///< A map from Varnodes in the \e register space to register names
+  std::vector<std::string> userop;		///< Names of user-define p-code ops for \b this Translate object
+  std::map<VarnodeData,std::string> varnode_xref;	///< A map from Varnodes in the \e register space to register names
 protected:
   SubtableSymbol *root;		///< The root SLEIGH decoding symbol
   SymbolTable symtab;		///< The SLEIGH symbol table
@@ -65,7 +65,7 @@ class SleighBase : public Translate {
   uint4 unique_allocatemask;	///< Bits that are guaranteed to be zero in the unique allocation scheme
   uint4 numSections;		///< Number of \e named sections
   SourceFileIndexer indexer;    ///< source file index used when generating SLEIGH constructor debug info
-  void buildXrefs(vector<string> &errorPairs);	///< Build register map. Collect user-ops and context-fields.
+  void buildXrefs(std::vector<std::string> &errorPairs);	///< Build register map. Collect user-ops and context-fields.
   void reregisterContext(void);	///< Reregister context fields for a new executable
   void restoreXml(const Element *el);	///< Read a SLEIGH specification from XML
 public:
@@ -73,15 +73,15 @@ class SleighBase : public Translate {
   SleighBase(void);		///< Construct an uninitialized translator
   bool isInitialized(void) const { return (root != (SubtableSymbol *)0); }	///< Return \b true if \b this is initialized
   virtual ~SleighBase(void) {}	///< Destructor
-  virtual const VarnodeData &getRegister(const string &nm) const;
-  virtual string getRegisterName(AddrSpace *base,uintb off,int4 size) const;
-  virtual void getAllRegisters(map<VarnodeData,string> &reglist) const;
-  virtual void getUserOpNames(vector<string> &res) const;
+  virtual const VarnodeData &getRegister(const std::string &nm) const;
+  virtual std::string getRegisterName(AddrSpace *base,uintb off,int4 size) const;
+  virtual void getAllRegisters(std::map<VarnodeData,std::string> &reglist) const;
+  virtual void getUserOpNames(std::vector<std::string> &res) const;
 
-  SleighSymbol *findSymbol(const string &nm) const { return symtab.findSymbol(nm); }	///< Find a specific SLEIGH symbol by name in the current scope
+  SleighSymbol *findSymbol(const std::string &nm) const { return symtab.findSymbol(nm); }	///< Find a specific SLEIGH symbol by name in the current scope
   SleighSymbol *findSymbol(uintm id) const { return symtab.findSymbol(id); }	///< Find a specific SLEIGH symbol by id
-  SleighSymbol *findGlobalSymbol(const string &nm) const { return symtab.findGlobalSymbol(nm); }	///< Find a specific global SLEIGH symbol by name
-  void saveXml(ostream &s) const;	///< Write out the SLEIGH specification as an XML \<sleigh> tag.
+  SleighSymbol *findGlobalSymbol(const std::string &nm) const { return symtab.findGlobalSymbol(nm); }	///< Find a specific global SLEIGH symbol by name
+  void saveXml(std::ostream &s) const;	///< Write out the SLEIGH specification as an XML \<sleigh> tag.
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighexample.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighexample.cc
index 87a4d7980..3ed0c3390 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleighexample.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleighexample.cc
@@ -22,6 +22,8 @@
 #include "emulate.hh"
 #include <iostream>
 
+using namespace std;
+
 // These are the bytes for an example x86 binary
 // These bytes are loaded at address 0x80483b4
 static uint1 myprog[] = {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index 40d731480..2c8eefab7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -17,6 +17,8 @@
 #include "filemanage.hh"
 #include <csignal>
 
+using namespace std;
+
 SleighCompile *slgh;		// Global pointer to sleigh object for use with parser
 #ifdef YYDEBUG
 extern int yydebug;		// Global debugging state for parser
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
index 8fd9ba2fd..c4971d04e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.hh
@@ -51,7 +51,7 @@ struct RtlPair {
 class SectionVector {
   int4 nextindex;		///< Index of the section currently being parsed.
   RtlPair main;			///< The main section
-  vector<RtlPair> named;	///< Named sections accessed by index
+  std::vector<RtlPair> named;	///< Named sections accessed by index
 public:
   SectionVector(ConstructTpl *rtl,SymbolScope *scope);					///< Constructor
   ConstructTpl *getMainSection(void) const { return main.section; }			///< Get the \e main section
@@ -73,12 +73,12 @@ struct SpaceQuality {
     ramtype,		///< An address space representing normal, indexed, memory
     registertype	///< An address space containing registers
   };
-  string name;		///< Name of the address space
+  std::string name;		///< Name of the address space
   uint4 type;		///< Type of address space, \e ramtype or \e registertype
   uint4 size;		///< Number of bytes required to index all bytes of the space
   uint4 wordsize;       ///< Number of bytes in an addressable unit of the space
   bool isdefault;	///< \b true if the new address space will be the default
-  SpaceQuality(const string &nm);	///< Constructor
+  SpaceQuality(const std::string &nm);	///< Constructor
 };
 
 /// \brief Qualities associated (via parsing) with a token or context \b field
@@ -87,13 +87,13 @@ struct SpaceQuality {
 /// are parsed in of a \b define \b token block prior to formally allocating the
 /// TokenField or FieldContext object.
 struct FieldQuality {
-  string name;		///< Name of the field
+  std::string name;		///< Name of the field
   uint4 low;		///< The least significant bit of the field within the token
   uint4 high;		///< The most significant bit of the field within the token
   bool signext;		///< \b true if the field's value is signed
   bool flow;		///< \b true if the context \b flows for this field.
   bool hex;		///< \b true if the field value is displayed in hex
-  FieldQuality(string *nm,uintb *l,uintb *h);	///< Constructor
+  FieldQuality(std::string *nm,uintb *l,uintb *h);	///< Constructor
 };
 
 /// \brief Subtable, pattern, and context information applied across a \b with block
@@ -104,14 +104,14 @@ struct FieldQuality {
 class WithBlock {
   SubtableSymbol *ss;			///< Subtable containing each Constructor (or null for root table)
   PatternEquation *pateq;		///< Pattern to prepend to each Constructor (or null)
-  vector<ContextChange *> contvec;	///< Context change to associate with each constructor (or null)
+  std::vector<ContextChange *> contvec;	///< Context change to associate with each constructor (or null)
 public:
   WithBlock(void) { pateq = (PatternEquation *)0; }	///< Constructor
-  void set(SubtableSymbol *s, PatternEquation *pq, vector<ContextChange *> *cvec);	///< Set components of the header
+  void set(SubtableSymbol *s, PatternEquation *pq, std::vector<ContextChange *> *cvec);	///< Set components of the header
   ~WithBlock(void);	///< Destructor
-  static PatternEquation *collectAndPrependPattern(const list<WithBlock> &stack, PatternEquation *pateq);
-  static vector<ContextChange *> *collectAndPrependContext(const list<WithBlock> &stack, vector<ContextChange *> *contvec);
-  static SubtableSymbol *getCurrentSubtable(const list<WithBlock> &stack);
+  static PatternEquation *collectAndPrependPattern(const std::list<WithBlock> &stack, PatternEquation *pateq);
+  static std::vector<ContextChange *> *collectAndPrependContext(const std::list<WithBlock> &stack, std::vector<ContextChange *> *contvec);
+  static SubtableSymbol *getCurrentSubtable(const std::list<WithBlock> &stack);
 };
 
 class SleighCompile;
@@ -161,11 +161,11 @@ class ConsistencyChecker {
   bool printdeadwarning;	///< Set to \b true if warning emitted for each written but not read temporary
   bool printlargetempwarning;	///< Set to \b true if warning emitted for each too large temporary
   SubtableSymbol *root_symbol;	///< The root symbol table for the parsed SLEIGH file
-  vector<SubtableSymbol *> postorder;	///< Subtables sorted into \e post order (dependent tables listed earlier)
-  map<SubtableSymbol *,int4> sizemap;	///< Sizes associated with table \e exports
+  std::vector<SubtableSymbol *> postorder;	///< Subtables sorted into \e post order (dependent tables listed earlier)
+  std::map<SubtableSymbol *,int4> sizemap;	///< Sizes associated with table \e exports
   OperandSymbol *getOperandSymbol(int4 slot,OpTpl *op,Constructor *ct);
-  void printOpName(ostream &s,OpTpl *op);
-  void printOpError(OpTpl *op,Constructor *ct,int4 err1,int4 err2,const string &message);
+  void printOpName(std::ostream &s,OpTpl *op);
+  void printOpError(OpTpl *op,Constructor *ct,int4 err1,int4 err2,const std::string &message);
   int4 recoverSize(const ConstTpl &sizeconst,Constructor *ct);
   bool checkOpMisuse(OpTpl *op,Constructor *ct);
   bool sizeRestriction(OpTpl *op,Constructor *ct);
@@ -180,14 +180,14 @@ class ConsistencyChecker {
   void setPostOrder(SubtableSymbol *root);
 
   // Optimization routines
-  static void examineVn(map<uintb,OptimizeRecord> &recs,const VarnodeTpl *vn,uint4 i,int4 inslot,int4 secnum);
+  static void examineVn(std::map<uintb,OptimizeRecord> &recs,const VarnodeTpl *vn,uint4 i,int4 inslot,int4 secnum);
   static bool possibleIntersection(const VarnodeTpl *vn1,const VarnodeTpl *vn2);
   bool readWriteInterference(const VarnodeTpl *vn,const OpTpl *op,bool checkread) const;
-  void optimizeGather1(Constructor *ct,map<uintb,OptimizeRecord> &recs,int4 secnum) const;
-  void optimizeGather2(Constructor *ct,map<uintb,OptimizeRecord> &recs,int4 secnum) const;
-  const OptimizeRecord *findValidRule(Constructor *ct,const map<uintb,OptimizeRecord> &recs) const;
+  void optimizeGather1(Constructor *ct,std::map<uintb,OptimizeRecord> &recs,int4 secnum) const;
+  void optimizeGather2(Constructor *ct,std::map<uintb,OptimizeRecord> &recs,int4 secnum) const;
+  const OptimizeRecord *findValidRule(Constructor *ct,const std::map<uintb,OptimizeRecord> &recs) const;
   void applyOptimization(Constructor *ct,const OptimizeRecord &rec);
-  void checkUnusedTemps(Constructor *ct,const map<uintb,OptimizeRecord> &recs);
+  void checkUnusedTemps(Constructor *ct,const std::map<uintb,OptimizeRecord> &recs);
   void checkLargeTemporaries(Constructor *ct,ConstructTpl *ctpl);
   void optimize(Constructor *ct);
 public:
@@ -224,14 +224,14 @@ struct FieldContext {
 class MacroBuilder : public PcodeBuilder {
   SleighCompile *slgh;		///< The SLEIGH parsing object
   bool haserror;		///< Set to \b true by the build() method if there was an error
-  vector<OpTpl *> &outvec;	///< The partial list of op templates to expand the macro into
-  vector<HandleTpl *> params;	///< List of parameters to substitute into the macro
-  bool transferOp(OpTpl *op,vector<HandleTpl *> &params);
+  std::vector<OpTpl *> &outvec;	///< The partial list of op templates to expand the macro into
+  std::vector<HandleTpl *> params;	///< List of parameters to substitute into the macro
+  bool transferOp(OpTpl *op,std::vector<HandleTpl *> &params);
   virtual void dump( OpTpl *op );
   void free(void);						///< Free resources used by the builder
-  void reportError(const Location* loc, const string &val);	///< Report error encountered expanding the macro
+  void reportError(const Location* loc, const std::string &val);	///< Report error encountered expanding the macro
 public:
-  MacroBuilder(SleighCompile *sl,vector<OpTpl *> &ovec,uint4 lbcnt) : PcodeBuilder(lbcnt),outvec(ovec) {
+  MacroBuilder(SleighCompile *sl,std::vector<OpTpl *> &ovec,uint4 lbcnt) : PcodeBuilder(lbcnt),outvec(ovec) {
     slgh = sl; haserror = false; }					///< Constructor
   void setMacroOp(OpTpl *macroop);					///< Establish the MACRO directive to expand
   bool hasError(void) const { return haserror; }			///< Return \b true if there were errors during expansion
@@ -251,8 +251,8 @@ class SleighPcode : public PcodeCompile {
   SleighCompile *compiler;			///< The main SLEIGH parser
   virtual uint4 allocateTemp(void);
   virtual const Location *getLocation(SleighSymbol *sym) const;
-  virtual void reportError(const Location* loc, const string &msg);
-  virtual void reportWarning(const Location* loc, const string &msg);
+  virtual void reportError(const Location* loc, const std::string &msg);
+  virtual void reportWarning(const Location* loc, const std::string &msg);
   virtual void addSymbol(SleighSymbol *sym);
 public:
   SleighPcode(void) : PcodeCompile() { compiler = (SleighCompile *)0; }	///< Constructor
@@ -272,21 +272,21 @@ class SleighCompile : public SleighBase {
 public:
   SleighPcode pcode;			///< The p-code parsing (sub)engine
 private:
-  map<string,string> preproc_defines;	///< Defines for the preprocessor
-  vector<FieldContext> contexttable;	///< Context field definitions (prior to defining ContextField and ContextSymbol)
-  vector<ConstructTpl *> macrotable;	///< SLEIGH macro definitions
-  vector<Token *> tokentable;		///< SLEIGH token definitions
-  vector<SubtableSymbol *> tables;	///< SLEIGH subtables
-  vector<SectionSymbol *> sections;	///< Symbols defining Constructor sections
-  list<WithBlock> withstack;		///< Current stack of \b with blocks
+  std::map<std::string,std::string> preproc_defines;	///< Defines for the preprocessor
+  std::vector<FieldContext> contexttable;	///< Context field definitions (prior to defining ContextField and ContextSymbol)
+  std::vector<ConstructTpl *> macrotable;	///< SLEIGH macro definitions
+  std::vector<Token *> tokentable;		///< SLEIGH token definitions
+  std::vector<SubtableSymbol *> tables;	///< SLEIGH subtables
+  std::vector<SectionSymbol *> sections;	///< Symbols defining Constructor sections
+  std::list<WithBlock> withstack;		///< Current stack of \b with blocks
   Constructor *curct;			///< Current Constructor being defined
   MacroSymbol *curmacro;		///< Current macro being defined
   bool contextlock;			///< If the context layout has been established yet
-  vector<string> relpath;		///< Relative path (to cwd) for each filename
-  vector<string> filename;		///< Stack of current files being parsed
-  vector<int4> lineno;			///< Current line number for each file in stack
-  map<Constructor *, Location> ctorLocationMap;		///< Map each Constructor to its defining parse location
-  map<SleighSymbol *, Location> symbolLocationMap;	///< Map each symbol to its defining parse location
+  std::vector<std::string> relpath;		///< Relative path (to cwd) for each filename
+  std::vector<std::string> filename;		///< Stack of current files being parsed
+  std::vector<int4> lineno;			///< Current line number for each file in stack
+  std::map<Constructor *, Location> ctorLocationMap;		///< Map each Constructor to its defining parse location
+  std::map<SleighSymbol *, Location> symbolLocationMap;	///< Map each symbol to its defining parse location
   int4 userop_count;			///< Number of userops defined
   bool warnunnecessarypcode;		///< \b true if we warn of unnecessary ZEXT or SEXT
   bool warndeadtemps;			///< \b true if we warn of temporaries that are written but not read
@@ -295,7 +295,7 @@ class SleighCompile : public SleighBase {
   bool warnalllocalcollisions;		///< \b true if local export collisions generate individual warnings
   bool warnallnops;			///< \b true if pcode NOPs generate individual warnings
   bool failinsensitivedups;		///< \b true if case insensitive register duplicates cause error
-  vector<string> noplist;		///< List of individual NOP warnings
+  std::vector<std::string> noplist;		///< List of individual NOP warnings
   mutable Location currentLocCache;	///< Location for (last) request of current location
   int4 errors;				///< Number of fatal errors encountered
 
@@ -305,14 +305,14 @@ class SleighCompile : public SleighBase {
   void buildDecisionTrees(void);			///< Build decision trees for all subtables
   void buildPatterns(void);		///< Generate final match patterns based on parse constraint equations
   void checkConsistency(void);		///< Perform final consistency checks on the SLEIGH definitions
-  static int4 findCollision(map<uintb,int4> &local2Operand,const vector<uintb> &locals,int operand);
+  static int4 findCollision(std::map<uintb,int4> &local2Operand,const std::vector<uintb> &locals,int operand);
   bool checkLocalExports(Constructor *ct);	///< Check for operands that \e might export the same local variable
   void checkLocalCollisions(void);	///< Check all Constructors for local export collisions between operands
   void checkNops(void);			///< Report on all Constructors with empty semantic sections
   void checkCaseSensitivity(void);	///< Check that register names can be treated as case insensitive
-  string checkSymbols(SymbolScope *scope);	///< Make sure label symbols are both defined and used
+  std::string checkSymbols(SymbolScope *scope);	///< Make sure label symbols are both defined and used
   void addSymbol(SleighSymbol *sym);	///< Add a new symbol to the current scope
-  SleighSymbol *dedupSymbolList(vector<SleighSymbol *> *symlist);	///< Deduplicate the given list of symbols
+  SleighSymbol *dedupSymbolList(std::vector<SleighSymbol *> *symlist);	///< Deduplicate the given list of symbols
   bool expandMacros(ConstructTpl *ctpl);	///< Expand any formal SLEIGH macros in the given section of p-code
 
   bool finalizeSections(Constructor *big,SectionVector *vec);	///< Do final checks, expansions, and linking for p-code sections
@@ -322,17 +322,17 @@ class SleighCompile : public SleighBase {
   static void shiftUniqueOp(OpTpl *op,int4 sa);
   static void shiftUniqueHandle(HandleTpl *hand,int4 sa);
   static void shiftUniqueConstruct(ConstructTpl *tpl,int4 sa);
-  static string formatStatusMessage(const Location* loc, const string &msg);
+  static std::string formatStatusMessage(const Location* loc, const std::string &msg);
   void checkUniqueAllocation(void);	///< Modify temporary Varnode offsets to support \b crossbuilds
   void process(void);			///< Do all post processing on the parsed data structures
 public:
   SleighCompile(void);						///< Constructor
   const Location *getLocation(Constructor* ctor) const;		///< Get the source location of the given Constructor's definition
   const Location *getLocation(SleighSymbol *sym) const;		///< Get the source location of the given symbol's definition
-  void reportError(const string &msg);				///< Issue a fatal error message
-  void reportError(const Location *loc, const string &msg);	///< Issue a fatal error message with a source location
-  void reportWarning(const string &msg);			///< Issue a warning message
-  void reportWarning(const Location *loc, const string &msg);	///< Issue a warning message with a source location
+  void reportError(const std::string &msg);				///< Issue a fatal error message
+  void reportError(const Location *loc, const std::string &msg);	///< Issue a fatal error message with a source location
+  void reportWarning(const std::string &msg);			///< Issue a warning message
+  void reportWarning(const Location *loc, const std::string &msg);	///< Issue a warning message with a source location
   int4 numErrors(void) const { return errors; }			///< Return the current number of fatal errors
 
   uint4 getUniqueAddr(void);					///< Get the next available temporary register offset
@@ -379,21 +379,21 @@ class SleighCompile : public SleighBase {
 
   // Lexer functions
   void calcContextLayout(void);				///< Calculate the internal context field layout
-  string grabCurrentFilePath(void) const;		///< Get the path to the current source file
-  void parseFromNewFile(const string &fname);		///< Push a new source file to the current parse stack
+  std::string grabCurrentFilePath(void) const;		///< Get the path to the current source file
+  void parseFromNewFile(const std::string &fname);		///< Push a new source file to the current parse stack
   void parsePreprocMacro(void);				///< Mark start of parsing for an expanded preprocessor macro
   void parseFileFinished(void);				///< Mark end of parsing for the current file or macro
   void nextLine(void) { lineno.back() += 1; }		///< Indicate parsing proceeded to the next line of the current file
-  bool getPreprocValue(const string &nm,string &res) const;	///< Retrieve a given preprocessor variable
-  void setPreprocValue(const string &nm,const string &value);	///< Set a given preprocessor variable
-  bool undefinePreprocValue(const string &nm);		///< Remove the value associated with the given preprocessor variable
+  bool getPreprocValue(const std::string &nm,std::string &res) const;	///< Retrieve a given preprocessor variable
+  void setPreprocValue(const std::string &nm,const std::string &value);	///< Set a given preprocessor variable
+  bool undefinePreprocValue(const std::string &nm);		///< Remove the value associated with the given preprocessor variable
 
   // Parser functions
-  TokenSymbol *defineToken(string *name,uintb *sz,int4 endian);
+  TokenSymbol *defineToken(std::string *name,uintb *sz,int4 endian);
   void addTokenField(TokenSymbol *sym,FieldQuality *qual);
   bool addContextField(VarnodeSymbol *sym,FieldQuality *qual);
   void newSpace(SpaceQuality *qual);
-  SectionSymbol *newSectionSymbol(const string &nm);
+  SectionSymbol *newSectionSymbol(const std::string &nm);
   void setEndian(int4 end);
 
   /// \brief Set instruction alignment for the SLEIGH specification
@@ -401,36 +401,36 @@ class SleighCompile : public SleighBase {
   /// \param val is the alignment value in bytes. 1 is the default indicating no alignment
   void setAlignment(int4 val) { alignment = val; }
 
-  void defineVarnodes(SpaceSymbol *spacesym,uintb *off,uintb *size,vector<string> *names);
-  void defineBitrange(string *name,VarnodeSymbol *sym,uint4 bitoffset,uint4 numb);
-  void addUserOp(vector<string> *names);
-  void attachValues(vector<SleighSymbol *> *symlist,vector<intb> *numlist);
-  void attachNames(vector<SleighSymbol *> *symlist,vector<string> *names);
-  void attachVarnodes(vector<SleighSymbol *> *symlist,vector<SleighSymbol *> *varlist);
-  SubtableSymbol *newTable(string *nm);
-  void newOperand(Constructor *ct,string *nm);
+  void defineVarnodes(SpaceSymbol *spacesym,uintb *off,uintb *size,std::vector<std::string> *names);
+  void defineBitrange(std::string *name,VarnodeSymbol *sym,uint4 bitoffset,uint4 numb);
+  void addUserOp(std::vector<std::string> *names);
+  void attachValues(std::vector<SleighSymbol *> *symlist,std::vector<intb> *numlist);
+  void attachNames(std::vector<SleighSymbol *> *symlist,std::vector<std::string> *names);
+  void attachVarnodes(std::vector<SleighSymbol *> *symlist,std::vector<SleighSymbol *> *varlist);
+  SubtableSymbol *newTable(std::string *nm);
+  void newOperand(Constructor *ct,std::string *nm);
   PatternEquation *constrainOperand(OperandSymbol *sym,PatternExpression *patexp);
   void defineOperand(OperandSymbol *sym,PatternExpression *patexp);
   PatternEquation *defineInvisibleOperand(TripleSymbol *sym);
   void selfDefine(OperandSymbol *sym);
   ConstructTpl *setResultVarnode(ConstructTpl *ct,VarnodeTpl *vn);
   ConstructTpl *setResultStarVarnode(ConstructTpl *ct,StarQuality *star,VarnodeTpl *vn);
-  bool contextMod(vector<ContextChange *> *vec,ContextSymbol *sym,PatternExpression *pe);
-  void contextSet(vector<ContextChange *> *vec,TripleSymbol *sym,ContextSymbol *cvar);
-  MacroSymbol *createMacro(string *name,vector<string> *param);
-  void compareMacroParams(MacroSymbol *sym,const vector<ExprTree *> &param);
-  vector<OpTpl *> *createMacroUse(MacroSymbol *sym,vector<ExprTree *> *param);
+  bool contextMod(std::vector<ContextChange *> *vec,ContextSymbol *sym,PatternExpression *pe);
+  void contextSet(std::vector<ContextChange *> *vec,TripleSymbol *sym,ContextSymbol *cvar);
+  MacroSymbol *createMacro(std::string *name,std::vector<std::string> *param);
+  void compareMacroParams(MacroSymbol *sym,const std::vector<ExprTree *> &param);
+  std::vector<OpTpl *> *createMacroUse(MacroSymbol *sym,std::vector<ExprTree *> *param);
   SectionVector *standaloneSection(ConstructTpl *main);
   SectionVector *firstNamedSection(ConstructTpl *main,SectionSymbol *sym);
   SectionVector *nextNamedSection(SectionVector *vec,ConstructTpl *section,SectionSymbol *sym);
   SectionVector *finalNamedSection(SectionVector *vec,ConstructTpl *section);
-  vector<OpTpl *> *createCrossBuild(VarnodeTpl *addr,SectionSymbol *sym);
+  std::vector<OpTpl *> *createCrossBuild(VarnodeTpl *addr,SectionSymbol *sym);
   Constructor *createConstructor(SubtableSymbol *sym);
   bool isInRoot(Constructor *ct) const { return (root == ct->getParent()); }	///< Is the Constructor in the root table?
   void resetConstructors(void);
-  void pushWith(SubtableSymbol *ss,PatternEquation *pateq,vector<ContextChange *> *contvec);
+  void pushWith(SubtableSymbol *ss,PatternEquation *pateq,std::vector<ContextChange *> *contvec);
   void popWith(void);
-  void buildConstructor(Constructor *big,PatternEquation *pateq,vector<ContextChange *> *contvec,SectionVector *vec);
+  void buildConstructor(Constructor *big,PatternEquation *pateq,std::vector<ContextChange *> *contvec,SectionVector *vec);
   void buildMacro(MacroSymbol *sym,ConstructTpl *rtl);
   void recordNop(void);
 
@@ -440,11 +440,11 @@ class SleighCompile : public SleighBase {
   virtual int4 oneInstruction(PcodeEmit &emit,const Address &baseaddr) const { return 0; }
   virtual int4 printAssembly(AssemblyEmit &emit,const Address &baseaddr) const { return 0; }
 
-  void setAllOptions(const map<string,string> &defines, bool unnecessaryPcodeWarning,
+  void setAllOptions(const std::map<std::string,std::string> &defines, bool unnecessaryPcodeWarning,
 		     bool lenientConflict, bool allCollisionWarning,
 		     bool allNopWarning,bool deadTempWarning,bool enforceLocalKeyWord,
 		     bool largeTemporaryWarning, bool caseSensitiveRegisterNames);
-  int4 run_compilation(const string &filein,const string &fileout);
+  int4 run_compilation(const std::string &filein,const std::string &fileout);
 };
 
 extern SleighCompile *slgh;		///< A global reference to the SLEIGH compiler accessible to the parse functions
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
index 746d70a81..bd4aa1b77 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.cc
@@ -81,6 +81,8 @@
 
 #include "slgh_compile.hh"
 
+using namespace std;
+
 #define YYERROR_VERBOSE
 
   extern SleighCompile *slgh;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
index f52fe7abb..4bc7f292d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.hh
@@ -185,24 +185,24 @@ union YYSTYPE
   char ch;
   uintb *i;
   intb *big;
-  string *str;
-  vector<string> *strlist;
-  vector<intb> *biglist;
-  vector<ExprTree *> *param;
+  std::string *str;
+  std::vector<std::string> *strlist;
+  std::vector<intb> *biglist;
+  std::vector<ExprTree *> *param;
   SpaceQuality *spacequal;
   FieldQuality *fieldqual;
   StarQuality *starqual;
   VarnodeTpl *varnode;
   ExprTree *tree;
-  vector<OpTpl *> *stmt;
+  std::vector<OpTpl *> *stmt;
   ConstructTpl *sem;
   SectionVector *sectionstart;
   Constructor *construct;
   PatternEquation *pateq;
   PatternExpression *patexp;
 
-  vector<SleighSymbol *> *symlist;
-  vector<ContextChange *> *contop;
+  std::vector<SleighSymbol *> *symlist;
+  std::vector<ContextChange *> *contop;
   SleighSymbol *anysym;
   SpaceSymbol *spacesym;
   SectionSymbol *sectionsym;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.y
index b3fedb7b6..0e2172f79 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghparse.y
@@ -16,6 +16,8 @@
 %{
 #include "slgh_compile.hh"
 
+using namespace std;
+
 #define YYERROR_VERBOSE
 
   extern SleighCompile *slgh;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
index 3b7534f09..f6f4f029d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
@@ -16,6 +16,8 @@
 #include "slghpatexpress.hh"
 #include "sleighbase.hh"
 
+using namespace std;
+
 int4 TokenPattern::resolveTokens(const TokenPattern &tok1,const TokenPattern &tok2)
 
 {				// Use the token lists to decide how the two patterns
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
index 8c748c2ce..7aa030a45 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
@@ -20,7 +20,7 @@
 
 class TokenPattern {
   Pattern *pattern;
-  vector<Token *> toklist;
+  std::vector<Token *> toklist;
   bool leftellipsis;
   bool rightellipsis;
   static PatternBlock *buildSingle(int4 startbit,int4 endbit,uintm byteval);
@@ -61,13 +61,13 @@ class PatternExpression {
 public:
   PatternExpression(void) { refcount = 0; }
   virtual intb getValue(ParserWalker &walker) const=0;
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const=0;
-  virtual void listValues(vector<const PatternValue *> &list) const=0;
-  virtual void getMinMax(vector<intb> &minlist,vector<intb> &maxlist) const=0;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const=0;
-  virtual void saveXml(ostream &s) const=0;
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const=0;
+  virtual void listValues(std::vector<const PatternValue *> &list) const=0;
+  virtual void getMinMax(std::vector<intb> &minlist,std::vector<intb> &maxlist) const=0;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const=0;
+  virtual void saveXml(std::ostream &s) const=0;
   virtual void restoreXml(const Element *el,Translate *trans)=0;
-  intb getSubValue(const vector<intb> &replace) {
+  intb getSubValue(const std::vector<intb> &replace) {
     int4 listpos = 0;
     return getSubValue(replace,listpos); }
   void layClaim(void) { refcount += 1; }
@@ -78,10 +78,10 @@ class PatternExpression {
 class PatternValue : public PatternExpression {
 public:
   virtual TokenPattern genPattern(intb val) const=0;
-  virtual void listValues(vector<const PatternValue *> &list) const { list.push_back(this); }
-  virtual void getMinMax(vector<intb> &minlist,vector<intb> &maxlist) const { 
+  virtual void listValues(std::vector<const PatternValue *> &list) const { list.push_back(this); }
+  virtual void getMinMax(std::vector<intb> &minlist,std::vector<intb> &maxlist) const {
     minlist.push_back(minValue()); maxlist.push_back(maxValue()); }
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const { return replace[listpos++]; }
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const { return replace[listpos++]; }
   virtual intb minValue(void) const=0;
   virtual intb maxValue(void) const=0;
 };
@@ -97,11 +97,11 @@ class TokenField : public PatternValue {
   TokenField(void) {}		// For use with restoreXml
   TokenField(Token *tk,bool s,int4 bstart,int4 bend);
   virtual intb getValue(ParserWalker &walker) const;
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(tok); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(tok); }
   virtual TokenPattern genPattern(intb val) const;
   virtual intb minValue(void) const { return 0; }
   virtual intb maxValue(void) const { intb res=0; res=~res; zero_extend(res,bitend-bitstart); return res; }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };
 
@@ -117,11 +117,11 @@ class ContextField : public PatternValue {
   int4 getEndBit(void) const { return endbit; }
   bool getSignBit(void) const { return signbit; }
   virtual intb getValue(ParserWalker &walker) const;
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
   virtual TokenPattern genPattern(intb val) const;
   virtual intb minValue(void) const { return 0; }
   virtual intb maxValue(void) const { intb res=0; res=~res; zero_extend(res,(endbit-startbit)); return res; }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };
 
@@ -131,11 +131,11 @@ class ConstantValue : public PatternValue {
   ConstantValue(void) {}	// For use with restoreXml
   ConstantValue(intb v) { val = v; }
   virtual intb getValue(ParserWalker &walker) const { return val; }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
   virtual TokenPattern genPattern(intb v) const { return TokenPattern(val==v); }
   virtual intb minValue(void) const { return val; }
   virtual intb maxValue(void) const { return val; }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };
 
@@ -144,11 +144,11 @@ class StartInstructionValue : public PatternValue {
   StartInstructionValue(void) {}
   virtual intb getValue(ParserWalker &walker) const {
     return (intb)AddrSpace::byteToAddress(walker.getAddr().getOffset(),walker.getAddr().getSpace()->getWordSize()); }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
   virtual TokenPattern genPattern(intb val) const { return TokenPattern(); }
   virtual intb minValue(void) const { return (intb)0; }
   virtual intb maxValue(void) const { return (intb)0; }
-  virtual void saveXml(ostream &s) const { s << "<start_exp/>"; }
+  virtual void saveXml(std::ostream &s) const { s << "<start_exp/>"; }
   virtual void restoreXml(const Element *el,Translate *trans) {}
 };
                                                                                         
@@ -157,11 +157,11 @@ class EndInstructionValue : public PatternValue {
   EndInstructionValue(void) {}
   virtual intb getValue(ParserWalker &walker) const {
     return (intb)AddrSpace::byteToAddress(walker.getNaddr().getOffset(),walker.getNaddr().getSpace()->getWordSize()); }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
   virtual TokenPattern genPattern(intb val) const { return TokenPattern(); }
   virtual intb minValue(void) const { return (intb)0; }
   virtual intb maxValue(void) const { return (intb)0; }
-  virtual void saveXml(ostream &s) const { s << "<end_exp/>"; }
+  virtual void saveXml(std::ostream &s) const { s << "<end_exp/>"; }
   virtual void restoreXml(const Element *el,Translate *trans) {}
 };
 
@@ -170,11 +170,11 @@ class Next2InstructionValue : public PatternValue {
   Next2InstructionValue(void) {}
   virtual intb getValue(ParserWalker &walker) const {
     return (intb)AddrSpace::byteToAddress(walker.getN2addr().getOffset(),walker.getN2addr().getSpace()->getWordSize()); }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
   virtual TokenPattern genPattern(intb val) const { return TokenPattern(); }
   virtual intb minValue(void) const { return (intb)0; }
   virtual intb maxValue(void) const { return (intb)0; }
-  virtual void saveXml(ostream &s) const { s << "<next2_exp/>"; }
+  virtual void saveXml(std::ostream &s) const { s << "<next2_exp/>"; }
   virtual void restoreXml(const Element *el,Translate *trans) {}
 };
 
@@ -188,14 +188,14 @@ class OperandValue : public PatternValue {
   OperandValue(int4 ind,Constructor *c) { index = ind; ct = c; }
   void changeIndex(int4 newind) { index = newind; }
   bool isConstructorRelative(void) const;
-  const string &getName(void) const;
+  const std::string &getName(void) const;
   virtual TokenPattern genPattern(intb val) const;
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return ops[index]; }
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return ops[index]; }
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
   virtual intb minValue(void) const;
   virtual intb maxValue(void) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };
 
@@ -208,12 +208,12 @@ class BinaryExpression : public PatternExpression {
   BinaryExpression(PatternExpression *l,PatternExpression *r);
   PatternExpression *getLeft(void) const { return left; }
   PatternExpression *getRight(void) const { return right; }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
-  virtual void listValues(vector<const PatternValue *> &list) const {
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual void listValues(std::vector<const PatternValue *> &list) const {
     left->listValues(list); right->listValues(list); }
-  virtual void getMinMax(vector<intb> &minlist,vector<intb> &maxlist) const {
+  virtual void getMinMax(std::vector<intb> &minlist,std::vector<intb> &maxlist) const {
     left->getMinMax(minlist,maxlist); right->getMinMax(minlist,maxlist); }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };
 
@@ -225,13 +225,13 @@ class UnaryExpression : public PatternExpression {
   UnaryExpression(void) { unary = (PatternExpression *)0; } // For use with restoreXml
   UnaryExpression(PatternExpression *u);
   PatternExpression *getUnary(void) const { return unary; }
-  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
-  virtual void listValues(vector<const PatternValue *> &list) const {
+  virtual TokenPattern genMinPattern(const std::vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual void listValues(std::vector<const PatternValue *> &list) const {
     unary->listValues(list); }
-  virtual void getMinMax(vector<intb> &minlist,vector<intb> &maxlist) const {
+  virtual void getMinMax(std::vector<intb> &minlist,std::vector<intb> &maxlist) const {
     unary->getMinMax(minlist,maxlist);
   }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,Translate *trans);
 };  
 
@@ -240,8 +240,8 @@ class PlusExpression : public BinaryExpression {
   PlusExpression(void) {}	// For use by restoreXml
   PlusExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
   
 class SubExpression : public BinaryExpression {
@@ -249,8 +249,8 @@ class SubExpression : public BinaryExpression {
   SubExpression(void) {}	// For use with restoreXml
   SubExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
   
 class MultExpression : public BinaryExpression {
@@ -258,8 +258,8 @@ class MultExpression : public BinaryExpression {
   MultExpression(void) {}	// For use with restoreXml
   MultExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
   
 class LeftShiftExpression : public BinaryExpression {
@@ -267,8 +267,8 @@ class LeftShiftExpression : public BinaryExpression {
   LeftShiftExpression(void) {}
   LeftShiftExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
 
 class RightShiftExpression : public BinaryExpression {
@@ -276,8 +276,8 @@ class RightShiftExpression : public BinaryExpression {
   RightShiftExpression(void) {}
   RightShiftExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
 
 class AndExpression : public BinaryExpression {
@@ -285,8 +285,8 @@ class AndExpression : public BinaryExpression {
   AndExpression(void) {}
   AndExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
   
 class OrExpression : public BinaryExpression {
@@ -294,8 +294,8 @@ class OrExpression : public BinaryExpression {
   OrExpression(void) {}
   OrExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
   
 class XorExpression : public BinaryExpression {
@@ -303,8 +303,8 @@ class XorExpression : public BinaryExpression {
   XorExpression(void) {}
   XorExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
 
 class DivExpression : public BinaryExpression {
@@ -312,8 +312,8 @@ class DivExpression : public BinaryExpression {
   DivExpression(void) {}
   DivExpression(PatternExpression *l,PatternExpression *r) : BinaryExpression(l,r) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };
 
 class MinusExpression : public UnaryExpression {
@@ -321,8 +321,8 @@ class MinusExpression : public UnaryExpression {
   MinusExpression(void) {}
   MinusExpression(PatternExpression *u) : UnaryExpression(u) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };  
 
 class NotExpression : public UnaryExpression {
@@ -330,13 +330,13 @@ class NotExpression : public UnaryExpression {
   NotExpression(void) {}
   NotExpression(PatternExpression *u) : UnaryExpression(u) {}
   virtual intb getValue(ParserWalker &walker) const;
-  virtual intb getSubValue(const vector<intb> &replace,int4 &listpos) const;
-  virtual void saveXml(ostream &s) const;
+  virtual intb getSubValue(const std::vector<intb> &replace,int4 &listpos) const;
+  virtual void saveXml(std::ostream &s) const;
 };  
 
 struct OperandResolve {
-  vector<OperandSymbol *> &operands;
-  OperandResolve(vector<OperandSymbol *> &ops) : operands(ops) {
+  std::vector<OperandSymbol *> &operands;
+  OperandResolve(std::vector<OperandSymbol *> &ops) : operands(ops) {
     base=-1; offset=0; cur_rightmost = -1; size = 0; }
   int4 base;		// Current base operand (as we traverse the pattern equation from left to right)
   int4 offset;		// Bytes we have traversed from the LEFT edge of the current base
@@ -354,9 +354,9 @@ class PatternEquation {
 public:
   PatternEquation(void) { refcount = 0; }
   const TokenPattern &getTokenPattern(void) const { return resultpattern; }
-  virtual void genPattern(const vector<TokenPattern> &ops) const=0;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const=0;
   virtual bool resolveOperandLeft(OperandResolve &state) const=0;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const {}
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const {}
   void layClaim(void) { refcount += 1; }
   static void release(PatternEquation *pateq);
 };
@@ -365,9 +365,9 @@ class OperandEquation : public PatternEquation { // Equation that defines operan
   int4 index;
 public:
   OperandEquation(int4 ind) { index = ind; }
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 class UnconstrainedEquation : public PatternEquation { // Unconstrained equation, just get tokens
@@ -376,7 +376,7 @@ class UnconstrainedEquation : public PatternEquation { // Unconstrained equation
   virtual ~UnconstrainedEquation(void);
 public:
   UnconstrainedEquation(PatternExpression *p);
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
 };
 
@@ -393,37 +393,37 @@ class ValExpressEquation : public PatternEquation {
 class EqualEquation : public ValExpressEquation {
 public:
   EqualEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class NotEqualEquation : public ValExpressEquation {
 public:
   NotEqualEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class LessEquation : public ValExpressEquation {
 public:
   LessEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class LessEqualEquation : public ValExpressEquation {
 public:
   LessEqualEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class GreaterEquation : public ValExpressEquation {
 public:
   GreaterEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class GreaterEqualEquation : public ValExpressEquation {
 public:
   GreaterEqualEquation(PatternValue *l,PatternExpression *r) : ValExpressEquation(l,r) {}
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
 };
 
 class EquationAnd : public PatternEquation { // Pattern Equations ANDed together
@@ -433,9 +433,9 @@ class EquationAnd : public PatternEquation { // Pattern Equations ANDed together
   virtual ~EquationAnd(void);
 public:
   EquationAnd(PatternEquation *l,PatternEquation *r);
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 class EquationOr : public PatternEquation { // Pattern Equations ORed together
@@ -445,9 +445,9 @@ class EquationOr : public PatternEquation { // Pattern Equations ORed together
   virtual ~EquationOr(void);
 public:
   EquationOr(PatternEquation *l,PatternEquation *r);
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 class EquationCat : public PatternEquation { // Pattern Equations concatenated
@@ -457,9 +457,9 @@ class EquationCat : public PatternEquation { // Pattern Equations concatenated
   virtual ~EquationCat(void);
 public:
   EquationCat(PatternEquation *l,PatternEquation *r);
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 class EquationLeftEllipsis : public PatternEquation { // Equation preceded by ellipses
@@ -468,9 +468,9 @@ class EquationLeftEllipsis : public PatternEquation { // Equation preceded by el
   virtual ~EquationLeftEllipsis(void) { PatternEquation::release(eq); }
 public:
   EquationLeftEllipsis(PatternEquation *e) { (eq=e)->layClaim(); }
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 class EquationRightEllipsis : public PatternEquation { // Equation preceded by ellipses
@@ -479,9 +479,9 @@ class EquationRightEllipsis : public PatternEquation { // Equation preceded by e
   virtual ~EquationRightEllipsis(void) { PatternEquation::release(eq); }
 public:
   EquationRightEllipsis(PatternEquation *e) { (eq=e)->layClaim(); }
-  virtual void genPattern(const vector<TokenPattern> &ops) const;
+  virtual void genPattern(const std::vector<TokenPattern> &ops) const;
   virtual bool resolveOperandLeft(OperandResolve &state) const;
-  virtual void operandOrder(Constructor *ct,vector<OperandSymbol *> &order) const;
+  virtual void operandOrder(Constructor *ct,std::vector<OperandSymbol *> &order) const;
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
index 4ebeaa000..9cb0803eb 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.cc
@@ -15,6 +15,8 @@
  */
 #include "slghpattern.hh"
 
+using namespace std;
+
 uintm DisjointPattern::getMask(int4 startbit,int4 size,bool context) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
index 05b98e00a..153164e9a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpattern.hh
@@ -22,14 +22,14 @@
 class PatternBlock {
   int4 offset;			// Offset to non-zero byte of mask
   int4 nonzerosize;		// Last byte(+1) containing nonzero mask
-  vector<uintm> maskvec;	// Mask
-  vector<uintm> valvec;		// Value
+  std::vector<uintm> maskvec;	// Mask
+  std::vector<uintm> valvec;		// Value
   void normalize(void);
 public:
   PatternBlock(int4 off,uintm msk,uintm val);
   PatternBlock(bool tf);
   PatternBlock(const PatternBlock *a,const PatternBlock *b);
-  PatternBlock(vector<PatternBlock *> &list);
+  PatternBlock(std::vector<PatternBlock *> &list);
   PatternBlock *commonSubPattern(const PatternBlock *b) const;
   PatternBlock *intersect(const PatternBlock *b) const;
   bool specializes(const PatternBlock *op2) const;
@@ -43,7 +43,7 @@ class PatternBlock {
   bool alwaysFalse(void) const { return (nonzerosize==-1); }
   bool isInstructionMatch(ParserWalker &walker) const;
   bool isContextMatch(ParserWalker &walker) const;
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el);
 };
 
@@ -62,7 +62,7 @@ class Pattern {
   virtual bool alwaysTrue(void) const=0;
   virtual bool alwaysFalse(void) const=0;
   virtual bool alwaysInstructionTrue(void) const=0;
-  virtual void saveXml(ostream &s) const=0;
+  virtual void saveXml(std::ostream &s) const=0;
   virtual void restoreXml(const Element *el)=0;
 };
 
@@ -98,7 +98,7 @@ class InstructionPattern : public DisjointPattern { // Matches the instruction b
   virtual bool alwaysTrue(void) const { return maskvalue->alwaysTrue(); }
   virtual bool alwaysFalse(void) const { return maskvalue->alwaysFalse(); }
   virtual bool alwaysInstructionTrue(void) const { return maskvalue->alwaysTrue(); }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el);
 };
 
@@ -119,7 +119,7 @@ class ContextPattern : public DisjointPattern { // Matches the context bitstream
   virtual bool alwaysTrue(void) const { return maskvalue->alwaysTrue(); }
   virtual bool alwaysFalse(void) const { return maskvalue->alwaysFalse(); }
   virtual bool alwaysInstructionTrue(void) const { return true; }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el);
 };
 
@@ -142,16 +142,16 @@ class CombinePattern : public DisjointPattern {
   virtual Pattern *doOr(const Pattern *b,int4 sa) const;
   virtual Pattern *doAnd(const Pattern *b,int4 sa) const;
   virtual Pattern *commonSubPattern(const Pattern *b,int4 sa) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el);
 };
 
 class OrPattern : public Pattern {
-  vector<DisjointPattern *> orlist;
+  std::vector<DisjointPattern *> orlist;
 public:
   OrPattern(void) {}		// For use with restoreXml
   OrPattern(DisjointPattern *a,DisjointPattern *b);
-  OrPattern(const vector<DisjointPattern *> &list);
+  OrPattern(const std::vector<DisjointPattern *> &list);
   virtual ~OrPattern(void);
   virtual Pattern *simplifyClone(void) const;
   virtual void shiftInstruction(int4 sa);
@@ -164,7 +164,7 @@ class OrPattern : public Pattern {
   virtual Pattern *doOr(const Pattern *b,int4 sa) const;
   virtual Pattern *doAnd(const Pattern *b,int4 sa) const;
   virtual Pattern *commonSubPattern(const Pattern *b,int4 sa) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el);
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
index 1ac87e2cd..20cbf21e4 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
@@ -888,6 +888,9 @@ char *yytext;
 #line 18 "slghscan.l"
 #include "slgh_compile.hh"
 #include "slghparse.hh"
+
+using namespace std;
+
 #define yywrap() 1
 #define YY_SKIP_YYWRAP
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
index 2df137019..f2341ef09 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
@@ -17,6 +17,9 @@
 %{
 #include "slgh_compile.hh"
 #include "slghparse.hh"
+
+using namespace std;
+
 #define yywrap() 1
 #define YY_SKIP_YYWRAP
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
index 85bd54261..22dc50d0d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
@@ -17,6 +17,8 @@
 #include "sleighbase.hh"
 #include <cmath>
 
+using namespace std;
+
 SleighSymbol *SymbolScope::addSymbol(SleighSymbol *a)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
index 82d95ffef..e07f85e2b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
@@ -29,19 +29,19 @@ class SleighSymbol {
                      bitrange_symbol, context_symbol, epsilon_symbol, label_symbol,
 		     dummy_symbol };
 private:
-  string name;
+  std::string name;
   uintm id;			// Unique id across all symbols
   uintm scopeid;		// Unique id of scope this symbol is in
 public:
   SleighSymbol(void) {}		// For use with restoreXml
-  SleighSymbol(const string &nm) { name = nm; id = 0; }
+  SleighSymbol(const std::string &nm) { name = nm; id = 0; }
   virtual ~SleighSymbol(void) {}
-  const string &getName(void) const { return name; }
+  const std::string &getName(void) const { return name; }
   uintm getId(void) const { return id; }
   virtual symbol_type getType(void) const { return dummy_symbol; }
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   void restoreXmlHeader(const Element *el);
-  virtual void saveXml(ostream &s) const {}
+  virtual void saveXml(std::ostream &s) const {}
   virtual void restoreXml(const Element *el,SleighBase *trans) {}
 };
 
@@ -50,7 +50,7 @@ struct SymbolCompare {
     return (a->getName() < b->getName()); }
 };
 
-typedef set<SleighSymbol *,SymbolCompare> SymbolTree;
+typedef std::set<SleighSymbol *,SymbolCompare> SymbolTree;
 class SymbolScope {
   friend class SymbolTable;
   SymbolScope *parent;
@@ -60,7 +60,7 @@ class SymbolScope {
   SymbolScope(SymbolScope *p,uintm i) { parent = p; id = i; }
   SymbolScope *getParent(void) const { return parent; }
   SleighSymbol *addSymbol(SleighSymbol *a);
-  SleighSymbol *findSymbol(const string &nm) const;
+  SleighSymbol *findSymbol(const std::string &nm) const;
   SymbolTree::const_iterator begin(void) const { return tree.begin(); }
   SymbolTree::const_iterator end(void) const { return tree.end(); }
   uintm getId(void) const { return id; }
@@ -68,11 +68,11 @@ class SymbolScope {
 };
 
 class SymbolTable {
-  vector<SleighSymbol *> symbollist;
-  vector<SymbolScope *> table;
+  std::vector<SleighSymbol *> symbollist;
+  std::vector<SymbolScope *> table;
   SymbolScope *curscope;
   SymbolScope *skipScope(int4 i) const;
-  SleighSymbol *findSymbolInternal(SymbolScope *scope,const string &nm) const;
+  SleighSymbol *findSymbolInternal(SymbolScope *scope,const std::string &nm) const;
   void renumber(void);
 public:
   SymbolTable(void) { curscope = (SymbolScope *)0; }
@@ -85,12 +85,12 @@ class SymbolTable {
   void popScope(void);		// Make parent of current scope current
   void addGlobalSymbol(SleighSymbol *a);
   void addSymbol(SleighSymbol *a);
-  SleighSymbol *findSymbol(const string &nm) const { return findSymbolInternal(curscope,nm); }
-  SleighSymbol *findSymbol(const string &nm,int4 skip) const { return findSymbolInternal(skipScope(skip),nm); }
-  SleighSymbol *findGlobalSymbol(const string &nm) const { return findSymbolInternal(table[0],nm); }
+  SleighSymbol *findSymbol(const std::string &nm) const { return findSymbolInternal(curscope,nm); }
+  SleighSymbol *findSymbol(const std::string &nm,int4 skip) const { return findSymbolInternal(skipScope(skip),nm); }
+  SleighSymbol *findGlobalSymbol(const std::string &nm) const { return findSymbolInternal(table[0],nm); }
   SleighSymbol *findSymbol(uintm id) const { return symbollist[id]; }
   void replaceSymbol(SleighSymbol *a,SleighSymbol *b);
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,SleighBase *trans);
   void restoreSymbolHeader(const Element *el);
   void purge(void);
@@ -118,7 +118,7 @@ class SectionSymbol : public SleighSymbol { // Named p-code sections
   int4 define_count;		// Number of definitions of this named section
   int4 ref_count;		// Number of references to this named section
 public:
-  SectionSymbol(const string &nm,int4 id) : SleighSymbol(nm) { templateid=id; define_count=0; ref_count=0; }
+  SectionSymbol(const std::string &nm,int4 id) : SleighSymbol(nm) { templateid=id; define_count=0; ref_count=0; }
   int4 getTemplateId(void) const { return templateid; }
   void incrementDefineCount(void) { define_count += 1; }
   void incrementRefCount(void) { ref_count += 1; }
@@ -132,12 +132,12 @@ class UserOpSymbol : public SleighSymbol { // A user-defined pcode-op
   uint4 index;
 public:
   UserOpSymbol(void) {}		// For use with restoreXml
-  UserOpSymbol(const string &nm) : SleighSymbol(nm) { index = 0; }
+  UserOpSymbol(const std::string &nm) : SleighSymbol(nm) { index = 0; }
   void setIndex(uint4 ind) { index = ind; }
   uint4 getIndex(void) const { return index; }
   virtual symbol_type getType(void) const { return userop_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -146,26 +146,26 @@ class Constructor;		// Forward declaration
 class TripleSymbol : public SleighSymbol {
 public:
   TripleSymbol(void) {}
-  TripleSymbol(const string &nm) : SleighSymbol(nm) {}
+  TripleSymbol(const std::string &nm) : SleighSymbol(nm) {}
   virtual Constructor *resolve(ParserWalker &walker) { return (Constructor *)0; }
   virtual PatternExpression *getPatternExpression(void) const=0;
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const=0;
   virtual int4 getSize(void) const { return 0; }	// Size out of context
-  virtual void print(ostream &s,ParserWalker &walker) const=0;
-  virtual void collectLocalValues(vector<uintb> &results) const {}
+  virtual void print(std::ostream &s,ParserWalker &walker) const=0;
+  virtual void collectLocalValues(std::vector<uintb> &results) const {}
 };
   
 class FamilySymbol : public TripleSymbol {
 public:
   FamilySymbol(void) {}
-  FamilySymbol(const string &nm) : TripleSymbol(nm) {}
+  FamilySymbol(const std::string &nm) : TripleSymbol(nm) {}
   virtual PatternValue *getPatternValue(void) const=0;
 };
 
 class SpecificSymbol : public TripleSymbol {
 public:
   SpecificSymbol(void) {}
-  SpecificSymbol(const string &nm) : TripleSymbol(nm) {}
+  SpecificSymbol(const std::string &nm) : TripleSymbol(nm) {}
   virtual VarnodeTpl *getVarnode(void) const=0;
 };
 
@@ -173,10 +173,10 @@ class PatternlessSymbol : public SpecificSymbol { // Behaves like constant 0 pat
   ConstantValue *patexp;
 public:
   PatternlessSymbol(void);	// For use with restoreXml
-  PatternlessSymbol(const string &nm);
+  PatternlessSymbol(const std::string &nm);
   virtual ~PatternlessSymbol(void);
   virtual PatternExpression *getPatternExpression(void) const { return patexp; }
-  virtual void saveXml(ostream &s) const {}
+  virtual void saveXml(std::ostream &s) const {}
   virtual void restoreXml(const Element *el,SleighBase *trans) {}
 };
 
@@ -184,13 +184,13 @@ class EpsilonSymbol : public PatternlessSymbol { // Another name for zero patter
   AddrSpace *const_space;
 public:
   EpsilonSymbol(void) {}	// For use with restoreXml
-  EpsilonSymbol(const string &nm,AddrSpace *spc) : PatternlessSymbol(nm) { const_space=spc; }
+  EpsilonSymbol(const std::string &nm,AddrSpace *spc) : PatternlessSymbol(nm) { const_space=spc; }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return epsilon_symbol; }
   virtual VarnodeTpl *getVarnode(void) const;
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -199,46 +199,46 @@ class ValueSymbol : public FamilySymbol {
   PatternValue *patval;
 public:
   ValueSymbol(void) { patval = (PatternValue *)0; } // For use with restoreXml
-  ValueSymbol(const string &nm,PatternValue *pv);
+  ValueSymbol(const std::string &nm,PatternValue *pv);
   virtual ~ValueSymbol(void);
   virtual PatternValue *getPatternValue(void) const { return patval; }
   virtual PatternExpression *getPatternExpression(void) const { return patval; }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return value_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
 class ValueMapSymbol : public ValueSymbol {
-  vector<intb> valuetable;
+  std::vector<intb> valuetable;
   bool tableisfilled;
   void checkTableFill(void);
 public:
   ValueMapSymbol(void) {}	// For use with restoreXml
-  ValueMapSymbol(const string &nm,PatternValue *pv,const vector<intb> &vt) : ValueSymbol(nm,pv) { valuetable=vt; checkTableFill(); }
+  ValueMapSymbol(const std::string &nm,PatternValue *pv,const std::vector<intb> &vt) : ValueSymbol(nm,pv) { valuetable=vt; checkTableFill(); }
   virtual Constructor *resolve(ParserWalker &walker);
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return valuemap_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
 class NameSymbol : public ValueSymbol {
-  vector<string> nametable;
+  std::vector<std::string> nametable;
   bool tableisfilled;
   void checkTableFill(void);
 public:
   NameSymbol(void) {}		// For use with restoreXml
-  NameSymbol(const string &nm,PatternValue *pv,const vector<string> &nt) : ValueSymbol(nm,pv) { nametable=nt; checkTableFill(); }
+  NameSymbol(const std::string &nm,PatternValue *pv,const std::vector<std::string> &nt) : ValueSymbol(nm,pv) { nametable=nt; checkTableFill(); }
   virtual Constructor *resolve(ParserWalker &walker);
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return name_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -247,18 +247,18 @@ class VarnodeSymbol : public PatternlessSymbol { // A global varnode
   bool context_bits;
 public:
   VarnodeSymbol(void) {}	// For use with restoreXml
-  VarnodeSymbol(const string &nm,AddrSpace *base,uintb offset,int4 size);
+  VarnodeSymbol(const std::string &nm,AddrSpace *base,uintb offset,int4 size);
   void markAsContext(void) { context_bits = true; }
   const VarnodeData &getFixedVarnode(void) const { return fix; }
   virtual VarnodeTpl *getVarnode(void) const;
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
   virtual int4 getSize(void) const { return fix.size; }
-  virtual void print(ostream &s,ParserWalker &walker) const {
+  virtual void print(std::ostream &s,ParserWalker &walker) const {
     s << getName(); }
-  virtual void collectLocalValues(vector<uintb> &results) const;
+  virtual void collectLocalValues(std::vector<uintb> &results) const;
   virtual symbol_type getType(void) const { return varnode_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -268,7 +268,7 @@ class BitrangeSymbol : public SleighSymbol { // A smaller bitrange within a varn
   uint4 numbits;		// number of bits in the range
 public:
   BitrangeSymbol(void) {}	// For use with restoreXml
-  BitrangeSymbol(const string &nm,VarnodeSymbol *sym,uint4 bitoff,uint4 num)
+  BitrangeSymbol(const std::string &nm,VarnodeSymbol *sym,uint4 bitoff,uint4 num)
     : SleighSymbol(nm) { varsym=sym; bitoffset=bitoff; numbits=num; }
   VarnodeSymbol *getParentSymbol(void) const { return varsym; }
   uint4 getBitOffset(void) const { return bitoffset; }
@@ -282,31 +282,31 @@ class ContextSymbol : public ValueSymbol {
   bool flow;
 public:
   ContextSymbol(void) {}	// For use with restoreXml
-  ContextSymbol(const string &nm,ContextField *pate,VarnodeSymbol *v,uint4 l,uint4 h,bool flow);
+  ContextSymbol(const std::string &nm,ContextField *pate,VarnodeSymbol *v,uint4 l,uint4 h,bool flow);
   VarnodeSymbol *getVarnode(void) const { return vn; }
   uint4 getLow(void) const { return low; }
   uint4 getHigh(void) const { return high; }
   bool getFlow(void) const { return flow; }
   virtual symbol_type getType(void) const { return context_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
 class VarnodeListSymbol : public ValueSymbol {
-  vector<VarnodeSymbol *> varnode_table;
+  std::vector<VarnodeSymbol *> varnode_table;
   bool tableisfilled;
   void checkTableFill(void);
 public:
   VarnodeListSymbol(void) {}	// For use with restoreXml
-  VarnodeListSymbol(const string &nm,PatternValue *pv,const vector<SleighSymbol *> &vt); 
+  VarnodeListSymbol(const std::string &nm,PatternValue *pv,const std::vector<SleighSymbol *> &vt);
   virtual Constructor *resolve(ParserWalker &walker);
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
   virtual int4 getSize(void) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return varnodelist_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
   
@@ -328,7 +328,7 @@ class OperandSymbol : public SpecificSymbol {
   bool isVariableLength(void) const { return ((flags&variable_len)!=0); }
 public:
   OperandSymbol(void) {}	// For use with restoreXml
-  OperandSymbol(const string &nm,int4 index,Constructor *ct);
+  OperandSymbol(const std::string &nm,int4 index,Constructor *ct);
   uint4 getRelativeOffset(void) const { return reloffset; }
   int4 getOffsetBase(void) const { return offsetbase; }
   int4 getMinimumLength(void) const { return minimumlength; }
@@ -349,11 +349,11 @@ class OperandSymbol : public SpecificSymbol {
   virtual PatternExpression *getPatternExpression(void) const { return localexp; }
   virtual void getFixedHandle(FixedHandle &hnd,ParserWalker &walker) const;
   virtual int4 getSize(void) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
-  virtual void collectLocalValues(vector<uintb> &results) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
+  virtual void collectLocalValues(std::vector<uintb> &results) const;
   virtual symbol_type getType(void) const { return operand_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -362,15 +362,15 @@ class StartSymbol : public SpecificSymbol {
   PatternExpression *patexp;
 public:
   StartSymbol(void) { patexp = (PatternExpression *)0; } // For use with restoreXml
-  StartSymbol(const string &nm,AddrSpace *cspc);
+  StartSymbol(const std::string &nm,AddrSpace *cspc);
   virtual ~StartSymbol(void);
   virtual VarnodeTpl *getVarnode(void) const;
   virtual PatternExpression *getPatternExpression(void) const { return patexp; }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return start_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -379,15 +379,15 @@ class EndSymbol : public SpecificSymbol {
   PatternExpression *patexp;
 public:
   EndSymbol(void) { patexp = (PatternExpression *)0; } // For use with restoreXml
-  EndSymbol(const string &nm,AddrSpace *cspc);
+  EndSymbol(const std::string &nm,AddrSpace *cspc);
   virtual ~EndSymbol(void);
   virtual VarnodeTpl *getVarnode(void) const;
   virtual PatternExpression *getPatternExpression(void) const { return patexp; }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return end_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -396,15 +396,15 @@ class Next2Symbol : public SpecificSymbol {
   PatternExpression *patexp;
 public:
   Next2Symbol(void) { patexp = (PatternExpression *)0; } // For use with restoreXml
-  Next2Symbol(const string &nm,AddrSpace *cspc);
+  Next2Symbol(const std::string &nm,AddrSpace *cspc);
   virtual ~Next2Symbol(void);
   virtual VarnodeTpl *getVarnode(void) const;
   virtual PatternExpression *getPatternExpression(void) const { return patexp; }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return next2_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -412,14 +412,14 @@ class FlowDestSymbol : public SpecificSymbol {
   AddrSpace *const_space;
 public:
   FlowDestSymbol(void) {}	// For use with restoreXml
-  FlowDestSymbol(const string &nm,AddrSpace *cspc);
+  FlowDestSymbol(const std::string &nm,AddrSpace *cspc);
   virtual VarnodeTpl *getVarnode(void) const;
   virtual PatternExpression *getPatternExpression(void) const { throw SleighError("Cannot use symbol in pattern"); }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return start_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -427,14 +427,14 @@ class FlowRefSymbol : public SpecificSymbol {
   AddrSpace *const_space;
 public:
   FlowRefSymbol(void) {}	// For use with restoreXml
-  FlowRefSymbol(const string &nm,AddrSpace *cspc);
+  FlowRefSymbol(const std::string &nm,AddrSpace *cspc);
   virtual VarnodeTpl *getVarnode(void) const;
   virtual PatternExpression *getPatternExpression(void) const { throw SleighError("Cannot use symbol in pattern"); }
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
-  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual void print(std::ostream &s,ParserWalker &walker) const;
   virtual symbol_type getType(void) const { return start_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
@@ -442,7 +442,7 @@ class ContextChange {		// Change to context command
 public:
   virtual ~ContextChange(void) {}
   virtual void validate(void) const=0;
-  virtual void saveXml(ostream &s) const=0;
+  virtual void saveXml(std::ostream &s) const=0;
   virtual void restoreXml(const Element *el,SleighBase *trans)=0;
   virtual void apply(ParserWalkerChange &walker) const=0;
   virtual ContextChange *clone(void) const=0;
@@ -458,7 +458,7 @@ class ContextOp : public ContextChange {
   ContextOp(void) {}		// For use with restoreXml
   virtual ~ContextOp(void) { PatternExpression::release(patexp); }
   virtual void validate(void) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
   virtual void apply(ParserWalkerChange &walker) const;
   virtual ContextChange *clone(void) const;
@@ -473,7 +473,7 @@ class ContextCommit : public ContextChange {
   ContextCommit(void) {}	// For use with restoreXml
   ContextCommit(TripleSymbol *s,int4 sbit,int4 ebit,bool fl);
   virtual void validate(void) const {}
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
   virtual void apply(ParserWalkerChange &walker) const;
   virtual ContextChange *clone(void) const;
@@ -484,11 +484,11 @@ class Constructor {		// This is NOT a symbol
   TokenPattern *pattern;
   SubtableSymbol *parent;
   PatternEquation *pateq;
-  vector<OperandSymbol *> operands;
-  vector<string> printpiece;
-  vector<ContextChange *> context; // Context commands
+  std::vector<OperandSymbol *> operands;
+  std::vector<std::string> printpiece;
+  std::vector<ContextChange *> context; // Context commands
   ConstructTpl *templ;		// The main p-code section
-  vector<ConstructTpl *> namedtempl; // Other named p-code sections
+  std::vector<ConstructTpl *> namedtempl; // Other named p-code sections
   int4 minimumlength;		// Minimum length taken up by this constructor in bytes
   uintm id;			// Unique id of constructor within subtable
   int4 firstwhitespace;		// Index of first whitespace piece in -printpiece-
@@ -501,7 +501,7 @@ class Constructor {		// This is NOT a symbol
   Constructor(void);		// For use with restoreXml
   Constructor(SubtableSymbol *p);
   ~Constructor(void);
-  TokenPattern *buildPattern(ostream &s);
+  TokenPattern *buildPattern(std::ostream &s);
   TokenPattern *getPattern(void) const { return pattern; }
   void setMinimumLength(int4 l) { minimumlength = l; }
   int4 getMinimumLength(void) const { return minimumlength; }
@@ -511,10 +511,10 @@ class Constructor {		// This is NOT a symbol
   int4 getLineno(void) const { return lineno; }
   void setSrcIndex(int4 index) {src_index = index;}
   int4 getSrcIndex(void) {return src_index;}
-  void addContext(const vector<ContextChange *> &vec) { context = vec; }
+  void addContext(const std::vector<ContextChange *> &vec) { context = vec; }
   void addOperand(OperandSymbol *sym);
   void addInvisibleOperand(OperandSymbol *sym);
-  void addSyntax(const string &syn);
+  void addSyntax(const std::string &syn);
   void addEquation(PatternEquation *pe);
   void setMainSection(ConstructTpl *tpl) { templ = tpl; }
   void setNamedSection(ConstructTpl *tpl,int4 id);
@@ -525,38 +525,38 @@ class Constructor {		// This is NOT a symbol
   ConstructTpl *getTempl(void) const { return templ; }
   ConstructTpl *getNamedTempl(int4 secnum) const;
   int4 getNumSections(void) const { return namedtempl.size(); }
-  void printInfo(ostream &s) const;
-  void print(ostream &s,ParserWalker &pos) const;
-  void printMnemonic(ostream &s,ParserWalker &walker) const;
-  void printBody(ostream &s,ParserWalker &walker) const;
+  void printInfo(std::ostream &s) const;
+  void print(std::ostream &s,ParserWalker &pos) const;
+  void printMnemonic(std::ostream &s,ParserWalker &walker) const;
+  void printBody(std::ostream &s,ParserWalker &walker) const;
   void removeTrailingSpace(void);
   void applyContext(ParserWalkerChange &walker) const {
-    vector<ContextChange *>::const_iterator iter;
+    std::vector<ContextChange *>::const_iterator iter;
     for(iter=context.begin();iter!=context.end();++iter)
       (*iter)->apply(walker);
   }
-  void markSubtableOperands(vector<int4> &check) const;
-  void collectLocalExports(vector<uintb> &results) const;
+  void markSubtableOperands(std::vector<int4> &check) const;
+  void collectLocalExports(std::vector<uintb> &results) const;
   void setError(bool val) const { inerror = val; }
   bool isError(void) const { return inerror; }
   bool isRecursive(void) const;
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,SleighBase *trans);
 };
 
 class DecisionProperties {
-  vector<pair<Constructor *, Constructor *> > identerrors;
-  vector<pair<Constructor *, Constructor *> > conflicterrors;
+  std::vector<std::pair<Constructor *, Constructor *> > identerrors;
+  std::vector<std::pair<Constructor *, Constructor *> > conflicterrors;
 public:
   void identicalPattern(Constructor *a,Constructor *b);
   void conflictingPattern(Constructor *a,Constructor *b);
-  const vector<pair<Constructor *, Constructor *> > &getIdentErrors(void) const { return identerrors; }
-  const vector<pair<Constructor *, Constructor *> > &getConflictErrors(void) const { return conflicterrors; }
+  const std::vector<std::pair<Constructor *, Constructor *> > &getIdentErrors(void) const { return identerrors; }
+  const std::vector<std::pair<Constructor *, Constructor *> > &getConflictErrors(void) const { return conflicterrors; }
 };
 
 class DecisionNode {
-  vector<pair<DisjointPattern *,Constructor *> > list;
-  vector<DecisionNode *> children;
+  std::vector<std::pair<DisjointPattern *,Constructor *> > list;
+  std::vector<DecisionNode *> children;
   int4 num;			// Total number of patterns we distinguish
   bool contextdecision;		// True if this is decision based on context
   int4 startbit,bitsize;        // Bits in the stream on which to base the decision
@@ -565,7 +565,7 @@ class DecisionNode {
   double getScore(int4 low,int4 size,bool context);
   int4 getNumFixed(int4 low,int4 size,bool context);
   int4 getMaximumLength(bool context);
-  void consistentValues(vector<uint4> &bins,DisjointPattern *pat);
+  void consistentValues(std::vector<uint4> &bins,DisjointPattern *pat);
 public:
   DecisionNode(void) {}		// For use with restoreXml
   DecisionNode(DecisionNode *p);
@@ -574,24 +574,24 @@ class DecisionNode {
   void addConstructorPair(const DisjointPattern *pat,Constructor *ct);
   void split(DecisionProperties &props);
   void orderPatterns(DecisionProperties &props);
-  void saveXml(ostream &s) const;
+  void saveXml(std::ostream &s) const;
   void restoreXml(const Element *el,DecisionNode *par,SubtableSymbol *sub);
 };
 
 class SubtableSymbol : public TripleSymbol {
   TokenPattern *pattern;
   bool beingbuilt,errors;
-  vector<Constructor *> construct; // All the Constructors in this table
+  std::vector<Constructor *> construct; // All the Constructors in this table
   DecisionNode *decisiontree;
 public:
   SubtableSymbol(void) { pattern = (TokenPattern *)0; decisiontree = (DecisionNode *)0; } // For use with restoreXml
-  SubtableSymbol(const string &nm);
+  SubtableSymbol(const std::string &nm);
   virtual ~SubtableSymbol(void);
   bool isBeingBuilt(void) const { return beingbuilt; }
   bool isError(void) const { return errors; }
   void addConstructor(Constructor *ct) { ct->setId(construct.size()); construct.push_back(ct); }
   void buildDecisionTree(DecisionProperties &props);
-  TokenPattern *buildPattern(ostream &s);
+  TokenPattern *buildPattern(std::ostream &s);
   TokenPattern *getPattern(void) const { return pattern; }
   int4 getNumConstructors(void) const { return construct.size(); }
   Constructor *getConstructor(uintm id) const { return construct[id]; }
@@ -600,21 +600,21 @@ class SubtableSymbol : public TripleSymbol {
   virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const {
     throw SleighError("Cannot use subtable in expression"); }
   virtual int4 getSize(void) const { return -1; }
-  virtual void print(ostream &s,ParserWalker &walker) const {
+  virtual void print(std::ostream &s,ParserWalker &walker) const {
     throw SleighError("Cannot use subtable in expression"); }
-  virtual void collectLocalValues(vector<uintb> &results) const;
+  virtual void collectLocalValues(std::vector<uintb> &results) const;
   virtual symbol_type getType(void) const { return subtable_symbol; }
-  virtual void saveXml(ostream &s) const;
-  virtual void saveXmlHeader(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
+  virtual void saveXmlHeader(std::ostream &s) const;
   virtual void restoreXml(const Element *el,SleighBase *trans);
 };
 
 class MacroSymbol : public SleighSymbol { // A user-defined pcode-macro
   int4 index;
   ConstructTpl *construct;
-  vector<OperandSymbol *> operands;
+  std::vector<OperandSymbol *> operands;
 public:
-  MacroSymbol(const string &nm,int4 i) : SleighSymbol(nm) { index = i; construct = (ConstructTpl *)0; }
+  MacroSymbol(const std::string &nm,int4 i) : SleighSymbol(nm) { index = i; construct = (ConstructTpl *)0; }
   int4 getIndex(void) const { return index; }
   void setConstruct(ConstructTpl *ct) { construct = ct; }
   ConstructTpl *getConstruct(void) const { return construct; }
@@ -630,7 +630,7 @@ class LabelSymbol : public SleighSymbol { // A branch label
   bool isplaced;		// Has the label been placed (not just referenced)
   uint4 refcount;		// Number of references to this label
 public:
-  LabelSymbol(const string &nm,uint4 i) : SleighSymbol(nm) { index = i; refcount = 0; isplaced=false; }
+  LabelSymbol(const std::string &nm,uint4 i) : SleighSymbol(nm) { index = i; refcount = 0; isplaced=false; }
   uint4 getIndex(void) const { return index; }
   void incrementRefCount(void) { refcount += 1; }
   uint4 getRefCount(void) const { return refcount; }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/space.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/space.cc
index ff6f282ca..b8ac04e72 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/space.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/space.cc
@@ -18,6 +18,8 @@
 
 #include <climits>
 
+using namespace std;
+
 AttributeId ATTRIB_BASE = AttributeId("base",89);
 AttributeId ATTRIB_DEADCODEDELAY = AttributeId("deadcodedelay",90);
 AttributeId ATTRIB_DELAY = AttributeId("delay", 91);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/space.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/space.hh
index 92209bd30..e25e3f79e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/space.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/space.hh
@@ -113,7 +113,7 @@ class AddrSpace {
   uintb pointerUpperBound;	///< Offset above which we don't search for pointers
   char shortcut;		///< Shortcut character for printing
 protected:
-  string name;			///< Name of this space
+  std::string name;			///< Name of this space
   uint4 addressSize;		///< Size of an address into this space in bytes
   uint4 wordsize;		///< Size of unit being addressed (1=byte)
   int4 minimumPointerSize;	///< Smallest size of a pointer into \b this space (in bytes)
@@ -123,14 +123,14 @@ class AddrSpace {
   void calcScaleMask(void);	///< Calculate scale and mask
   void setFlags(uint4 fl);	///< Set a cached attribute
   void clearFlags(uint4 fl);	///< Clear a cached attribute
-  void saveBasicAttributes(ostream &s) const; ///< Write the XML attributes of this space
+  void saveBasicAttributes(std::ostream &s) const; ///< Write the XML attributes of this space
   void decodeBasicAttributes(Decoder &decoder);	///< Read attributes for \b this space from an open XML element
   void truncateSpace(uint4 newsize);
 public:
-  AddrSpace(AddrSpaceManager *m,const Translate *t,spacetype tp,const string &nm,uint4 size,uint4 ws,int4 ind,uint4 fl,int4 dl);
+  AddrSpace(AddrSpaceManager *m,const Translate *t,spacetype tp,const std::string &nm,uint4 size,uint4 ws,int4 ind,uint4 fl,int4 dl);
   AddrSpace(AddrSpaceManager *m,const Translate *t,spacetype tp); ///< For use with decode
   virtual ~AddrSpace(void) {}	///< The address space destructor
-  const string &getName(void) const; ///< Get the name
+  const std::string &getName(void) const; ///< Get the name
   AddrSpaceManager *getManager(void) const; ///< Get the space manager
   const Translate *getTrans(void) const; ///< Get the processor translator
   spacetype getType(void) const; ///< Get the type of space
@@ -156,7 +156,7 @@ class AddrSpace {
   bool isOtherSpace(void) const;	///< Return \b true if \b this is the \e other address space
   bool isTruncated(void) const; ///< Return \b true if this space is truncated from its original size
   bool hasNearPointers(void) const;	///< Return \b true if \e near (truncated) pointers into \b this space are possible
-  void printOffset(ostream &s,uintb offset) const;  ///< Write an address offset to a stream
+  void printOffset(std::ostream &s,uintb offset) const;  ///< Write an address offset to a stream
 
   virtual int4 numSpacebase(void) const;	///< Number of base registers associated with this space
   virtual const VarnodeData &getSpacebase(int4 i) const;	///< Get a base register that creates this virtual space
@@ -166,9 +166,9 @@ class AddrSpace {
   virtual void encodeAttributes(Encoder &encoder,uintb offset) const;  ///< Encode address attributes to a stream
   virtual void encodeAttributes(Encoder &encoder,uintb offset,int4 size) const;   ///< Encode an address and size attributes to a stream
   virtual uintb decodeAttributes(Decoder &decoder,uint4 &size) const;   ///< Recover an offset and size
-  virtual void printRaw(ostream &s,uintb offset) const;  ///< Write an address in this space to a stream
-  virtual uintb read(const string &s,int4 &size) const;  ///< Read in an address (and possible size) from a string
-  virtual void saveXml(ostream &s) const; ///< Write the details of this space as XML
+  virtual void printRaw(std::ostream &s,uintb offset) const;  ///< Write an address in this space to a stream
+  virtual uintb read(const std::string &s,int4 &size) const;  ///< Read in an address (and possible size) from a string
+  virtual void saveXml(std::ostream &s) const; ///< Write the details of this space as XML
   virtual void decode(Decoder &decoder); ///< Recover the details of this space from XML
 
   static uintb addressToByte(uintb val,uint4 ws); ///< Scale from addressable units to byte units
@@ -193,10 +193,10 @@ class AddrSpace {
 class ConstantSpace : public AddrSpace {
 public:
   ConstantSpace(AddrSpaceManager *m,const Translate *t); ///< Only constructor
-  virtual void printRaw(ostream &s,uintb offset) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void printRaw(std::ostream &s,uintb offset) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
-  static const string NAME;		///< Reserved name for the address space
+  static const std::string NAME;		///< Reserved name for the address space
   static const int4 INDEX;		///< Reserved index for constant space
 };
 
@@ -205,9 +205,9 @@ class OtherSpace : public AddrSpace {
 public:
   OtherSpace(AddrSpaceManager *m, const Translate *t, int4 ind);	///< Constructor
   OtherSpace(AddrSpaceManager *m, const Translate *t);	///< For use with decode
-  virtual void printRaw(ostream &s, uintb offset) const;
-  virtual void saveXml(ostream &s) const;
-  static const string NAME;		///< Reserved name for the address space
+  virtual void printRaw(std::ostream &s, uintb offset) const;
+  virtual void saveXml(std::ostream &s) const;
+  static const std::string NAME;		///< Reserved name for the address space
   static const int4 INDEX;		///< Reserved index for the other space
 };
 
@@ -224,8 +224,8 @@ class UniqueSpace : public AddrSpace {
 public:
   UniqueSpace(AddrSpaceManager *m,const Translate *t,int4 ind,uint4 fl);	///< Constructor
   UniqueSpace(AddrSpaceManager *m,const Translate *t);	///< For use with decode
-  virtual void saveXml(ostream &s) const;
-  static const string NAME;		///< Reserved name for the unique space
+  virtual void saveXml(std::ostream &s) const;
+  static const std::string NAME;		///< Reserved name for the unique space
   static const uint4 SIZE;		///< Fixed size (in bytes) for unique space offsets
 };
 
@@ -243,11 +243,11 @@ class JoinSpace : public AddrSpace {
   virtual void encodeAttributes(Encoder &encoder,uintb offset) const;
   virtual void encodeAttributes(Encoder &encoder,uintb offset,int4 size) const;
   virtual uintb decodeAttributes(Decoder &decoder,uint4 &size) const;
-  virtual void printRaw(ostream &s,uintb offset) const;
-  virtual uintb read(const string &s,int4 &size) const;
-  virtual void saveXml(ostream &s) const;
+  virtual void printRaw(std::ostream &s,uintb offset) const;
+  virtual uintb read(const std::string &s,int4 &size) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
-  static const string NAME;		///< Reserved name for the join space
+  static const std::string NAME;		///< Reserved name for the join space
 };
 
 /// \brief An overlay space.
@@ -263,7 +263,7 @@ class OverlaySpace : public AddrSpace {
 public:
   OverlaySpace(AddrSpaceManager *m,const Translate *t);	///< Constructor
   virtual AddrSpace *getContain(void) const { return baseSpace; }
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
 };
 
@@ -282,7 +282,7 @@ inline void AddrSpace::clearFlags(uint4 fl) {
 /// Every address space has a (unique) name, which is referred
 /// to especially in configuration files via XML.
 /// \return the name of this space
-inline const string &AddrSpace::getName(void) const {
+inline const std::string &AddrSpace::getName(void) const {
   return name;
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.cc
index 080f543ce..eb10514d1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "string_ghidra.hh"
 
+using namespace std;
+
 GhidraStringManager::GhidraStringManager(ArchitectureGhidra *g,int4 max)
   : StringManager(max)
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.hh
index 884e7e671..af81276ed 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/string_ghidra.hh
@@ -33,7 +33,7 @@ class GhidraStringManager : public StringManager {
 public:
   GhidraStringManager(ArchitectureGhidra *g,int4 max);	///< Constructor
   virtual ~GhidraStringManager(void);
-  virtual const vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc);
+  virtual const std::vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.cc
index 220210a1c..a1324ca46 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.cc
@@ -16,6 +16,8 @@
 #include "stringmanage.hh"
 #include "architecture.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_TRUNC = AttributeId("trunc",69);
 
 ElementId ELEM_BYTES = ElementId("bytes",83);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.hh
index 8a227c69e..f6f5bcb4e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/stringmanage.hh
@@ -40,9 +40,9 @@ class StringManager {
   class StringData {
   public:
     bool isTruncated;		///< \b true if the the string is truncated
-    vector<uint1> byteData;	///< UTF8 encoded string data
+    std::vector<uint1> byteData;	///< UTF8 encoded string data
   };
-  map<Address,StringData> stringMap;	///< Map from address to string data
+  std::map<Address,StringData> stringMap;	///< Map from address to string data
   int4 maximumChars;			///< Maximum characters in a string before truncating
 public:
   StringManager(int4 max);		///< Constructor
@@ -60,14 +60,14 @@ class StringManager {
   /// \param charType is a character data-type indicating the encoding
   /// \param isTrunc passes back whether the string is truncated
   /// \return the byte array of UTF8 data
-  virtual const vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc)=0;
+  virtual const std::vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc)=0;
 
   void encode(Encoder &encoder) const;	///< Encode cached strings to a stream
   void decode(Decoder &decoder);	///< Restore string cache from a stream
 
   static bool hasCharTerminator(const uint1 *buffer,int4 size,int4 charsize);	///< Check for a unicode string terminator
   static int4 readUtf16(const uint1 *buf,bool bigend);	///< Read a UTF16 code point from a byte array
-  static void writeUtf8(ostream &s,int4 codepoint);	///< Write unicode character to stream in UTF8 encoding
+  static void writeUtf8(std::ostream &s,int4 codepoint);	///< Write unicode character to stream in UTF8 encoding
   static int4 getCodepoint(const uint1 *buf,int4 charsize,bool bigend,int4 &skip);	///< Extract next \e unicode \e codepoint
 };
 
@@ -83,8 +83,8 @@ class StringManagerUnicode : public StringManager {
   StringManagerUnicode(Architecture *g,int4 max);	///< Constructor
   virtual ~StringManagerUnicode(void);
 
-  virtual const vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc);
-  bool writeUnicode(ostream &s,uint1 *buffer,int4 size,int4 charsize);	///< Translate/copy unicode to UTF8
+  virtual const std::vector<uint1> &getStringData(const Address &addr,Datatype *charType,bool &isTrunc);
+  bool writeUnicode(std::ostream &s,uint1 *buffer,int4 size,int4 charsize);	///< Translate/copy unicode to UTF8
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
index 8f6835b3f..2a79f2942 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
@@ -15,6 +15,8 @@
  */
 #include "subflow.hh"
 
+using namespace std;
+
 /// \brief Return \e slot of constant if INT_OR op sets all bits in mask, otherwise -1
 ///
 /// \param orop is the given CPUI_INT_OR op
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
index d3c5983b8..741af41d2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.hh
@@ -56,7 +56,7 @@ class SubvariableFlow {
     OpCode opc;			///< Opcode of the new op
     int4 numparams;		///< Number of parameters in (new) op
     ReplaceVarnode *output;	///< Varnode output
-    vector<ReplaceVarnode *> input; ///< Varnode inputs
+    std::vector<ReplaceVarnode *> input; ///< Varnode inputs
   };
 
   /// \brief Operation with a new logical value as (part of) input, but output Varnode is unchanged
@@ -83,11 +83,11 @@ class SubvariableFlow {
   bool aggressive;		///< Do we "know" initial seed point must be a sub variable
   bool sextrestrictions;	///< Check for logical variables that are always sign extended into their container
   Funcdata *fd;			///< Containing function
-  map<Varnode *,ReplaceVarnode> varmap;	///< Map from original Varnodes to the overlaying subgraph nodes
-  list<ReplaceVarnode> newvarlist;	///< Storage for subgraph variable nodes
-  list<ReplaceOp> oplist;		///< Storage for subgraph op nodes
-  list<PatchRecord> patchlist;	///< Operations getting patched (but with no flow thru)
-  vector<ReplaceVarnode *> worklist;	///< Subgraph variable nodes still needing to be traced
+  std::map<Varnode *,ReplaceVarnode> varmap;	///< Map from original Varnodes to the overlaying subgraph nodes
+  std::list<ReplaceVarnode> newvarlist;	///< Storage for subgraph variable nodes
+  std::list<ReplaceOp> oplist;		///< Storage for subgraph op nodes
+  std::list<PatchRecord> patchlist;	///< Operations getting patched (but with no flow thru)
+  std::vector<ReplaceVarnode *> worklist;	///< Subgraph variable nodes still needing to be traced
   int4 pullcount;		///< Number of instructions pulling out the logical value
   static int4 doesOrSet(PcodeOp *orop,uintb mask);
   static int4 doesAndClear(PcodeOp *andop,uintb mask);
@@ -132,7 +132,7 @@ class SubvariableFlow {
 /// involved in the data-flow into their logical pieces.
 class SplitFlow : public TransformManager {
   LaneDescription laneDescription;	///< Description of how to split Varnodes
-  vector<TransformVar *> worklist;	///< Pending work list of Varnodes to push the split through
+  std::vector<TransformVar *> worklist;	///< Pending work list of Varnodes to push the split through
   TransformVar *setReplacement(Varnode *vn);
   bool addOp(PcodeOp *op,TransformVar *rvn,int4 slot);
   bool traceForward(TransformVar *rvn);
@@ -152,7 +152,7 @@ class SubfloatFlow : public TransformManager {
   int4 precision;		///< Number of bytes of precision in the logical flow
   int4 terminatorCount;		///< Number of terminating nodes reachable via the root
   const FloatFormat *format;	///< The floating-point format of the logical value
-  vector<TransformVar *> worklist;	///< Current list of placeholders that still need to be traced
+  std::vector<TransformVar *> worklist;	///< Current list of placeholders that still need to be traced
   TransformVar *setReplacement(Varnode *vn);
   bool traceForward(TransformVar *rvn);
   bool traceBackward(TransformVar *rvn);
@@ -179,7 +179,7 @@ class LaneDivide : public TransformManager {
   };
 
   LaneDescription description;	///< Global description of lanes that need to be split
-  vector<WorkNode> workList;	///< List of Varnodes still left to trace
+  std::vector<WorkNode> workList;	///< List of Varnodes still left to trace
   bool allowSubpieceTerminator;	///< \b true if we allow lanes to be cast (via SUBPIECE) to a smaller integer size
 
   TransformVar *setReplacement(Varnode *vn,int4 numLanes,int4 skipLanes);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/test.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/test.cc
index ebc049c29..cfac8815a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/test.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/test.cc
@@ -19,6 +19,8 @@
 
 #include "libdecomp.hh"
 
+using namespace std;
+
 vector<UnitTest *> UnitTest::tests;
 
 /// Run all the tests unless a non-empty set of names is passed in.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.cc
index 4f7110bb4..a23cad3df 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.cc
@@ -15,6 +15,8 @@
  */
 #include "ifacedecomp.hh"
 
+using namespace std;
+
 void FunctionTestProperty::startTest(void) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.hh
index 46abd6bce..daf9779b7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/testfunction.hh
@@ -33,24 +33,24 @@ class IfaceDecompData;
 class FunctionTestProperty {
   int4 minimumMatch;		///< Minimum number of times property is expected to match
   int4 maximumMatch;		///< Maximum number of times property is expected to match
-  string name;			///< Name of the test, to be printed in test summaries
-  regex pattern;		///< Regular expression to match against a line of output
+  std::string name;			///< Name of the test, to be printed in test summaries
+  std::regex pattern;		///< Regular expression to match against a line of output
   mutable uint4 count;		///< Number of times regular expression has been seen
 public:
-  string getName(void) const { return name; }	///< Get the name of the property
+  std::string getName(void) const { return name; }	///< Get the name of the property
   void startTest(void) const;		///< Reset "state", counting number of matching lines
-  void processLine(const string &line) const;	///< Search thru \e line, update state if match found
+  void processLine(const std::string &line) const;	///< Search thru \e line, update state if match found
   bool endTest(void) const;		///< Return results of property search
   void restoreXml(const Element *el);	///< Reconstruct the property from an XML tag
 };
 
 /// \brief A console command run as part of a test sequence
 class ConsoleCommands : public IfaceStatus {
-  vector<string> &commands;		///< Sequence of commands
+  std::vector<std::string> &commands;		///< Sequence of commands
   uint4 pos;				///< Position of next command to execute
-  virtual void readLine(string &line);
+  virtual void readLine(std::string &line);
 public:
-  ConsoleCommands(ostream &s,vector<string> &comms);		///< Constructor
+  ConsoleCommands(std::ostream &s,std::vector<std::string> &comms);		///< Constructor
   virtual void reset(void);		///< Reset console for a new program
   virtual bool isStreamFinished(void) const { return pos == commands.size(); }
 };
@@ -66,9 +66,9 @@ class ConsoleCommands : public IfaceStatus {
 /// does not complete properly, this is considered a special kind of failure.
 class FunctionTestCollection {
   IfaceDecompData *dcp;		///< Program data for the test collection
-  string fileName;		///< Name of the file containing test data
-  list<FunctionTestProperty> testList;	///< List of tests for this collection
-  vector<string> commands;	///< Sequence of commands for current test
+  std::string fileName;		///< Name of the file containing test data
+  std::list<FunctionTestProperty> testList;	///< List of tests for this collection
+  std::vector<std::string> commands;	///< Sequence of commands for current test
   IfaceStatus *console;		///< Decompiler console for executing scripts
   bool consoleOwner;		///< Set to \b true if \b this object owns the console
   mutable int4 numTestsApplied;		///< Count of tests that were executed
@@ -77,21 +77,21 @@ class FunctionTestCollection {
   void restoreXmlCommands(const Element *el);	///< Reconstruct commands from an XML tag
   void buildProgram(DocumentStorage &store);	///< Build program (Architecture) from \<binaryimage> tag
   void startTests(void) const;	///< Initialize each FunctionTestProperty
-  void passLineToTests(const string &line) const;	///< Let all tests analyze a line of the results
-  void evaluateTests(list<string> &lateStream) const;
+  void passLineToTests(const std::string &line) const;	///< Let all tests analyze a line of the results
+  void evaluateTests(std::list<std::string> &lateStream) const;
 public:
-  FunctionTestCollection(ostream &s);		///< Constructor
+  FunctionTestCollection(std::ostream &s);		///< Constructor
   FunctionTestCollection(IfaceStatus *con);	///< Constructor with preexisting console
   ~FunctionTestCollection(void);		///< Destructor
   int4 getTestsApplied(void) const { return numTestsApplied; }	///< Get the number of tests executed
   int4 getTestsSucceeded(void) const { return numTestsSucceeded; }	///< Get the number of tests that passed
   int4 numCommands(void) const { return commands.size(); }	///< Get the number of commands in the current script
-  string getCommand(int4 i) const { return commands[i]; }	///< Get the i-th command
-  void loadTest(const string &filename);	///< Load a test program, tests, and script
+  std::string getCommand(int4 i) const { return commands[i]; }	///< Get the i-th command
+  void loadTest(const std::string &filename);	///< Load a test program, tests, and script
   void restoreXml(DocumentStorage &store,const Element *el);	///< Load tests from a \<decompilertest> tag.
   void restoreXmlOldForm(DocumentStorage &store,const Element *el);	///< Load tests from \<binaryimage> tag.
-  void runTests(list<string> &lateStream);	///< Run the script and perform the tests
-  static int runTestFiles(const vector<string> &testFiles,ostream &s);	///< Run tests for each listed file
+  void runTests(std::list<std::string> &lateStream);	///< Run the script and perform the tests
+  static int runTestFiles(const std::vector<std::string> &testFiles,std::ostream &s);	///< Run tests for each listed file
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
index 3c594169d..2e42baac0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.cc
@@ -16,6 +16,8 @@
 #include "transform.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_VECTOR_LANE_SIZES = AttributeId("vector_lane_sizes",130);
 
 /// \param op2 is the lane description to copy from
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.hh
index fa26f0bd1..107e701fc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/transform.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/transform.hh
@@ -77,7 +77,7 @@ class TransformOp {
   OpCode opc;			///< Opcode of the new op
   uint4 special;		///< Special handling code when creating
   TransformVar *output;	///< Varnode output
-  vector<TransformVar *> input; ///< Varnode inputs
+  std::vector<TransformVar *> input; ///< Varnode inputs
   TransformOp *follow;		///< The following op after \b this (if not null)
   void createReplacement(Funcdata *fd);	///< Create the new/modified op this placeholder represents
   bool attemptInsertion(Funcdata *fd);	///< Try to put the new PcodeOp into its basic block
@@ -127,8 +127,8 @@ class LanedRegister {
 /// lanes all of the same size, but the API allows for possibly non-uniform lanes.
 class LaneDescription {
   int4 wholeSize;		///< Size of the region being split in bytes
-  vector<int4> laneSize;	///< Size of lanes in bytes
-  vector<int4> lanePosition;	///< Significance positions of lanes in bytes
+  std::vector<int4> laneSize;	///< Size of lanes in bytes
+  std::vector<int4> lanePosition;	///< Significance positions of lanes in bytes
 public:
   LaneDescription(const LaneDescription &op2);	///< Copy constructor
   LaneDescription(int4 origSize,int4 sz);	///< Construct uniform lanes
@@ -151,15 +151,15 @@ class LaneDescription {
 /// Varnode and data-flow into explicit operations on the lanes.
 class TransformManager {
   Funcdata *fd;					///< Function being operated on
-  map<int4,TransformVar *> pieceMap;		///< Map from large Varnodes to their new pieces
-  list<TransformVar> newVarnodes;		///< Storage for Varnode placeholder nodes
-  list<TransformOp> newOps;			///< Storage for PcodeOp placeholder nodes
+  std::map<int4,TransformVar *> pieceMap;		///< Map from large Varnodes to their new pieces
+  std::list<TransformVar> newVarnodes;		///< Storage for Varnode placeholder nodes
+  std::list<TransformOp> newOps;			///< Storage for PcodeOp placeholder nodes
 
   void specialHandling(TransformOp &rop);
   void createOps(void);		///< Create a new op for each placeholder
-  void createVarnodes(vector<TransformVar *> &inputList);	///< Create a Varnode for each placeholder
+  void createVarnodes(std::vector<TransformVar *> &inputList);	///< Create a Varnode for each placeholder
   void removeOld(void);		///< Remove old preexisting PcodeOps and Varnodes that are now obsolete
-  void transformInputVarnodes(vector<TransformVar *> &inputList);	///< Remove old input Varnodes, mark new input Varnodes
+  void transformInputVarnodes(std::vector<TransformVar *> &inputList);	///< Remove old input Varnodes, mark new input Varnodes
   void placeInputs(void);	///< Set input Varnodes for all new ops
 public:
   TransformManager(Funcdata *f) { fd = f; }	///< Constructor
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
index ec3ec9a01..1d1c89275 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.cc
@@ -15,6 +15,8 @@
  */
 #include "translate.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_CODE = AttributeId("code",43);
 AttributeId ATTRIB_CONTAIN = AttributeId("contain",44);
 AttributeId ATTRIB_DEFAULTSPACE = AttributeId("defaultspace",45);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
index 4f296ee10..baec0079a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
@@ -54,7 +54,7 @@ struct UnimplError : public LowlevelError {
   ///
   /// \param s is a more verbose description of the error
   /// \param l is the length (in bytes) of the unimplemented instruction
-  UnimplError(const string &s,int4 l) : LowlevelError(s) { instruction_length = l; }
+  UnimplError(const std::string &s,int4 l) : LowlevelError(s) { instruction_length = l; }
 };
 
 /// \brief Exception for bad instruction data
@@ -67,7 +67,7 @@ struct BadDataError : public LowlevelError {
   /// \brief Constructor
   ///
   /// \param s is a more verbose description of the error
-  BadDataError(const string &s) : LowlevelError(s) {}
+  BadDataError(const std::string &s) : LowlevelError(s) {}
 };
 
 class Translate;
@@ -77,11 +77,11 @@ class Translate;
 /// This can turn up in various XML configuration files and essentially acts
 /// as a command to override the size of an address space as defined by the architecture
 class TruncationTag {
-  string spaceName;	///< Name of space to be truncated
+  std::string spaceName;	///< Name of space to be truncated
   uint4 size;		///< Size truncated addresses into the space
 public:
   void decode(Decoder &decoder);				///< Restore \b this from a stream
-  const string &getName(void) const { return spaceName; }	///< Get name of address space being truncated
+  const std::string &getName(void) const { return spaceName; }	///< Get name of address space being truncated
   uint4 getSize(void) const { return size; }			///< Size (of pointers) for new truncated space
 };
 
@@ -128,7 +128,7 @@ class AssemblyEmit {
   /// \param addr is the Address of the machine instruction
   /// \param mnem is the decoded instruction mnemonic
   /// \param body is the decode body (or operands) of the instruction
-  virtual void dump(const Address &addr,const string &mnem,const string &body)=0;
+  virtual void dump(const Address &addr,const std::string &mnem,const std::string &body)=0;
 };
 
 /// \brief Abstract class for converting native constants to addresses
@@ -176,14 +176,14 @@ class SpacebaseSpace : public AddrSpace {
   VarnodeData baseOrig;		///< Original base register before any truncation
   void setBaseRegister(const VarnodeData &data,int4 origSize,bool stackGrowth); ///< Set the base register at time space is created
 public:
-  SpacebaseSpace(AddrSpaceManager *m,const Translate *t,const string &nm,int4 ind,int4 sz,AddrSpace *base,int4 dl,bool isFormal);
+  SpacebaseSpace(AddrSpaceManager *m,const Translate *t,const std::string &nm,int4 ind,int4 sz,AddrSpace *base,int4 dl,bool isFormal);
   SpacebaseSpace(AddrSpaceManager *m,const Translate *t); ///< For use with decode
   virtual int4 numSpacebase(void) const;
   virtual const VarnodeData &getSpacebase(int4 i) const;
   virtual const VarnodeData &getSpacebaseFull(int4 i) const;
   virtual bool stackGrowsNegative(void) const { return isNegativeStack; }
   virtual AddrSpace *getContain(void) const { return contain; } ///< Return containing space
-  virtual void saveXml(ostream &s) const;
+  virtual void saveXml(std::ostream &s) const;
   virtual void decode(Decoder &decoder);
 };
 
@@ -194,7 +194,7 @@ class SpacebaseSpace : public AddrSpace {
 /// from \e most \e significant to \e least \e significant.
 class JoinRecord {
   friend class AddrSpaceManager;
-  vector<VarnodeData> pieces;	///< All the physical pieces of the symbol
+  std::vector<VarnodeData> pieces;	///< All the physical pieces of the symbol
   VarnodeData unified; ///< Special entry representing entire symbol in one chunk
 public:
   int4 numPieces(void) const { return pieces.size(); }	///< Get number of pieces in this record
@@ -216,10 +216,10 @@ struct JoinRecordCompare {
 /// Allow creation, lookup by name, lookup by shortcut, lookup by name, and iteration
 /// over address spaces
 class AddrSpaceManager {
-  vector<AddrSpace *> baselist; ///< Every space we know about for this architecture
-  vector<AddressResolver *> resolvelist; ///< Special constant resolvers
-  map<string,AddrSpace *> name2Space;	///< Map from name -> space
-  map<int4,AddrSpace *> shortcut2Space;	///< Map from shortcut -> space
+  std::vector<AddrSpace *> baselist; ///< Every space we know about for this architecture
+  std::vector<AddressResolver *> resolvelist; ///< Special constant resolvers
+  std::map<std::string,AddrSpace *> name2Space;	///< Map from name -> space
+  std::map<int4,AddrSpace *> shortcut2Space;	///< Map from shortcut -> space
   AddrSpace *constantspace;	///< Quick reference to constant space
   AddrSpace *defaultcodespace;	///< Default space where code lives, generally main RAM
   AddrSpace *defaultdataspace;	///< Default space where data lives
@@ -229,8 +229,8 @@ class AddrSpaceManager {
   AddrSpace *stackspace;	///< Stack space associated with processor
   AddrSpace *uniqspace;		///< Temporary space associated with processor
   uintb joinallocate;		///< Next offset to be allocated in join space
-  set<JoinRecord *,JoinRecordCompare> splitset;	///< Different splits that have been defined in join space
-  vector<JoinRecord *> splitlist; ///< JoinRecords indexed by join address
+  std::set<JoinRecord *,JoinRecordCompare> splitset;	///< Different splits that have been defined in join space
+  std::vector<JoinRecord *> splitlist; ///< JoinRecords indexed by join address
 protected:
   AddrSpace *decodeSpace(Decoder &decoder,const Translate *trans); ///< Add a space to the model based an on XML tag
   void decodeSpaces(Decoder &decoder,const Translate *trans); ///< Restore address spaces in the model from an XML tag
@@ -249,7 +249,7 @@ class AddrSpaceManager {
   AddrSpaceManager(void);	///< Construct an empty address space manager
   virtual ~AddrSpaceManager(void); ///< Destroy the manager
   int4 getDefaultSize(void) const; ///< Get size of addresses for the default space
-  AddrSpace *getSpaceByName(const string &nm) const; ///< Get address space by name
+  AddrSpace *getSpaceByName(const std::string &nm) const; ///< Get address space by name
   AddrSpace *getSpaceByShortcut(char sc) const;	///< Get address space from its shortcut
   AddrSpace *getIopSpace(void) const; ///< Get the internal pcode op space
   AddrSpace *getFspecSpace(void) const; ///< Get the internal callspec space
@@ -265,7 +265,7 @@ class AddrSpaceManager {
   int4 numSpaces(void) const; ///< Get the number of address spaces for this processor
   AddrSpace *getSpace(int4 i) const; ///< Get an address space via its index
   AddrSpace *getNextSpaceInOrder(AddrSpace *spc) const; ///< Get the next \e contiguous address space
-  JoinRecord *findAddJoin(const vector<VarnodeData> &pieces,uint4 logicalsize); ///< Get (or create) JoinRecord for \e pieces
+  JoinRecord *findAddJoin(const std::vector<VarnodeData> &pieces,uint4 logicalsize); ///< Get (or create) JoinRecord for \e pieces
   JoinRecord *findJoin(uintb offset) const; ///< Find JoinRecord for \e offset in the join space
   void setDeadcodeDelay(AddrSpace *spc,int4 delaydelta); ///< Set the deadcodedelay for a specific space
   void truncateSpace(const TruncationTag &tag);	///< Mark a space as truncated from its original size
@@ -306,7 +306,7 @@ class Translate : public AddrSpaceManager {
   uint4 unique_base;		///< Starting offset into unique space
 protected:
   int4 alignment;      ///< Byte modulo on which instructions are aligned
-  vector<FloatFormat> floatformats; ///< Floating point formats utilized by the processor
+  std::vector<FloatFormat> floatformats; ///< Floating point formats utilized by the processor
 
   void setBigEndian(bool val);	///< Set general endianness to \b big if val is \b true
   void setUniqueBase(uint4 val); ///< Set the base offset for new temporary registers
@@ -336,7 +336,7 @@ class Translate : public AddrSpaceManager {
   /// \param name is the name of the new context variable
   /// \param sbit is the first bit of the variable in the packed state
   /// \param ebit is the last bit of the variable in the packed state
-  virtual void registerContext(const string &name,int4 sbit,int4 ebit) {}
+  virtual void registerContext(const std::string &name,int4 sbit,int4 ebit) {}
 
   /// \brief Set the default value for a particular context variable
   ///
@@ -345,7 +345,7 @@ class Translate : public AddrSpaceManager {
   /// for the variable.
   /// \param name is the name of the context variable
   /// \param val is the value to be considered default
-  virtual void setContextDefault(const string &name,uintm val) {}
+  virtual void setContextDefault(const std::string &name,uintm val) {}
 
   /// \brief Toggle whether disassembly is allowed to affect context
   ///
@@ -362,7 +362,7 @@ class Translate : public AddrSpaceManager {
   /// Retrieve the location and size of a register given its name
   /// \param nm is the name of the register
   /// \return the VarnodeData for the register
-  virtual const VarnodeData &getRegister(const string &nm) const=0;
+  virtual const VarnodeData &getRegister(const std::string &nm) const=0;
 
   /// \brief Get the name of a register given its location
   ///
@@ -374,7 +374,7 @@ class Translate : public AddrSpaceManager {
   /// \param off is the offset of the location
   /// \param size is the size of the location
   /// \return the name of the register, or an empty string
-  virtual string getRegisterName(AddrSpace *base,uintb off,int4 size) const=0;
+  virtual std::string getRegisterName(AddrSpace *base,uintb off,int4 size) const=0;
 
   /// \brief Get a list of all register names and the corresponding location
   ///
@@ -382,7 +382,7 @@ class Translate : public AddrSpaceManager {
   /// that are specific to it.  This function populates a map from the location information
   /// to the name, for every named location known by the translator
   /// \param reglist is the map which will be populated by the call
-  virtual void getAllRegisters(map<VarnodeData,string> &reglist) const=0;
+  virtual void getAllRegisters(std::map<VarnodeData,std::string> &reglist) const=0;
 
   /// \brief Get a list of all \e user-defined pcode ops
   ///
@@ -392,7 +392,7 @@ class Translate : public AddrSpaceManager {
   /// and an index.  This method returns a list of these ops
   /// in index order.
   /// \param res is the resulting vector of user op names
-  virtual void getUserOpNames(vector<string> &res) const=0;
+  virtual void getUserOpNames(std::vector<std::string> &res) const=0;
 
   /// \brief Get the length of a machine instruction
   ///
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
index 91bf4bc77..0f725c138 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
@@ -16,6 +16,8 @@
 #include "type.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 /// The base propagation ordering associated with each meta-type.
 /// The array elements correspond to the ordering of #type_metatype.
 sub_metatype Datatype::base2sub[15] = {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
index 78b6fe4d2..64fa3f4d8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
@@ -68,7 +68,7 @@ extern ElementId ELEM_TYPEREF;			///< Marshaling element \<typeref>
 //extern ElementId ELEM_ZERO_LENGTH_BOUNDARY;	///< Marshaling element \<zero_length_boundary>
 
 /// Print a hex dump of a data buffer to stream
-extern void print_data(ostream &s,uint1 *buffer,int4 size,const Address &baseaddr);
+extern void print_data(std::ostream &s,uint1 *buffer,int4 size,const Address &baseaddr);
 //extern void print_char(ostream &s,int4 onechar);
 //extern bool print_string(ostream &s,uint1 *buffer,int4 size);
 
@@ -121,10 +121,10 @@ enum sub_metatype {
   SUB_PARTIALUNION = 0		///< Compare as a TYPE_PARTIALUNION
 };
 /// Convert type \b meta-type to name
-extern void metatype2string(type_metatype metatype,string &res);
+extern void metatype2string(type_metatype metatype,std::string &res);
 
 /// Convert string to type \b meta-type
-extern type_metatype string2metatype(const string &metastring);
+extern type_metatype string2metatype(const std::string &metastring);
 
 class Architecture;		// Forward declarations
 class PcodeOp;
@@ -158,7 +158,7 @@ class Datatype {
   friend class TypeFactory;
   friend struct DatatypeCompare;
   int4 size;			///< Size (of variable holding a value of this type)
-  string name;			///< Name of type
+  std::string name;			///< Name of type
   type_metatype metatype;	///< Meta-type - type disregarding size
   sub_metatype submeta;		///< Sub-type of of the meta-type, for comparisons
   uint4 flags;			///< Boolean properties of the type
@@ -170,7 +170,7 @@ class Datatype {
   void markComplete(void) { flags &= ~(uint4)type_incomplete; }		///< Mark \b this data-type as completely defined
   void setDisplayFormat(uint4 format);		///< Set a specific display format
   virtual Datatype *clone(void) const=0;	///< Clone the data-type
-  static uint8 hashName(const string &nm);	///< Produce a data-type id by hashing the type name
+  static uint8 hashName(const std::string &nm);	///< Produce a data-type id by hashing the type name
   static uint8 hashSize(uint8 id,int4 size);	///< Reversibly hash size into id
 public:
   /// Construct the base data-type copying low-level properties of another
@@ -200,16 +200,16 @@ class Datatype {
   sub_metatype getSubMeta(void) const { return submeta; }	///< Get the \b sub-metatype
   uint8 getId(void) const { return id; }			///< Get the type id
   int4 getSize(void) const { return size; }			///< Get the type size
-  const string &getName(void) const { return name; }		///< Get the type name
+  const std::string &getName(void) const { return name; }		///< Get the type name
   Datatype *getTypedef(void) const { return typedefImm; }	///< Get the data-type immediately typedefed by \e this (or null)
-  virtual void printRaw(ostream &s) const;			///< Print a description of the type to stream
+  virtual void printRaw(std::ostream &s) const;			///< Print a description of the type to stream
   virtual const TypeField *findTruncation(int4 off,int4 sz,const PcodeOp *op,int4 slot,int4 &newoff) const;
   virtual Datatype *getSubType(uintb off,uintb *newoff) const; ///< Recover component data-type one-level down
   virtual Datatype *nearestArrayedComponentForward(uintb off,uintb *newoff,int4 *elSize) const;
   virtual Datatype *nearestArrayedComponentBackward(uintb off,uintb *newoff,int4 *elSize) const;
   virtual int4 numDepend(void) const { return 0; }	///< Return number of component sub-types
   virtual Datatype *getDepend(int4 index) const { return (Datatype *)0; }	///< Return the i-th component sub-type
-  virtual void printNameBase(ostream &s) const { if (!name.empty()) s<<name[0]; } ///< Print name as short prefix
+  virtual void printNameBase(std::ostream &s) const { if (!name.empty()) s<<name[0]; } ///< Print name as short prefix
   virtual int4 compare(const Datatype &op,int4 level) const; ///< Order types for propagation
   virtual int4 compareDependency(const Datatype &op) const; ///< Compare for storage in tree structure
   virtual void encode(Encoder &encoder) const;	///< Encode the data-type to a stream
@@ -222,8 +222,8 @@ class Datatype {
   int4 typeOrder(const Datatype &op) const { if (this==&op) return 0; return compare(op,10); }	///< Order this with -op- datatype
   int4 typeOrderBool(const Datatype &op) const;	///< Order \b this with -op-, treating \e bool data-type as special
   void encodeRef(Encoder &encoder) const;	///< Encode a reference of \b this to a stream
-  static uint4 encodeIntegerFormat(const string &val);
-  static string decodeIntegerFormat(uint4 val);
+  static uint4 encodeIntegerFormat(const std::string &val);
+  static std::string decodeIntegerFormat(uint4 val);
 };
 
 /// \brief A field within a structure or union
@@ -231,10 +231,10 @@ class TypeField {
 public:
   int4 ident;			///< Id for identifying \b this within its containing structure or union
   int4 offset;			///< Offset (into containing structure or union) of subfield
-  string name;			///< Name of subfield
+  std::string name;			///< Name of subfield
   Datatype *type;		///< Data-type of subfield
   TypeField(Decoder &decoder,TypeFactory &typegrp);	///< Restore \b this field from a stream
-  TypeField(int4 id,int4 off,const string &nm,Datatype *ct) { ident=id; offset=off; name=nm; type=ct; }	///< Construct from components
+  TypeField(int4 id,int4 off,const std::string &nm,Datatype *ct) { ident=id; offset=off; name=nm; type=ct; }	///< Construct from components
   bool operator<(const TypeField &op2) const { return (offset < op2.offset); }	///< Compare based on offset
   void encode(Encoder &encoder) const;			///< Encode \b this field to a stream
 };
@@ -258,10 +258,10 @@ struct DatatypeNameCompare {
 };
 
 /// A set of data-types sorted by function
-typedef set<Datatype *,DatatypeCompare> DatatypeSet;
+typedef std::set<Datatype *,DatatypeCompare> DatatypeSet;
 
 /// A set of data-types sorted by name
-typedef set<Datatype *,DatatypeNameCompare> DatatypeNameSet;
+typedef std::set<Datatype *,DatatypeNameCompare> DatatypeNameSet;
 
 /// \brief Base class for the fundamental atomic types.
 ///
@@ -275,7 +275,7 @@ class TypeBase : public Datatype {
   /// Construct TypeBase from a size and meta-type
   TypeBase(int4 s,type_metatype m) : Datatype(s,m) {}
   /// Construct TypeBase from a size, meta-type, and name
-  TypeBase(int4 s,type_metatype m,const string &n) : Datatype(s,m) { name = n; }
+  TypeBase(int4 s,type_metatype m,const std::string &n) : Datatype(s,m) { name = n; }
   virtual Datatype *clone(void) const { return new TypeBase(*this); }
 };
 
@@ -290,7 +290,7 @@ class TypeChar : public TypeBase {
   /// Construct TypeChar copying properties from another data-type
   TypeChar(const TypeChar &op) : TypeBase(op) { flags |= Datatype::chartype; }
   /// Construct a char (always 1-byte) given a name
-  TypeChar(const string &n) : TypeBase(1,TYPE_INT,n) { flags |= Datatype::chartype; submeta = SUB_INT_CHAR; }
+  TypeChar(const std::string &n) : TypeBase(1,TYPE_INT,n) { flags |= Datatype::chartype; submeta = SUB_INT_CHAR; }
   virtual Datatype *clone(void) const { return new TypeChar(*this); }
   virtual void encode(Encoder &encoder) const;
 };
@@ -306,7 +306,7 @@ class TypeUnicode : public TypeBase { // Unicode character type
 public:
   TypeUnicode(void) : TypeBase(0,TYPE_INT) {} ///< For use with decode
   TypeUnicode(const TypeUnicode &op) : TypeBase(op) {}	///< Construct from another TypeUnicode
-  TypeUnicode(const string &nm,int4 sz,type_metatype m);	///< Construct given name,size, meta-type
+  TypeUnicode(const std::string &nm,int4 sz,type_metatype m);	///< Construct given name,size, meta-type
   virtual Datatype *clone(void) const { return new TypeUnicode(*this); }
   virtual void encode(Encoder &encoder) const;
 };
@@ -350,10 +350,10 @@ class TypePointer : public Datatype {
   Datatype *getPtrTo(void) const { return ptrto; }	///< Get the pointed-to Datatype
   uint4 getWordSize(void) const { return wordsize; }	///< Get the size of the addressable unit being pointed to
   AddrSpace *getSpace(void) const { return spaceid; }	///< Get any address space associated with \b this pointer
-  virtual void printRaw(ostream &s) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual int4 numDepend(void) const { return 1; }
   virtual Datatype *getDepend(int4 index) const { return ptrto; }
-  virtual void printNameBase(ostream &s) const { s << 'p'; ptrto->printNameBase(s); }
+  virtual void printNameBase(std::ostream &s) const { s << 'p'; ptrto->printNameBase(s); }
   virtual int4 compare(const Datatype &op,int4 level) const;
   virtual int4 compareDependency(const Datatype &op) const;
   virtual Datatype *clone(void) const { return new TypePointer(*this); }
@@ -381,11 +381,11 @@ class TypeArray : public Datatype {
   Datatype *getBase(void) const { return arrayof; }	///< Get the element data-type
   int4 numElements(void) const { return arraysize; }	///< Get the number of elements
   Datatype *getSubEntry(int4 off,int4 sz,int4 *newoff,int4 *el) const;	///< Figure out what a byte range overlaps
-  virtual void printRaw(ostream &s) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual Datatype *getSubType(uintb off,uintb *newoff) const;
   virtual int4 numDepend(void) const { return 1; }
   virtual Datatype *getDepend(int4 index) const { return arrayof; }
-  virtual void printNameBase(ostream &s) const { s << 'a'; arrayof->printNameBase(s); }
+  virtual void printNameBase(std::ostream &s) const { s << 'a'; arrayof->printNameBase(s); }
   virtual int4 compare(const Datatype &op,int4 level) const; // For tree structure
   virtual int4 compareDependency(const Datatype &op) const; // For tree structure
   virtual Datatype *clone(void) const { return new TypeArray(*this); }
@@ -402,9 +402,9 @@ class TypeArray : public Datatype {
 class TypeEnum : public TypeBase {
 protected:
   friend class TypeFactory;
-  map<uintb,string> namemap;	///< Map from integer to name
-  vector<uintb> masklist;	///< Masks for each bitfield within the enum
-  void setNameMap(const map<uintb,string> &nmap);	///< Establish the value -> name map
+  std::map<uintb,std::string> namemap;	///< Map from integer to name
+  std::vector<uintb> masklist;	///< Masks for each bitfield within the enum
+  void setNameMap(const std::map<uintb,std::string> &nmap);	///< Establish the value -> name map
   void decode(Decoder &decoder,TypeFactory &typegrp);	///< Restore \b this enum data-type from a stream
 public:
   /// Construct from another TypeEnum
@@ -413,11 +413,11 @@ class TypeEnum : public TypeBase {
   TypeEnum(int4 s,type_metatype m) : TypeBase(s,m) {
     flags |= enumtype; submeta = (m==TYPE_INT) ? SUB_INT_ENUM : SUB_UINT_ENUM; }
   /// Construct from a size, meta-type, and name
-  TypeEnum(int4 s,type_metatype m,const string &nm) : TypeBase(s,m,nm) {
+  TypeEnum(int4 s,type_metatype m,const std::string &nm) : TypeBase(s,m,nm) {
     flags |= enumtype; submeta = (m==TYPE_INT) ? SUB_INT_ENUM : SUB_UINT_ENUM; }
-  map<uintb,string>::const_iterator beginEnum(void) const { return namemap.begin(); }	///< Beginning of name map
-  map<uintb,string>::const_iterator endEnum(void) const { return namemap.end(); }	///< End of name map
-  bool getMatches(uintb val,vector<string> &matchname) const;	///< Recover the named representation
+  std::map<uintb,std::string>::const_iterator beginEnum(void) const { return namemap.begin(); }	///< Beginning of name map
+  std::map<uintb,std::string>::const_iterator endEnum(void) const { return namemap.end(); }	///< End of name map
+  bool getMatches(uintb val,std::vector<std::string> &matchname) const;	///< Recover the named representation
   virtual int4 compare(const Datatype &op,int4 level) const;
   virtual int4 compareDependency(const Datatype &op) const;
   virtual Datatype *clone(void) const { return new TypeEnum(*this); }
@@ -428,8 +428,8 @@ class TypeEnum : public TypeBase {
 class TypeStruct : public Datatype {
 protected:
   friend class TypeFactory;
-  vector<TypeField> field;			///< The list of fields
-  void setFields(const vector<TypeField> &fd);	///< Establish fields for \b this
+  std::vector<TypeField> field;			///< The list of fields
+  void setFields(const std::vector<TypeField> &fd);	///< Establish fields for \b this
   int4 getFieldIter(int4 off) const;		///< Get index into field list
   int4 getLowerBoundField(int4 off) const;	///< Get index of last field before or equal to given offset
   void decodeFields(Decoder &decoder,TypeFactory &typegrp);	///< Restore fields from a stream
@@ -437,8 +437,8 @@ class TypeStruct : public Datatype {
 public:
   TypeStruct(const TypeStruct &op);	///< Construct from another TypeStruct
   TypeStruct(void) : Datatype(0,TYPE_STRUCT) { flags |= type_incomplete; }	///< Construct incomplete/empty TypeStruct
-  vector<TypeField>::const_iterator beginField(void) const { return field.begin(); }	///< Beginning of fields
-  vector<TypeField>::const_iterator endField(void) const { return field.end(); }	///< End of fields
+  std::vector<TypeField>::const_iterator beginField(void) const { return field.begin(); }	///< Beginning of fields
+  std::vector<TypeField>::const_iterator endField(void) const { return field.end(); }	///< End of fields
   virtual const TypeField *findTruncation(int4 off,int4 sz,const PcodeOp *op,int4 slot,int4 &newoff) const;
   virtual Datatype *getSubType(uintb off,uintb *newoff) const;
   virtual Datatype *nearestArrayedComponentForward(uintb off,uintb *newoff,int4 *elSize) const;
@@ -452,7 +452,7 @@ class TypeStruct : public Datatype {
   virtual Datatype *resolveInFlow(PcodeOp *op,int4 slot);
   virtual Datatype* findResolve(const PcodeOp *op,int4 slot);
   virtual int4 findCompatibleResolve(Datatype *ct) const;
-  static void assignFieldOffsets(vector<TypeField> &list,int4 align);	///< Assign field offsets given a byte alignment
+  static void assignFieldOffsets(std::vector<TypeField> &list,int4 align);	///< Assign field offsets given a byte alignment
 };
 
 /// \brief A collection of overlapping Datatype objects: A \b union of component \b fields
@@ -462,8 +462,8 @@ class TypeStruct : public Datatype {
 class TypeUnion : public Datatype {
 protected:
   friend class TypeFactory;
-  vector<TypeField> field;			///< The list of fields
-  void setFields(const vector<TypeField> &fd);	///< Establish fields for \b this
+  std::vector<TypeField> field;			///< The list of fields
+  void setFields(const std::vector<TypeField> &fd);	///< Establish fields for \b this
   void decodeFields(Decoder &decoder,TypeFactory &typegrp);	///< Restore fields from a stream
 public:
   TypeUnion(const TypeUnion &op);	///< Construct from another TypeUnion
@@ -499,7 +499,7 @@ class TypePartialUnion : public Datatype {
   TypePartialUnion(const TypePartialUnion &op);			///< Construct from another TypePartialUnion
   TypePartialUnion(TypeUnion *contain,int4 off,int4 sz,Datatype *strip);	///< Constructor
   TypeUnion *getParentUnion(void) const { return container; }	///< Get the union which \b this is part of
-  virtual void printRaw(ostream &s) const;			///< Print a description of the type to stream
+  virtual void printRaw(std::ostream &s) const;			///< Print a description of the type to stream
   virtual const TypeField *findTruncation(int4 off,int4 sz,const PcodeOp *op,int4 slot,int4 &newoff) const;
   virtual int4 numDepend(void);
   virtual Datatype *getDepend(int4 index);
@@ -543,7 +543,7 @@ class TypePointerRel : public TypePointer {
   ///
   /// \return the offset value in \e address \e units
   int4 getPointerOffset(void) const { return AddrSpace::byteToAddressInt(offset, wordsize); }
-  virtual void printRaw(ostream &s) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual int4 compare(const Datatype &op,int4 level) const;
   virtual int4 compareDependency(const Datatype &op) const;
   virtual Datatype *clone(void) const { return new TypePointerRel(*this); }
@@ -566,7 +566,7 @@ class TypeCode : public Datatype {
   FuncProto *proto;		///< If non-null, this describes the prototype of the underlying function
   TypeFactory *factory;		///< Factory owning \b this
   void setPrototype(TypeFactory *tfact,ProtoModel *model,
-		    Datatype *outtype,const vector<Datatype *> &intypes,
+		    Datatype *outtype,const std::vector<Datatype *> &intypes,
 		    bool dotdotdot,Datatype *voidtype);	///< Establish a function pointer
   void setPrototype(TypeFactory *typegrp,const FuncProto *fp);	///< Set a particular function prototype on \b this
   void decodeStub(Decoder &decoder);		///< Restore stub of data-type without the full prototype
@@ -577,7 +577,7 @@ class TypeCode : public Datatype {
   int4 compareBasic(const TypeCode *op) const;	///< Compare surface characteristics of two TypeCodes
   const FuncProto *getPrototype(void) const { return proto; }	///< Get the function prototype
   virtual ~TypeCode(void);
-  virtual void printRaw(ostream &s) const;
+  virtual void printRaw(std::ostream &s) const;
   virtual Datatype *getSubType(uintb off,uintb *newoff) const;
   virtual int4 compare(const Datatype &op,int4 level) const;
   virtual int4 compareDependency(const Datatype &op) const;
@@ -631,21 +631,21 @@ class TypeFactory {
   Datatype *findNoName(Datatype &ct);	///< Find data-type (in this container) by function
   void insert(Datatype *newtype);	///< Insert pointer into the cross-reference sets
   Datatype *findAdd(Datatype &ct);	///< Find data-type in this container or add it
-  void orderRecurse(vector<Datatype *> &deporder,DatatypeSet &mark,Datatype *ct) const;	///< Write out dependency list
+  void orderRecurse(std::vector<Datatype *> &deporder,DatatypeSet &mark,Datatype *ct) const;	///< Write out dependency list
   Datatype *decodeTypedef(Decoder &decoder);		///< Restore a \<def> element describing a typedef
   Datatype *decodeStruct(Decoder &decoder,bool forcecore);	///< Restore a \<type> element describing a structure
   Datatype *decodeUnion(Decoder &decoder,bool forcecore);	///< Restore a \<type> element describing a union
   Datatype *decodeCode(Decoder &decoder,bool isConstructor,bool isDestructor,bool forcecore);	///< Restore an element describing a code object
   Datatype *decodeTypeNoRef(Decoder &decoder,bool forcecore);	///< Restore from a stream
   void clearCache(void);		///< Clear the common type cache
-  TypeChar *getTypeChar(const string &n);	///< Create a default "char" type
-  TypeUnicode *getTypeUnicode(const string &nm,int4 sz,type_metatype m);	///< Create a default "unicode" type
-  TypeCode *getTypeCode(const string &n);	///< Create a default "code" type
+  TypeChar *getTypeChar(const std::string &n);	///< Create a default "char" type
+  TypeUnicode *getTypeUnicode(const std::string &nm,int4 sz,type_metatype m);	///< Create a default "unicode" type
+  TypeCode *getTypeCode(const std::string &n);	///< Create a default "code" type
   void recalcPointerSubmeta(Datatype *base,sub_metatype sub);	///< Recalculate submeta for pointers to given base data-type
 protected:
   Architecture *glb;		///< The Architecture object that owns this TypeFactory
-  Datatype *findByIdLocal(const string &nm,uint8 id) const;	///< Search locally by name and id
-  virtual Datatype *findById(const string &n,uint8 id,int4 sz);		///< Search by \e name and/or \e id
+  Datatype *findByIdLocal(const std::string &nm,uint8 id) const;	///< Search locally by name and id
+  virtual Datatype *findById(const std::string &n,uint8 id,int4 sz);		///< Search by \e name and/or \e id
 public:
   TypeFactory(Architecture *g);	///< Construct a factory
   void setupSizes(void);	///< Derive some size information from Architecture
@@ -657,50 +657,50 @@ class TypeFactory {
   int4 getSizeOfInt(void) const { return sizeOfInt; }	///< Get the size of the default "int"
   int4 getSizeOfLong(void) const { return sizeOfLong; }	///< Get the size of the default "long"
   Architecture *getArch(void) const { return glb; }	///< Get the Architecture object
-  Datatype *findByName(const string &n);		///< Return type of given name
-  Datatype *setName(Datatype *ct,const string &n); 	///< Set the given types name
+  Datatype *findByName(const std::string &n);		///< Return type of given name
+  Datatype *setName(Datatype *ct,const std::string &n); 	///< Set the given types name
   void setDisplayFormat(Datatype *ct,uint4 format);	///< Set the display format associated with the given data-type
-  bool setFields(vector<TypeField> &fd,TypeStruct *ot,int4 fixedsize,uint4 flags);	///< Set fields on a TypeStruct
-  bool setFields(vector<TypeField> &fd,TypeUnion *ot,int4 fixedsize,uint4 flags);	///< Set fields on a TypeUnion
+  bool setFields(std::vector<TypeField> &fd,TypeStruct *ot,int4 fixedsize,uint4 flags);	///< Set fields on a TypeStruct
+  bool setFields(std::vector<TypeField> &fd,TypeUnion *ot,int4 fixedsize,uint4 flags);	///< Set fields on a TypeUnion
   void setPrototype(const FuncProto *fp,TypeCode *newCode,uint4 flags);	///< Set the prototype on a TypeCode
-  bool setEnumValues(const vector<string> &namelist,
-		      const vector<uintb> &vallist,
-		      const vector<bool> &assignlist,
+  bool setEnumValues(const std::vector<std::string> &namelist,
+		      const std::vector<uintb> &vallist,
+		      const std::vector<bool> &assignlist,
 		      TypeEnum *te);		///< Set named values for an enumeration
   Datatype *decodeType(Decoder &decoder);	///< Restore Datatype from a stream
   Datatype *decodeTypeWithCodeFlags(Decoder &decoder,bool isConstructor,bool isDestructor);
   TypeVoid *getTypeVoid(void);					///< Get the "void" data-type
   Datatype *getBaseNoChar(int4 s,type_metatype m);		///< Get atomic type excluding "char"
   Datatype *getBase(int4 s,type_metatype m);			///< Get atomic type
-  Datatype *getBase(int4 s,type_metatype m,const string &n);	///< Get named atomic type
+  Datatype *getBase(int4 s,type_metatype m,const std::string &n);	///< Get named atomic type
   TypeCode *getTypeCode(void);					///< Get an "anonymous" function data-type
   TypePointer *getTypePointerStripArray(int4 s,Datatype *pt,uint4 ws);	///< Construct a pointer data-type, stripping an ARRAY level
   TypePointer *getTypePointer(int4 s,Datatype *pt,uint4 ws);	///< Construct an absolute pointer data-type
-  TypePointer *getTypePointer(int4 s,Datatype *pt,uint4 ws,const string &n);	///< Construct a named pointer data-type
+  TypePointer *getTypePointer(int4 s,Datatype *pt,uint4 ws,const std::string &n);	///< Construct a named pointer data-type
   TypePointer *getTypePointerNoDepth(int4 s,Datatype *pt,uint4 ws);	///< Construct a depth limited pointer data-type
   TypeArray *getTypeArray(int4 as,Datatype *ao);		///< Construct an array data-type
-  TypeStruct *getTypeStruct(const string &n);			///< Create an (empty) structure
-  TypeUnion *getTypeUnion(const string &n);			///< Create an (empty) union
+  TypeStruct *getTypeStruct(const std::string &n);			///< Create an (empty) structure
+  TypeUnion *getTypeUnion(const std::string &n);			///< Create an (empty) union
   TypePartialUnion *getTypePartialUnion(TypeUnion *contain,int4 off,int4 sz);	///< Create a partial union
-  TypeEnum *getTypeEnum(const string &n);			///< Create an (empty) enumeration
+  TypeEnum *getTypeEnum(const std::string &n);			///< Create an (empty) enumeration
   TypeSpacebase *getTypeSpacebase(AddrSpace *id,const Address &addr);	///< Create a "spacebase" type
   TypeCode *getTypeCode(ProtoModel *model,Datatype *outtype,
-			const vector<Datatype *> &intypes,
+			const std::vector<Datatype *> &intypes,
 			bool dotdotdot);			///< Create a "function" datatype
-  Datatype *getTypedef(Datatype *ct,const string &name,uint8 id,uint4 format);	///< Create a new \e typedef data-type
+  Datatype *getTypedef(Datatype *ct,const std::string &name,uint8 id,uint4 format);	///< Create a new \e typedef data-type
   TypePointerRel *getTypePointerRel(TypePointer *parentPtr,Datatype *ptrTo,int4 off);	///< Get pointer offset relative to a container
-  TypePointerRel *getTypePointerRel(int4 sz,Datatype *parent,Datatype *ptrTo,int4 ws,int4 off,const string &nm);
-  TypePointer *getTypePointerWithSpace(Datatype *ptrTo,AddrSpace *spc,const string &nm);
+  TypePointerRel *getTypePointerRel(int4 sz,Datatype *parent,Datatype *ptrTo,int4 ws,int4 off,const std::string &nm);
+  TypePointer *getTypePointerWithSpace(Datatype *ptrTo,AddrSpace *spc,const std::string &nm);
   void destroyType(Datatype *ct);				///< Remove a data-type from \b this
   Datatype *concretize(Datatype *ct);				///< Convert given data-type to concrete form
-  void dependentOrder(vector<Datatype *> &deporder) const;	///< Place all data-types in dependency order
+  void dependentOrder(std::vector<Datatype *> &deporder) const;	///< Place all data-types in dependency order
   void encode(Encoder &encoder) const;			///< Encode \b this container to stream
   void encodeCoreTypes(Encoder &encoder) const;		///< Encode core types to stream
   void decode(Decoder &decoder);			///< Decode \b this from a \<typegrp> element
   void decodeCoreTypes(Decoder &decoder);		///< Initialize basic data-types from a stream
   void decodeDataOrganization(Decoder &decoder);	///< Parse a \<data_organization> element
   void parseEnumConfig(Decoder &decoder);		///< Parse the \<enum> tag
-  void setCoreType(const string &name,int4 size,type_metatype meta,bool chartp);	///< Create a core data-type
+  void setCoreType(const std::string &name,int4 size,type_metatype meta,bool chartp);	///< Create a core data-type
   void cacheCoreTypes(void);				///< Cache common types
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.cc
index 351e3df1a..dcc279aaf 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.cc
@@ -15,6 +15,8 @@
  */
 #include "typegrp_ghidra.hh"
 
+using namespace std;
+
 Datatype *TypeFactoryGhidra::findById(const string &n,uint8 id,int4 sz)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.hh
index 847dec7da..91de00eea 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/typegrp_ghidra.hh
@@ -29,7 +29,7 @@
 /// converted into a Datatype object and cached in this object.
 class TypeFactoryGhidra : public TypeFactory {
 protected:
-  virtual Datatype *findById(const string &n,uint8 id,int4 sz);
+  virtual Datatype *findById(const std::string &n,uint8 id,int4 sz);
 public:
   TypeFactoryGhidra(ArchitectureGhidra *g) : TypeFactory(g) {}	///< Constructor
   virtual ~TypeFactoryGhidra(void) {}
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
index 11000806f..210d7ae99 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.cc
@@ -17,6 +17,8 @@
 #include "funcdata.hh"
 #include <cmath>
 
+using namespace std;
+
 /// \param inst will hold the array of TypeOp objects, indexed on op-code
 /// \param tlst is the corresponding TypeFactory for the Architecture
 /// \param trans is the Translate object for floating-point formats
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.hh
index f8976eb5e..c90401b52 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/typeop.hh
@@ -46,15 +46,15 @@ class TypeOp {
   OpCode opcode;		///< The op-code value
   uint4 opflags;		///< Cached pcode-op properties for this op-code
   uint4 addlflags;		///< Additional properties
-  string name;			///< Symbol denoting this operation
+  std::string name;			///< Symbol denoting this operation
   OpBehavior *behave;		///< Object for emulating the behavior of the op-code
   virtual void setMetatypeIn(type_metatype val) {}	///< Set the data-type associated with inputs to this opcode
   virtual void setMetatypeOut(type_metatype val) {}	///< Set the data-type associated with outputs of this opcode
-  virtual void setSymbol(const string &nm) { name = nm; }	///< Set the display symbol associated with the op-code
+  virtual void setSymbol(const std::string &nm) { name = nm; }	///< Set the display symbol associated with the op-code
 public:
-  TypeOp(TypeFactory *t,OpCode opc,const string &n);	///< Constructor
+  TypeOp(TypeFactory *t,OpCode opc,const std::string &n);	///< Constructor
   virtual ~TypeOp(void);				///< Destructor
-  const string &getName(void) const { return name; }	///< Get the display name of the op-code
+  const std::string &getName(void) const { return name; }	///< Get the display name of the op-code
   OpCode getOpcode(void) const { return opcode; }	///< Get the op-code value
   uint4 getFlags(void) const { return opflags; }	///< Get the properties associated with the op-code
   OpBehavior *getBehavior(void) const { return behave; }	///< Get the behavior associated with the op-code
@@ -140,21 +140,21 @@ class TypeOp {
   ///
   /// \param s is the output stream
   /// \param op is the specific PcodeOp to print
-  virtual void printRaw(ostream &s,const PcodeOp *op)=0;
+  virtual void printRaw(std::ostream &s,const PcodeOp *op)=0;
 
   /// \brief Get the name of the op-code as it should be displayed in context.
   ///
   /// Depending on the context, the same op-code may get displayed in different ways.
   /// \param op is the PcodeOp context
   /// \return the display token
-  virtual string getOperatorName(const PcodeOp *op) const { return name; }
+  virtual std::string getOperatorName(const PcodeOp *op) const { return name; }
 
   /// \brief Build a map from op-code value to the TypeOp information objects
-  static void registerInstructions(vector<TypeOp *> &inst,TypeFactory *tlst,
+  static void registerInstructions(std::vector<TypeOp *> &inst,TypeFactory *tlst,
 				   const Translate *trans);
 
   /// \brief Toggle Java specific aspects of the op-code information
-  static void selectJavaOperators(vector<TypeOp *> &inst,bool val);
+  static void selectJavaOperators(std::vector<TypeOp *> &inst,bool val);
 };
 
 // Major classes of operations
@@ -169,11 +169,11 @@ class TypeOpBinary : public TypeOp {
   virtual void setMetatypeIn(type_metatype val) { metain = val; }
   virtual void setMetatypeOut(type_metatype val) { metaout = val; }
 public:
-  TypeOpBinary(TypeFactory *t,OpCode opc,const string &n,type_metatype mout,type_metatype min)
+  TypeOpBinary(TypeFactory *t,OpCode opc,const std::string &n,type_metatype mout,type_metatype min)
     : TypeOp(t,opc,n) { metaout = mout; metain = min; }	///< Constructor
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief A generic unary operator: one input and one output
@@ -186,11 +186,11 @@ class TypeOpUnary : public TypeOp {
   virtual void setMetatypeIn(type_metatype val) { metain = val; }
   virtual void setMetatypeOut(type_metatype val) { metaout = val; }
 public:
-  TypeOpUnary(TypeFactory *t,OpCode opc,const string &n,type_metatype mout,type_metatype min)
+  TypeOpUnary(TypeFactory *t,OpCode opc,const std::string &n,type_metatype mout,type_metatype min)
     : TypeOp(t,opc,n) { metaout = mout; metain = min; }	///< Constructor
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief A generic functional operator.
@@ -203,11 +203,11 @@ class TypeOpFunc : public TypeOp {
   virtual void setMetatypeIn(type_metatype val) { metain = val; }
   virtual void setMetatypeOut(type_metatype val) { metaout = val; }
 public:
-  TypeOpFunc(TypeFactory *t,OpCode opc,const string &n,type_metatype mout,type_metatype min)
+  TypeOpFunc(TypeFactory *t,OpCode opc,const std::string &n,type_metatype mout,type_metatype min)
     : TypeOp(t,opc,n) { metaout = mout; metain = min; }		///< Constructor
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 // A class for each op-code
@@ -221,7 +221,7 @@ class TypeOpCopy : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCopy(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the LOAD op-code
@@ -234,7 +234,7 @@ class TypeOpLoad : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opLoad(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the STORE op-code
@@ -246,7 +246,7 @@ class TypeOpStore : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opStore(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the BRANCH op-code
@@ -254,7 +254,7 @@ class TypeOpBranch : public TypeOp {
 public:
   TypeOpBranch(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opBranch(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the CBRANCH op-code
@@ -263,7 +263,7 @@ class TypeOpCbranch : public TypeOp {
   TypeOpCbranch(TypeFactory *t);			///< Constructor
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCbranch(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the BRANCHIND op-code
@@ -271,7 +271,7 @@ class TypeOpBranchind : public TypeOp {
 public:
   TypeOpBranchind(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opBranchind(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the CALL op-code
@@ -279,7 +279,7 @@ class TypeOpCall : public TypeOp {
 public:
   TypeOpCall(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCall(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
 };
@@ -289,7 +289,7 @@ class TypeOpCallind : public TypeOp {
 public:
   TypeOpCallind(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCallind(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
 };
@@ -299,8 +299,8 @@ class TypeOpCallother : public TypeOp {
 public:
   TypeOpCallother(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCallother(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
 };
@@ -310,7 +310,7 @@ class TypeOpReturn : public TypeOp {
 public:
   TypeOpReturn(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opReturn(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
 };
 
@@ -381,7 +381,7 @@ class TypeOpIntZext : public TypeOpFunc {
 public:
   TypeOpIntZext(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntZext(op,readOp); }
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual Datatype *getInputCast(const PcodeOp *op,int4 slot,const CastStrategy *castStrategy) const;
 };
 
@@ -390,7 +390,7 @@ class TypeOpIntSext : public TypeOpFunc {
 public:
   TypeOpIntSext(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntSext(op,readOp); }
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual Datatype *getInputCast(const PcodeOp *op,int4 slot,const CastStrategy *castStrategy) const;
 };
 
@@ -419,7 +419,7 @@ class TypeOpIntCarry : public TypeOpFunc {
 public:
   TypeOpIntCarry(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntCarry(op); }
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
 };
 
 /// \brief Information about the INT_SCARRY op-code
@@ -427,7 +427,7 @@ class TypeOpIntScarry : public TypeOpFunc {
 public:
   TypeOpIntScarry(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntScarry(op); }
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
 };
 
 /// \brief Information about the INT_SBORROW op-code
@@ -435,7 +435,7 @@ class TypeOpIntSborrow : public TypeOpFunc {
 public:
   TypeOpIntSborrow(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntSborrow(op); }
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
 };
 
 /// \brief Information about the INT_2COMP op-code
@@ -508,7 +508,7 @@ class TypeOpIntSright : public TypeOpBinary {
 public:
   TypeOpIntSright(TypeFactory *t);			///< Constructor
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIntSright(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
   virtual Datatype *getInputCast(const PcodeOp *op,int4 slot,const CastStrategy *castStrategy) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual Datatype *getOutputToken(const PcodeOp *op,CastStrategy *castStrategy) const;
@@ -715,7 +715,7 @@ class TypeOpMulti : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opMultiequal(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the INDIRECT op-code
@@ -726,7 +726,7 @@ class TypeOpIndirect : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opIndirect(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the PIECE op-code
@@ -734,7 +734,7 @@ class TypeOpPiece : public TypeOpFunc {
 public:
   TypeOpPiece(TypeFactory *t);			///< Constructor
   virtual Datatype *getOutputToken(const PcodeOp *op,CastStrategy *castStrategy) const;
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opPiece(op); }
 };
 
@@ -747,7 +747,7 @@ class TypeOpSubpiece : public TypeOpFunc {
   virtual Datatype *getOutputToken(const PcodeOp *op,CastStrategy *castStrategy) const;
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opSubpiece(op); }
   static const TypeField *testExtraction(bool useHigh,const PcodeOp *op,Datatype *&parent,int4 &offset);
   static int4 computeByteOffsetForComposite(const PcodeOp *op);
@@ -760,7 +760,7 @@ class TypeOpCast : public TypeOp {
 				// We don't care what types are cast
 				// So no input and output requirements
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCast(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
   
 /// \brief Information about the PTRADD op-code
@@ -774,7 +774,7 @@ class TypeOpPtradd : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opPtradd(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the PTRSUB op-code
@@ -788,7 +788,7 @@ class TypeOpPtrsub : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opPtrsub(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the SEGMENTOP op-code
@@ -809,7 +809,7 @@ class TypeOpSegment : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opSegmentOp(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the CPOOLREF op-code
@@ -821,7 +821,7 @@ class TypeOpCpoolref : public TypeOp {
   virtual Datatype *getOutputLocal(const PcodeOp *op) const;
   virtual Datatype *getInputLocal(const PcodeOp *op,int4 slot) const;
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opCpoolRefOp(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the NEW op-code
@@ -832,7 +832,7 @@ class TypeOpNew : public TypeOp {
   virtual Datatype *propagateType(Datatype *alttype,PcodeOp *op,Varnode *invn,Varnode *outvn,
 				  int4 inslot,int4 outslot);
   virtual void push(PrintLanguage *lng,const PcodeOp *op,const PcodeOp *readOp) const { lng->opNewOp(op); }
-  virtual void printRaw(ostream &s,const PcodeOp *op);
+  virtual void printRaw(std::ostream &s,const PcodeOp *op);
 };
 
 /// \brief Information about the INSERT op-code
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
index d848cfc7d..4caefde8d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.cc
@@ -16,6 +16,8 @@
 #ifdef CPUI_RULECOMPILE
 #include "unify.hh"
 
+using namespace std;
+
 UnifyDatatype::UnifyDatatype(uint4 tp)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.hh
index 995f96b44..2522ad5ae 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/unify.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/unify.hh
@@ -49,8 +49,8 @@ class UnifyDatatype {
   BlockBasic *getBlock(void) const { return storespot.bl; }
   void setConstant(uintb val);
   uintb getConstant(void) const { return *storespot.cn; }
-  void printVarDecl(ostream &s,int4 id,const UnifyCPrinter &cprinter) const;
-  string getBaseName(void) const;
+  void printVarDecl(std::ostream &s,int4 id,const UnifyCPrinter &cprinter) const;
+  std::string getBaseName(void) const;
 };
 
 class UnifyState;
@@ -60,7 +60,7 @@ class RHSConstant {		// A construction that results in a constant on the right-h
   virtual ~RHSConstant(void) {}
   virtual RHSConstant *clone(void)=0;
   virtual uintb getConstant(UnifyState &state) const=0;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const=0;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const=0;
 };
 
 class ConstantNamed : public RHSConstant {
@@ -70,7 +70,7 @@ class ConstantNamed : public RHSConstant {
   int4 getId(void) const { return constindex; }
   virtual RHSConstant *clone(void) { return new ConstantNamed(constindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantAbsolute : public RHSConstant {
@@ -80,7 +80,7 @@ class ConstantAbsolute : public RHSConstant {
   uintb getVal(void) const { return val; }
   virtual RHSConstant *clone(void) { return new ConstantAbsolute(val); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantNZMask : public RHSConstant { // A varnode's non-zero mask
@@ -89,7 +89,7 @@ class ConstantNZMask : public RHSConstant { // A varnode's non-zero mask
   ConstantNZMask(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantNZMask(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantConsumed : public RHSConstant { // A varnode's consume mask
@@ -98,7 +98,7 @@ class ConstantConsumed : public RHSConstant { // A varnode's consume mask
   ConstantConsumed(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantConsumed(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantOffset : public RHSConstant { // A varnode's offset
@@ -107,7 +107,7 @@ class ConstantOffset : public RHSConstant { // A varnode's offset
   ConstantOffset(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantOffset(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantIsConstant : public RHSConstant { // TRUE if the varnode is constant
@@ -116,7 +116,7 @@ class ConstantIsConstant : public RHSConstant { // TRUE if the varnode is consta
   ConstantIsConstant(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantIsConstant(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantHeritageKnown : public RHSConstant { // A varnode's consume mask
@@ -125,7 +125,7 @@ class ConstantHeritageKnown : public RHSConstant { // A varnode's consume mask
   ConstantHeritageKnown(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantHeritageKnown(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantVarnodeSize : public RHSConstant { // A varnode's size as an actual constant
@@ -134,7 +134,7 @@ class ConstantVarnodeSize : public RHSConstant { // A varnode's size as an actua
   ConstantVarnodeSize(int4 ind) { varindex = ind; }
   virtual RHSConstant *clone(void) { return new ConstantVarnodeSize(varindex); }
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstantExpression : public RHSConstant {
@@ -145,7 +145,7 @@ class ConstantExpression : public RHSConstant {
   virtual ~ConstantExpression(void);
   virtual RHSConstant *clone(void);
   virtual uintb getConstant(UnifyState &state) const;
-  virtual void writeExpression(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void writeExpression(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class TraverseConstraint {
@@ -159,8 +159,8 @@ class TraverseConstraint {
 
 class TraverseDescendState : public TraverseConstraint {
   bool onestep;			// true if first step has occurred
-  list<PcodeOp *>::const_iterator iter;	// Different forward branches we could traverse
-  list<PcodeOp *>::const_iterator enditer;
+  std::list<PcodeOp *>::const_iterator iter;	// Different forward branches we could traverse
+  std::list<PcodeOp *>::const_iterator enditer;
 public:
   TraverseDescendState(int4 i) : TraverseConstraint(i) {}
   PcodeOp *getCurrentOp(void) const { return *iter; }
@@ -184,7 +184,7 @@ class TraverseCountState : public TraverseConstraint {
 };
 
 class TraverseGroupState : public TraverseConstraint {
-  vector<TraverseConstraint *> traverselist;
+  std::vector<TraverseConstraint *> traverselist;
   int4 currentconstraint;
   int4 state;
 public:
@@ -212,9 +212,9 @@ class UnifyConstraint {
   virtual bool step(UnifyState &state)=0;
   virtual void buildTraverseState(UnifyState &state);
   virtual void setId(int4 &id) { uniqid = id; id += 1; }
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const {}
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const {}
   virtual int4 getBaseIndex(void) const { return -1; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const=0;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const=0;
   virtual bool isDummy(void) const { return false; }
   virtual void removeDummy(void) {}
 };
@@ -225,9 +225,9 @@ class DummyOpConstraint : public UnifyConstraint {
   DummyOpConstraint(int4 ind) { maxnum = opindex = ind; }
   virtual UnifyConstraint *clone(void) const { return (new DummyOpConstraint(opindex))->copyid(this); }
   virtual bool step(UnifyState &state) { return true; }
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const { typelist[opindex] = UnifyDatatype(UnifyDatatype::op_type); }
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const { typelist[opindex] = UnifyDatatype(UnifyDatatype::op_type); }
   virtual int4 getBaseIndex(void) const { return opindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const {}
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const {}
   virtual bool isDummy(void) const { return true; }
 };
 
@@ -237,9 +237,9 @@ class DummyVarnodeConstraint : public UnifyConstraint {
   DummyVarnodeConstraint(int4 ind) { maxnum = varindex = ind; }
   virtual UnifyConstraint *clone(void) const { return (new DummyVarnodeConstraint(varindex))->copyid(this); }
   virtual bool step(UnifyState &state) { return true; }
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const { typelist[varindex] = UnifyDatatype(UnifyDatatype::var_type); }
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const { typelist[varindex] = UnifyDatatype(UnifyDatatype::var_type); }
   virtual int4 getBaseIndex(void) const { return varindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const {}
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const {}
   virtual bool isDummy(void) const { return true; }
 };
 
@@ -249,9 +249,9 @@ class DummyConstConstraint : public UnifyConstraint {
   DummyConstConstraint(int4 ind) { maxnum = constindex = ind; }
   virtual UnifyConstraint *clone(void) const { return (new DummyConstConstraint(constindex))->copyid(this); }
   virtual bool step(UnifyState &state) { return true; }
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const { typelist[constindex] = UnifyDatatype(UnifyDatatype::const_type); }
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const { typelist[constindex] = UnifyDatatype(UnifyDatatype::const_type); }
   virtual int4 getBaseIndex(void) const { return constindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const {}
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const {}
   virtual bool isDummy(void) const { return true; }
 };
 
@@ -263,7 +263,7 @@ class ConstraintBoolean : public UnifyConstraint { // Constant expression must e
   virtual ~ConstraintBoolean(void) { delete expr; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintBoolean(istrue,expr->clone()))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintVarConst : public UnifyConstraint { // Create a new varnode constant
@@ -275,9 +275,9 @@ class ConstraintVarConst : public UnifyConstraint { // Create a new varnode cons
   virtual ~ConstraintVarConst(void);
   virtual UnifyConstraint *clone(void) const;
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return varindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintNamedExpression : public UnifyConstraint {
@@ -288,9 +288,9 @@ class ConstraintNamedExpression : public UnifyConstraint {
   virtual ~ConstraintNamedExpression(void) { delete expr; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintNamedExpression(constindex,expr->clone()))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return constindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpCopy : public UnifyConstraint {
@@ -300,22 +300,22 @@ class ConstraintOpCopy : public UnifyConstraint {
   ConstraintOpCopy(int4 oldind,int4 newind) { oldopindex = oldind; newopindex = newind; maxnum = (oldopindex > newopindex) ? oldopindex : newopindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpCopy(oldopindex,newopindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return oldopindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpcode : public UnifyConstraint {
   int4 opindex;
-  vector<OpCode> opcodes;	// Which opcodes match
+  std::vector<OpCode> opcodes;	// Which opcodes match
 public:
-  ConstraintOpcode(int4 ind,const vector<OpCode> &o) { maxnum = opindex = ind; opcodes = o; }
-  const vector<OpCode> &getOpCodes(void) const { return opcodes; }
+  ConstraintOpcode(int4 ind,const std::vector<OpCode> &o) { maxnum = opindex = ind; opcodes = o; }
+  const std::vector<OpCode> &getOpCodes(void) const { return opcodes; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpcode(opindex,opcodes))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return opindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpCompare : public UnifyConstraint {
@@ -326,9 +326,9 @@ class ConstraintOpCompare : public UnifyConstraint {
   ConstraintOpCompare(int4 op1ind,int4 op2ind,bool val) { op1index = op1ind; op2index = op2ind; istrue = val; maxnum = (op1index > op2index) ? op1index : op2index; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpCompare(op1index,op2index,istrue))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return op1index; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpInput : public UnifyConstraint {	// Move from op to one of its input varnodes
@@ -339,9 +339,9 @@ class ConstraintOpInput : public UnifyConstraint {	// Move from op to one of its
   ConstraintOpInput(int4 oind,int4 vind,int4 sl) { opindex = oind; varnodeindex = vind; slot = sl; maxnum = (opindex > varnodeindex) ? opindex : varnodeindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpInput(opindex,varnodeindex,slot))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return varnodeindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpInputAny : public UnifyConstraint { // Move from op to ANY of its input varnodes
@@ -352,9 +352,9 @@ class ConstraintOpInputAny : public UnifyConstraint { // Move from op to ANY of
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpInputAny(opindex,varnodeindex))->copyid(this); }
   virtual void initialize(UnifyState &state);
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return varnodeindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOpOutput : public UnifyConstraint {	// Move from op to its output varnode
@@ -364,9 +364,9 @@ class ConstraintOpOutput : public UnifyConstraint {	// Move from op to its outpu
   ConstraintOpOutput(int4 oind,int4 vind) { opindex = oind; varnodeindex = vind; maxnum = (opindex > varnodeindex) ? opindex : varnodeindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOpOutput(opindex,varnodeindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return varnodeindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintParamConstVal : public UnifyConstraint {
@@ -377,8 +377,8 @@ class ConstraintParamConstVal : public UnifyConstraint {
   ConstraintParamConstVal(int4 oind,int4 sl,uintb v) { maxnum = opindex = oind; slot=sl; val = v; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintParamConstVal(opindex,slot,val))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintParamConst : public UnifyConstraint {
@@ -389,9 +389,9 @@ class ConstraintParamConst : public UnifyConstraint {
   ConstraintParamConst(int4 oind,int4 sl,int4 cind) { opindex = oind; slot=sl; constindex = cind; maxnum = (opindex > constindex) ? opindex : constindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintParamConst(opindex,slot,constindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return constindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintVarnodeCopy : public UnifyConstraint {
@@ -401,9 +401,9 @@ class ConstraintVarnodeCopy : public UnifyConstraint {
   ConstraintVarnodeCopy(int4 oldind,int4 newind) { oldvarindex = oldind; newvarindex = newind; maxnum = (oldvarindex > newvarindex) ? oldvarindex : newvarindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintVarnodeCopy(oldvarindex,newvarindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return oldvarindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintVarCompare : public UnifyConstraint {
@@ -414,9 +414,9 @@ class ConstraintVarCompare : public UnifyConstraint {
   ConstraintVarCompare(int4 var1ind,int4 var2ind,bool val) { var1index = var1ind; var2index = var2ind; istrue = val; maxnum = (var1index > var2index) ? var1index : var2index; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintVarCompare(var1index,var2index,istrue))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return var1index; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintDef : public UnifyConstraint {
@@ -426,9 +426,9 @@ class ConstraintDef : public UnifyConstraint {
   ConstraintDef(int4 oind,int4 vind) { opindex = oind; varindex = vind; maxnum = (opindex > varindex) ? opindex : varindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintDef(opindex,varindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return opindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintDescend : public UnifyConstraint {
@@ -440,9 +440,9 @@ class ConstraintDescend : public UnifyConstraint {
   virtual void buildTraverseState(UnifyState &state);
   virtual void initialize(UnifyState &state);
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return opindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintLoneDescend : public UnifyConstraint {
@@ -452,9 +452,9 @@ class ConstraintLoneDescend : public UnifyConstraint {
   ConstraintLoneDescend(int4 oind,int4 vind) { opindex = oind; varindex = vind; maxnum = (opindex > varindex) ? opindex : varindex; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintLoneDescend(opindex,varindex))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return opindex; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintOtherInput : public UnifyConstraint {
@@ -467,8 +467,8 @@ class ConstraintOtherInput : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintOtherInput(opindex,varindex_in,varindex_out))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return varindex_out; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintConstCompare : public UnifyConstraint {
@@ -480,16 +480,16 @@ class ConstraintConstCompare : public UnifyConstraint {
     maxnum = (const1index > const2index) ? const1index : const2index; }
   virtual UnifyConstraint *clone(void) const { return (new ConstraintConstCompare(const1index,const2index,opc))->copyid(this); }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual int4 getBaseIndex(void) const { return const1index; }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 // For a ConstraintGroup, the list of subconstraints must all match for the whole constraint to match.
 // Constraints are tested first to last, i.e. testing for constraint n can assume that 1 thru n-1 match.
 class ConstraintGroup : public UnifyConstraint {
 protected:
-  vector<UnifyConstraint *> constraintlist;
+  std::vector<UnifyConstraint *> constraintlist;
 public:
   ConstraintGroup(void);
   virtual ~ConstraintGroup(void);
@@ -501,11 +501,11 @@ class ConstraintGroup : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const;
   virtual void initialize(UnifyState &state);
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
   virtual void buildTraverseState(UnifyState &state);
   virtual void setId(int4 &id);
   virtual int4 getBaseIndex(void) const { return constraintlist.back()->getBaseIndex(); }
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
   virtual void removeDummy(void);
 };
 
@@ -518,7 +518,7 @@ class ConstraintOr : public ConstraintGroup {
   virtual bool step(UnifyState &state);
   virtual void buildTraverseState(UnifyState &state);
   virtual int4 getBaseIndex(void) const { return -1; } // Does not have a base
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 // Action constraints, these must always step exactly once (returning true), and do their action
@@ -534,8 +534,8 @@ class ConstraintNewOp : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintNewOp(newopindex,oldopindex,opc,insertafter,numparams))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return newopindex; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintNewUniqueOut : public UnifyConstraint {
@@ -547,8 +547,8 @@ class ConstraintNewUniqueOut : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintNewUniqueOut(opindex,newvarindex,sizevarindex))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return newvarindex; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintSetInput : public UnifyConstraint {
@@ -561,8 +561,8 @@ class ConstraintSetInput : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintSetInput(opindex,slot->clone(),varindex))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return varindex; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintSetInputConstVal : public UnifyConstraint {
@@ -575,8 +575,8 @@ class ConstraintSetInputConstVal : public UnifyConstraint {
   virtual ~ConstraintSetInputConstVal(void);
   virtual UnifyConstraint *clone(void) const;
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintRemoveInput : public UnifyConstraint {
@@ -588,8 +588,8 @@ class ConstraintRemoveInput : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintRemoveInput(opindex,slot->clone()))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return opindex; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class ConstraintSetOpcode : public UnifyConstraint {
@@ -600,14 +600,14 @@ class ConstraintSetOpcode : public UnifyConstraint {
   virtual UnifyConstraint *clone(void) const { return (new ConstraintSetOpcode(opindex,opc))->copyid(this); }
   virtual int4 getBaseIndex(void) const { return opindex; }
   virtual bool step(UnifyState &state);
-  virtual void collectTypes(vector<UnifyDatatype> &typelist) const;
-  virtual void print(ostream &s,UnifyCPrinter &printstate) const;
+  virtual void collectTypes(std::vector<UnifyDatatype> &typelist) const;
+  virtual void print(std::ostream &s,UnifyCPrinter &printstate) const;
 };
 
 class UnifyState {
   ConstraintGroup *container;	// containing unifyer
-  vector<UnifyDatatype> storemap;
-  vector<TraverseConstraint *> traverselist;
+  std::vector<UnifyDatatype> storemap;
+  std::vector<TraverseConstraint *> traverselist;
   Funcdata *fd;
 public:
   UnifyState(ConstraintGroup *uni);
@@ -624,32 +624,32 @@ class UnifyState {
 };
 
 class UnifyCPrinter {
-  vector<UnifyDatatype> storemap;
-  vector<string> namemap;
+  std::vector<UnifyDatatype> storemap;
+  std::vector<std::string> namemap;
   int4 depth;
   int4 printingtype;		// 0 = standard rule
-  string classname;		// Name of the printed class
+  std::string classname;		// Name of the printed class
   int4 opparam;
-  vector<OpCode> opcodelist;	// List of opcodes that are recognized by rule
+  std::vector<OpCode> opcodelist;	// List of opcodes that are recognized by rule
   void initializeBase(ConstraintGroup *g);
-  void printGetOpList(ostream &s);
-  void printRuleHeader(ostream &s);
+  void printGetOpList(std::ostream &s);
+  void printRuleHeader(std::ostream &s);
   ConstraintGroup *grp;
 public:
   UnifyCPrinter(void) { grp = (ConstraintGroup *)0; opparam = -1; printingtype=0; }
   int4 getDepth(void) const { return depth; }
   void incDepth(void) { depth += 1; }
   void decDepth(void) { depth -= 1; }
-  void printIndent(ostream &s) const { for(int4 i=0;i<depth+1;++i) s << "  "; }
-  void printAbort(ostream &s);
-  void popDepth(ostream &s,int4 newdepth);
-  const string &getName(int4 id) const { return namemap[id]; }
-  void initializeRuleAction(ConstraintGroup *g,int4 opparam,const vector<OpCode> &olist);
+  void printIndent(std::ostream &s) const { for(int4 i=0;i<depth+1;++i) s << "  "; }
+  void printAbort(std::ostream &s);
+  void popDepth(std::ostream &s,int4 newdepth);
+  const std::string &getName(int4 id) const { return namemap[id]; }
+  void initializeRuleAction(ConstraintGroup *g,int4 opparam,const std::vector<OpCode> &olist);
   void initializeBasic(ConstraintGroup *g);
-  void setClassName(const string &nm) { classname = nm; }
-  void addNames(const map<string,int4> &nmmap);
-  void printVarDecls(ostream &s) const;
-  void print(ostream &s);
+  void setClassName(const std::string &nm) { classname = nm; }
+  void addNames(const std::map<std::string,int4> &nmmap);
+  void printVarDecls(std::ostream &s) const;
+  void print(std::ostream &s);
 	     
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.cc
index 940d33322..055662fb9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.cc
@@ -16,6 +16,8 @@
 #include "unionresolve.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 /// The original parent must either be a union, a pointer to a union, or a partial union.
 /// The object is set up initially to resolve to the parent.
 /// \param parent is the original parent data-type
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.hh
index c60c70601..77e85c1a6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/unionresolve.hh
@@ -132,11 +132,11 @@ class ScoreUnionFields {
     }
   };
   TypeFactory &typegrp;		///< The factory containing data-types
-  vector<int4> scores;		///< Score for each field, indexed by fieldNum + 1 (whole union is index=0)
-  vector<Datatype *> fields;	///< Field corresponding to each score
-  set<VisitMark> visited;	///< Places that have already been visited
-  list<Trial> trialCurrent;	///< Current trials being pushed
-  list<Trial> trialNext;	///< Next set of trials
+  std::vector<int4> scores;		///< Score for each field, indexed by fieldNum + 1 (whole union is index=0)
+  std::vector<Datatype *> fields;	///< Field corresponding to each score
+  std::set<VisitMark> visited;	///< Places that have already been visited
+  std::list<Trial> trialCurrent;	///< Current trials being pushed
+  std::list<Trial> trialNext;	///< Next set of trials
   ResolvedUnion result;		///< The best result
   int4 trialCount;		///< Number of trials evaluated so far
   static const int4 maxPasses;	///< Maximum number of levels to score through
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
index e60353941..d32919020 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.cc
@@ -16,6 +16,8 @@
 #include "userop.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_FARPOINTER = AttributeId("farpointer",85);
 AttributeId ATTRIB_INPUTOP = AttributeId("inputop",86);
 AttributeId ATTRIB_OUTPUTOP = AttributeId("outputop",87);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.hh
index a283255cb..d99f16029 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/userop.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/userop.hh
@@ -49,14 +49,14 @@ class UserPcodeOp {
     no_operator = 2		///< Don't emit special token, just emit the first input parameter as expression
   };
 protected:
-  string name;			///< Low-level name of p-code operator
+  std::string name;			///< Low-level name of p-code operator
   int4 useropindex;		///< Index passed in the CALLOTHER op
   Architecture *glb;		///< Architecture owning the user defined op
   uint4 flags;			///< Boolean attributes of the CALLOTHER
 public:
-  UserPcodeOp(Architecture *g,const string &nm,int4 ind) {
+  UserPcodeOp(Architecture *g,const std::string &nm,int4 ind) {
     name = nm; useropindex = ind; glb = g; flags = 0; }		///< Construct from name and index
-  const string &getName(void) const { return name; }		///< Get the low-level name of the p-code op
+  const std::string &getName(void) const { return name; }		///< Get the low-level name of the p-code op
   int4 getIndex(void) const { return useropindex; }		///< Get the constant id of the op
   uint4 getDisplay(void) const { return (flags & (annotation_assignment | no_operator)); }	///< Get display type (0=functional)
   virtual ~UserPcodeOp(void) {}					///< Destructor
@@ -67,7 +67,7 @@ class UserPcodeOp {
   /// tailored more than the low-level name
   /// \param op is the operation (in context) where a symbol is needed
   /// \return the symbol as a string
-  virtual string getOperatorName(const PcodeOp *op) const {
+  virtual std::string getOperatorName(const PcodeOp *op) const {
     return name; }
 
   /// \brief Assign a size to an annotation input to \b this userop
@@ -92,7 +92,7 @@ class UserPcodeOp {
 /// but still has an unknown effect.
 class UnspecializedPcodeOp : public UserPcodeOp {
 public:
-  UnspecializedPcodeOp(Architecture *g,const string &nm,int4 ind)
+  UnspecializedPcodeOp(Architecture *g,const std::string &nm,int4 ind)
     : UserPcodeOp(g,nm,ind) {}		///< Constructor
   virtual void decode(Decoder &decoder) {}
 };
@@ -106,7 +106,7 @@ class UnspecializedPcodeOp : public UserPcodeOp {
 class InjectedUserOp : public UserPcodeOp {
   uint4 injectid;			///< The id of the injection object (to which this op maps)
 public:
-  InjectedUserOp(Architecture *g,const string &nm,int4 ind,int4 injid)
+  InjectedUserOp(Architecture *g,const std::string &nm,int4 ind,int4 injid)
     : UserPcodeOp(g,nm,ind) { injectid = injid; }	///< Constructor
   uint4 getInjectId(void) const { return injectid; }	///< Get the id of the injection object
   virtual void decode(Decoder &decoder);
@@ -121,9 +121,9 @@ class InjectedUserOp : public UserPcodeOp {
 /// memory and prevent accidental constant propagation.
 class VolatileOp : public UserPcodeOp {
 protected:
-  static string appendSize(const string &base,int4 size);	///< Append a suffix to a string encoding a specific size
+  static std::string appendSize(const std::string &base,int4 size);	///< Append a suffix to a string encoding a specific size
 public:
-  VolatileOp(Architecture *g,const string &nm,int4 ind)
+  VolatileOp(Architecture *g,const std::string &nm,int4 ind)
     : UserPcodeOp(g,nm,ind) { }					///< Constructor
   virtual void decode(Decoder &decoder) {}			///< Currently volatile ops only need their name
 };
@@ -135,9 +135,9 @@ class VolatileOp : public UserPcodeOp {
 /// is the actual value read from memory.
 class VolatileReadOp : public VolatileOp {
 public:
-  VolatileReadOp(Architecture *g,const string &nm,int4 ind,bool functional)
+  VolatileReadOp(Architecture *g,const std::string &nm,int4 ind,bool functional)
     : VolatileOp(g,nm,ind) { flags = functional ? 0 : no_operator; }			///< Constructor
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual int4 extractAnnotationSize(const Varnode *vn,const PcodeOp *op);
 };
 
@@ -149,9 +149,9 @@ class VolatileReadOp : public VolatileOp {
 ///   - The Varnode value being written to the memory
 class VolatileWriteOp : public VolatileOp {
 public:
-  VolatileWriteOp(Architecture *g,const string &nm,int4 ind,bool functional)
+  VolatileWriteOp(Architecture *g,const std::string &nm,int4 ind,bool functional)
     : VolatileOp(g,nm,ind) { flags = functional ? 0 : annotation_assignment; }		///< Constructor
-  virtual string getOperatorName(const PcodeOp *op) const;
+  virtual std::string getOperatorName(const PcodeOp *op) const;
   virtual int4 extractAnnotationSize(const Varnode *vn,const PcodeOp *op);
 };
 
@@ -167,7 +167,7 @@ class VolatileWriteOp : public VolatileOp {
 /// constant inputs (matching the format determined by unify()).
 class TermPatternOp : public UserPcodeOp {
 public:
-  TermPatternOp(Architecture *g,const string &nm,int4 ind) : UserPcodeOp(g,nm,ind) {}	///< Constructor
+  TermPatternOp(Architecture *g,const std::string &nm,int4 ind) : UserPcodeOp(g,nm,ind) {}	///< Constructor
   virtual int4 getNumVariableTerms(void) const=0;		///< Get the number of input Varnodes expected
 
   /// \brief Gather the formal input Varnode objects given the root PcodeOp
@@ -176,13 +176,13 @@ class TermPatternOp : public UserPcodeOp {
   /// \param op is the root operation
   /// \param bindlist will hold the ordered list of input Varnodes
   /// \return \b true if the requisite inputs were found
-  virtual bool unify(Funcdata &data,PcodeOp *op,vector<Varnode *> &bindlist) const=0;
+  virtual bool unify(Funcdata &data,PcodeOp *op,std::vector<Varnode *> &bindlist) const=0;
 
   /// \brief Compute the output value of \b this operation, given constant inputs
   ///
   /// \param input is the ordered list of constant inputs
   /// \return the resulting value as a constant
-  virtual uintb execute(const vector<uintb> &input) const=0;
+  virtual uintb execute(const std::vector<uintb> &input) const=0;
 };
 
 /// \brief The \e segmented \e address operator
@@ -215,15 +215,15 @@ class SegmentOp : public TermPatternOp {
   bool supportsfarpointer;	///< Is \b true if the joined pair base:near acts as a \b far pointer
   VarnodeData constresolve;	///< How to resolve constant near pointers
 public:
-  SegmentOp(Architecture *g,const string &nm,int4 ind);		///< Constructor
+  SegmentOp(Architecture *g,const std::string &nm,int4 ind);		///< Constructor
   AddrSpace *getSpace(void) const { return spc; }		///< Get the address space being pointed to
   bool hasFarPointerSupport(void) const { return supportsfarpointer; }	///< Return \b true, if \b this op supports far pointers
   int4 getBaseSize(void) const { return baseinsize; }		///< Get size in bytes of the base/segment value
   int4 getInnerSize(void) const { return innerinsize; }		///< Get size in bytes of the near value
   const VarnodeData &getResolve(void) const { return constresolve; }	///< Get the default register for resolving indirect segments
   virtual int4 getNumVariableTerms(void) const { if (baseinsize!=0) return 2; return 1; }
-  virtual bool unify(Funcdata &data,PcodeOp *op,vector<Varnode *> &bindlist) const;
-  virtual uintb execute(const vector<uintb> &input) const;
+  virtual bool unify(Funcdata &data,PcodeOp *op,std::vector<Varnode *> &bindlist) const;
+  virtual uintb execute(const std::vector<uintb> &input) const;
   virtual void decode(Decoder &decoder);
 };
 
@@ -259,9 +259,9 @@ class JumpAssistOp : public UserPcodeOp {
 /// may reassign a more specialized description object by parsing specific tags using
 /// on of \b this class's parse* methods.
 class UserOpManage {
-  vector<UserPcodeOp *> useroplist;	///< Description objects indexed by CALLOTHER constant id
-  map<string,UserPcodeOp *> useropmap;	///< A map from the name of the user defined operation to a description object
-  vector<SegmentOp *> segmentop;	///< Segment operations supported by this Architecture
+  std::vector<UserPcodeOp *> useroplist;	///< Description objects indexed by CALLOTHER constant id
+  std::map<std::string,UserPcodeOp *> useropmap;	///< A map from the name of the user defined operation to a description object
+  std::vector<SegmentOp *> segmentop;	///< Segment operations supported by this Architecture
   VolatileReadOp *vol_read;		///< (Single) volatile read operation
   VolatileWriteOp *vol_write;		///< (Single) volatile write operation
   void registerOp(UserPcodeOp *op);	///< Insert a new UserPcodeOp description object in the map(s)
@@ -280,7 +280,7 @@ class UserOpManage {
     return useroplist[i];
   }
 
-  UserPcodeOp *getOp(const string &nm) const;					///< Retrieve description by name
+  UserPcodeOp *getOp(const std::string &nm) const;					///< Retrieve description by name
 
   /// Retrieve a segment-op description object by index
   /// \param i is the index
@@ -296,8 +296,8 @@ class UserOpManage {
   void decodeVolatile(Decoder &decoder,Architecture *glb);			///< Parse a \<volatile> element
   void decodeCallOtherFixup(Decoder &decoder,Architecture *glb);		///< Parse a \<callotherfixup> element
   void decodeJumpAssist(Decoder &decoder,Architecture *glb);			///< Parse a \<jumpassist> element
-  void manualCallOtherFixup(const string &useropname,const string &outname,
-			    const vector<string> &inname,const string &snippet,Architecture *glb);
+  void manualCallOtherFixup(const std::string &useropname,const std::string &outname,
+			    const std::vector<std::string> &inname,const std::string &snippet,Architecture *glb);
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/variable.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/variable.cc
index ff5678c04..d8d010b27 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/variable.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/variable.cc
@@ -17,6 +17,8 @@
 #include "op.hh"
 #include "database.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_CLASS = AttributeId("class",66);
 AttributeId ATTRIB_REPREF = AttributeId("repref",67);
 AttributeId ATTRIB_SYMREF = AttributeId("symref",68);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/variable.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/variable.hh
index 25f6f8361..f26e0c6b6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/variable.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/variable.hh
@@ -62,7 +62,7 @@ class HighVariable {
 private:
   friend class Varnode;
   friend class Merge;
-  vector<Varnode *> inst;		///< The member Varnode objects making up \b this HighVariable
+  std::vector<Varnode *> inst;		///< The member Varnode objects making up \b this HighVariable
   int4 numMergeClasses;			///< Number of different speculative merge classes in \b this
   mutable uint4 highflags;		///< Dirtiness flags
   mutable uint4 flags;			///< Boolean properties inherited from Varnode members
@@ -102,9 +102,9 @@ class HighVariable {
   /// \brief Print details of the cover for \b this (for debug purposes)
   ///
   /// \param s is the output stream
-  void printCover(ostream &s) const { if ((highflags&HighVariable::coverdirty)==0) wholecover.print(s); else s << "Cover dirty"; }
+  void printCover(std::ostream &s) const { if ((highflags&HighVariable::coverdirty)==0) wholecover.print(s); else s << "Cover dirty"; }
 
-  void printInfo(ostream &s) const;		///< Print information about \b this HighVariable to stream
+  void printInfo(std::ostream &s) const;		///< Print information about \b this HighVariable to stream
   bool hasName(void) const;			///< Check if \b this HighVariable can be named
   Varnode *getTiedVarnode(void) const;		///< Find the first address tied member Varnode
   Varnode *getInputVarnode(void) const;		///< Find (the) input member Varnode
@@ -143,7 +143,7 @@ class HighVariable {
   //  Varnode *findGlobalRep(void) const;
   static bool compareName(Varnode *vn1,Varnode *vn2);	///< Determine which given Varnode is most nameable
   static bool compareJustLoc(const Varnode *a,const Varnode *b);	///< Compare based on storage location
-  static int4 markExpression(Varnode *vn,vector<HighVariable *> &highList);	///< Mark and collect variables in expression
+  static int4 markExpression(Varnode *vn,std::vector<HighVariable *> &highList);	///< Mark and collect variables in expression
 };
 
 #endif
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
index 76f4ed86f..9674c5dfe 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
@@ -16,6 +16,8 @@
 #include "varmap.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_LOCK = AttributeId("lock",133);
 AttributeId ATTRIB_MAIN = AttributeId("main",134);
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.hh
index 5267b0a3a..dba5351fa 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.hh
@@ -35,15 +35,15 @@ class NameRecommend {
   Address addr;			///< The starting address of the storage location
   Address useaddr;		///< The code address at the point of use
   int4 size;			///< An optional/recommended size for the variable being stored
-  string name;			///< The local symbol name recommendation
+  std::string name;			///< The local symbol name recommendation
   uint8 symbolId;		///< Id associated with the original Symbol
 public:
-  NameRecommend(const Address &ad,const Address &use,int4 sz,const string &nm,uint8 id) :
+  NameRecommend(const Address &ad,const Address &use,int4 sz,const std::string &nm,uint8 id) :
     addr(ad), useaddr(use), size(sz), name(nm), symbolId(id) {} ///< Constructor
   const Address &getAddr(void) const { return addr; }	///< Get the storage address
   const Address &getUseAddr(void) const { return useaddr; }	///< Get the use point address
   int4 getSize(void) const { return size; }			///< Get the optional size
-  string getName(void) const { return name; }			///< Get the recommended name
+  std::string getName(void) const { return name; }			///< Get the recommended name
   uint8 getSymbolId(void) const { return symbolId; }		///< Get the original Symbol id
 };
 
@@ -54,14 +54,14 @@ class NameRecommend {
 class DynamicRecommend {
   Address usePoint;		///< Use point of the Symbol
   uint8 hash;			///< Hash encoding the Symbols environment
-  string name;			///< The local symbol name recommendation
+  std::string name;			///< The local symbol name recommendation
   uint8 symbolId;		///< Id associated with the original Symbol
 public:
-  DynamicRecommend(const Address &addr,uint8 h,const string &nm,uint8 id) :
+  DynamicRecommend(const Address &addr,uint8 h,const std::string &nm,uint8 id) :
     usePoint(addr), hash(h), name(nm), symbolId(id) {}	///< Constructor
   const Address &getAddress(void) const { return usePoint; }	///< Get the use point address
   uint8 getHash(void) const { return hash; }			///< Get the dynamic hash
-  string getName(void) const { return name; }			///< Get the recommended name
+  std::string getName(void) const { return name; }			///< Get the recommended name
   uint8 getSymbolId(void) const { return symbolId; }		///< Get the original Symbol id
 };
 
@@ -135,8 +135,8 @@ class AliasChecker {
 private:
   const Funcdata *fd;		///< Function being searched for aliases
   AddrSpace *space;		///< AddressSpace in which to search
-  mutable vector<AddBase> addBase; ///< Collection of pointers into the AddressSpace
-  mutable vector<uintb> alias;	///< List of aliased addresses (as offsets)
+  mutable std::vector<AddBase> addBase; ///< Collection of pointers into the AddressSpace
+  mutable std::vector<uintb> alias;	///< List of aliased addresses (as offsets)
   mutable bool calculated;	///< Have aliases been calculated
   uintb localExtreme;		///< Largest possible offset for a local variable
   uintb localBoundary;		///< Boundary offset separating locals and parameters
@@ -149,9 +149,9 @@ class AliasChecker {
   void gather(const Funcdata *f,AddrSpace *spc,bool defer);		///< Gather Varnodes that point on the stack
   bool hasLocalAlias(Varnode *vn) const;	///< Return \b true if it looks like the given Varnode is aliased by a pointer
   void sortAlias(void) const;			///< Sort the alias starting offsets
-  const vector<AddBase> &getAddBase(void) const { return addBase; }	///< Get the collection of pointer Varnodes
-  const vector<uintb> &getAlias(void) const { return alias; }		///< Get the list of alias starting offsets
-  static void gatherAdditiveBase(Varnode *startvn,vector<AddBase> &addbase);
+  const std::vector<AddBase> &getAddBase(void) const { return addBase; }	///< Get the collection of pointer Varnodes
+  const std::vector<uintb> &getAlias(void) const { return alias; }		///< Get the list of alias starting offsets
+  static void gatherAdditiveBase(Varnode *startvn,std::vector<AddBase> &addbase);
   static uintb gatherOffset(Varnode *vn);
 };
 
@@ -164,8 +164,8 @@ class AliasChecker {
 class MapState {
   AddrSpace *spaceid;			///< The address space being analyzed
   RangeList range;			///< The subset of ranges, within the whole address space to analyze
-  vector<RangeHint *> maplist;		///< The list of collected RangeHints
-  vector<RangeHint *>::iterator iter;	///< The current iterator into the RangeHints
+  std::vector<RangeHint *> maplist;		///< The list of collected RangeHints
+  std::vector<RangeHint *>::iterator iter;	///< The current iterator into the RangeHints
   Datatype *defaultType;		///< The default data-type to use for RangeHints
   AliasChecker checker;			///< A collection of pointer Varnodes into our address space
   void addGuard(const LoadGuard &guard,OpCode opc,TypeFactory *typeFactory);	///< Add LoadGuard record as a hint to the collection
@@ -182,7 +182,7 @@ class MapState {
   ~MapState(void);		///< Destructor
   bool initialize(void);	///< Initialize the hint collection for iteration
   void sortAlias(void) { checker.sortAlias(); }		///< Sort the alias starting offsets
-  const vector<uintb> &getAlias(void) { return checker.getAlias(); }	///< Get the list of alias starting offsets
+  const std::vector<uintb> &getAlias(void) { return checker.getAlias(); }	///< Get the list of alias starting offsets
   void gatherSymbols(const EntryMap *rangemap);		///< Add Symbol information as hints to the collection
   void gatherVarnodes(const Funcdata &fd);		///< Add stack Varnodes as hints to the collection
   void gatherHighs(const Funcdata &fd);			///< Add HighVariables as hints to the collection
@@ -200,9 +200,9 @@ class MapState {
 /// portions are used for temporary storage (not mapped), and what portion is for parameters.
 class ScopeLocal : public ScopeInternal {
   AddrSpace *space;		///< Address space containing the local stack
-  list<NameRecommend> nameRecommend;	///< Symbol name recommendations for specific addresses
-  list<DynamicRecommend> dynRecommend;		///< Symbol name recommendations for dynamic locations
-  list<TypeRecommend> typeRecommend;	///< Data-types for specific storage locations
+  std::list<NameRecommend> nameRecommend;	///< Symbol name recommendations for specific addresses
+  std::list<DynamicRecommend> dynRecommend;		///< Symbol name recommendations for dynamic locations
+  std::list<TypeRecommend> typeRecommend;	///< Data-types for specific storage locations
   uintb minParamOffset;		///< Minimum offset of parameter passed (to a called function) on the stack
   uintb maxParamOffset;		///< Maximum offset of parameter passed (to a called function) on the stack
   bool stackGrowsNegative;	///< Marked \b true if the stack is considered to \e grow towards smaller offsets
@@ -210,7 +210,7 @@ class ScopeLocal : public ScopeInternal {
   bool adjustFit(RangeHint &a) const;	///< Make the given RangeHint fit in the current Symbol map
   void createEntry(const RangeHint &a);	///< Create a Symbol entry corresponding to the given (fitted) RangeHint
   bool restructure(MapState &state);	///< Merge hints into a formal Symbol layout of the address space
-  void markUnaliased(const vector<uintb> &alias);	///< Mark all local symbols for which there are no aliases
+  void markUnaliased(const std::vector<uintb> &alias);	///< Mark all local symbols for which there are no aliases
   void fakeInputSymbols(void);		///< Make sure all stack inputs have an associated Symbol
   void addRecommendName(Symbol *sym);	///< Convert the given symbol to a name recommendation
   void collectNameRecs(void);		///< Collect names of unlocked Symbols on the stack
@@ -235,7 +235,7 @@ class ScopeLocal : public ScopeInternal {
   virtual void encode(Encoder &encoder) const;
   virtual void decode(Decoder &decoder);
   virtual void decodeWrappingAttributes(Decoder &decoder);
-  virtual string buildVariableName(const Address &addr,
+  virtual std::string buildVariableName(const Address &addr,
 				   const Address &pc,
 				   Datatype *ct,
 				   int4 &index,uint4 flags) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
index 4675e9ee8..e7041884b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
@@ -16,6 +16,8 @@
 #include "varnode.hh"
 #include "funcdata.hh"
 
+using namespace std;
+
 AttributeId ATTRIB_ADDRTIED = AttributeId("addrtied",30);
 AttributeId ATTRIB_GRP = AttributeId("grp",31);
 AttributeId ATTRIB_INPUT = AttributeId("input",32);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
index c6f656478..d27b37f8c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
@@ -47,10 +47,10 @@ struct VarnodeCompareDefLoc {
 };
 
 /// A set of Varnodes sorted by location (then by definition)
-typedef set<Varnode *,VarnodeCompareLocDef> VarnodeLocSet;
+typedef std::set<Varnode *,VarnodeCompareLocDef> VarnodeLocSet;
 
 /// A set of Varnodes sorted by definition (then location)
-typedef set<Varnode *,VarnodeCompareDefLoc> VarnodeDefSet;
+typedef std::set<Varnode *,VarnodeCompareDefLoc> VarnodeDefSet;
 
 /// \brief A low-level variable or contiguous set of bytes described by an Address and a size
 ///
@@ -143,7 +143,7 @@ class Varnode {
   Datatype *type;		///< Datatype associated with this varnode
   VarnodeLocSet::iterator lociter;	///< Iterator into VarnodeBank sorted by location
   VarnodeDefSet::iterator defiter;	///< Iterator into VarnodeBank sorted by definition
-  list<PcodeOp *> descend;		///< List of every op using this varnode as input
+  std::list<PcodeOp *> descend;		///< List of every op using this varnode as input
   mutable Cover *cover;		///< Addresses covered by the def->use of this Varnode
   mutable union {
     Datatype *dataType;		///< Temporary data-type associated with \b this for use in type propagate algorithm
@@ -195,8 +195,8 @@ class Varnode {
   ValueSet *getValueSet(void) const { return temp.valueSet; }	///< Get the temporary ValueSet record
   uint4 getCreateIndex(void) const { return create_index; } ///< Get the creation index
   Cover *getCover(void) const { updateCover(); return cover; } ///< Get Varnode coverage information
-  list<PcodeOp *>::const_iterator beginDescend(void) const { return descend.begin(); } ///< Get iterator to list of syntax tree descendants (reads)
-  list<PcodeOp *>::const_iterator endDescend(void) const { return descend.end(); } ///< Get the end iterator to list of descendants
+  std::list<PcodeOp *>::const_iterator beginDescend(void) const { return descend.begin(); } ///< Get iterator to list of syntax tree descendants (reads)
+  std::list<PcodeOp *>::const_iterator endDescend(void) const { return descend.end(); } ///< Get the end iterator to list of descendants
   uintb getConsume(void) const { return consumed; } ///< Get mask of consumed bits
   void setConsume(uintb val) { consumed = val; } ///< Set the mask of consumed bits (used by dead-code algorithm)
   bool isConsumeList(void) const { return ((addlflags&Varnode::lisconsume)!=0); } ///< Get marker used by dead-code algorithm
@@ -207,10 +207,10 @@ class Varnode {
   void clearConsumeVacuous(void) { addlflags &= ~Varnode::vacconsume; } ///< Clear marker used by dead-code algorithm
   PcodeOp *loneDescend(void) const; ///< Return unique reading PcodeOp, or \b null if there are zero or more than 1
   Address getUsePoint(const Funcdata &fd) const; ///< Get Address when this Varnode first comes into scope
-  int4 printRawNoMarkup(ostream &s) const; ///< Print a simple identifier for the Varnode
-  void printRaw(ostream &s) const; ///< Print a simple identifier plus additional info identifying Varnode with SSA form
-  void printCover(ostream &s) const; ///< Print raw coverage info about the Varnode
-  void printInfo(ostream &s) const; ///< Print raw attribute info about the Varnode
+  int4 printRawNoMarkup(std::ostream &s) const; ///< Print a simple identifier for the Varnode
+  void printRaw(std::ostream &s) const; ///< Print a simple identifier plus additional info identifying Varnode with SSA form
+  void printCover(std::ostream &s) const; ///< Print raw coverage info about the Varnode
+  void printInfo(std::ostream &s) const; ///< Print raw attribute info about the Varnode
   Varnode(int4 s,const Address &m,Datatype *dt);	///< Construct a \e free Varnode
   bool operator<(const Varnode &op2) const; ///< Comparison operator on Varnode
   bool operator==(const Varnode &op2) const; ///< Equality operator
@@ -224,7 +224,7 @@ class Varnode {
   int4 overlap(const Address &op2loc,int4 op2size) const;	///< Return relative point of overlap with Address range
   uintb getNZMask(void) const { return nzm; } ///< Get the mask of bits within \b this that are known to be zero
   int4 termOrder(const Varnode *op) const; ///< Compare two Varnodes based on their term order
-  void printRawHeritage(ostream &s,int4 depth) const; ///< Print a simple SSA subtree rooted at \b this
+  void printRawHeritage(std::ostream &s,int4 depth) const; ///< Print a simple SSA subtree rooted at \b this
   bool isAnnotation(void) const { return ((flags&Varnode::annotation)!=0); } ///< Is \b this an annotation?
   bool isImplied(void) const { return ((flags&Varnode::implied)!=0); } ///< Is \b this an implied variable?
   bool isExplicit(void) const { return ((flags&Varnode::explict)!=0); }	///< Is \b this an explicitly printed variable?
@@ -332,7 +332,7 @@ class Varnode {
   bool copyShadow(const Varnode *op2) const; ///< Are \b this and \b op2 copied from the same source?
   void encode(Encoder &encoder) const; ///< Encode a description of \b this to a stream
   static bool comparePointers(const Varnode *a,const Varnode *b) { return (*a < *b); }	///< Compare Varnodes as pointers
-  static void printRaw(ostream &s,const Varnode *vn);	///< Print raw info about a Varnode to stream
+  static void printRaw(std::ostream &s,const Varnode *vn);	///< Print raw info about a Varnode to stream
 };
 
 /// \brief A container for Varnode objects from a specific function
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
index fc4d1bf61..68778c5ca 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
@@ -98,6 +98,8 @@
 #include <iostream>
 #include <string>
 
+using namespace std;
+
 string Attributes::bogus_uri("http://unused.uri");
 
 /// \brief The XML character scanner
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.hh
index a1c763a3e..802f57988 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.hh
@@ -25,8 +25,6 @@
 #include <vector>
 #include <map>
 
-using namespace std;
-
 /// \brief The \e attributes for a single XML element
 ///
 /// A container for name/value pairs (of strings) for the formal attributes, as collected during parsing.
@@ -34,34 +32,34 @@ using namespace std;
 /// This also holds other properties of the element that are unused in this implementation,
 /// including the \e namespace URI.
 class Attributes {
-  static string bogus_uri;		///< A placeholder for the namespace URI that should be attached to the element
-//  static string prefix;
-  string *elementname;			///< The name of the XML element
-  vector<string *> name;		///< List of names for each formal XML attribute
-  vector<string *> value;		///< List of values for each formal XML attribute
+  static std::string bogus_uri;		///< A placeholder for the namespace URI that should be attached to the element
+//  static std::string prefix;
+  std::string *elementname;			///< The name of the XML element
+  std::vector<std::string *> name;		///< List of names for each formal XML attribute
+  std::vector<std::string *> value;		///< List of values for each formal XML attribute
 public:
-  Attributes(string *el) { elementname = el; }	///< Construct from element name string
+  Attributes(std::string *el) { elementname = el; }	///< Construct from element name string
   ~Attributes(void) { 
     for(uint4 i=0;i<name.size();++i) { delete name[i]; delete value[i]; }
     delete elementname;
   }	///< Destructor
-  const string &getelemURI(void) const { return bogus_uri; }	///< Get the namespace URI associated with this element
-  const string &getelemName(void) const { return *elementname; }	///< Get the name of this element
-  void add_attribute(string *nm,string *vl) { name.push_back(nm); value.push_back(vl); }	///< Add a formal attribute
+  const std::string &getelemURI(void) const { return bogus_uri; }	///< Get the namespace URI associated with this element
+  const std::string &getelemName(void) const { return *elementname; }	///< Get the name of this element
+  void add_attribute(std::string *nm,std::string *vl) { name.push_back(nm); value.push_back(vl); }	///< Add a formal attribute
 				// The official SAX interface
   int4 getLength(void) const { return name.size(); }		///< Get the number of attributes associated with the element
-  const string &getURI(int4 i) const { return bogus_uri; }	///< Get the namespace URI associated with the i-th attribute
-  const string &getLocalName(int4 i) const { return *name[i]; }	///< Get the local name of the i-th attribute
-  const string &getQName(int4 i) const { return *name[i]; }	///< Get the qualified name of the i-th attribute
-  //  int4 getIndex(const string &uri,const string &localName) const;
-  //  int4 getIndex(const string &qualifiedName) const;
-  //  const string &getType(int4 index) const;
-  //  const string &getType(const string &uri,const string &localName) const;
-  //  const string &getType(const string &qualifiedName) const;
-  const string &getValue(int4 i) const { return *value[i]; }	///< Get the value of the i-th attribute
-  //const string &getValue(const string &uri,const string &localName) const;
+  const std::string &getURI(int4 i) const { return bogus_uri; }	///< Get the namespace URI associated with the i-th attribute
+  const std::string &getLocalName(int4 i) const { return *name[i]; }	///< Get the local name of the i-th attribute
+  const std::string &getQName(int4 i) const { return *name[i]; }	///< Get the qualified name of the i-th attribute
+  //  int4 getIndex(const std::string &uri,const std::string &localName) const;
+  //  int4 getIndex(const std::string &qualifiedName) const;
+  //  const std::string &getType(int4 index) const;
+  //  const std::string &getType(const std::string &uri,const std::string &localName) const;
+  //  const std::string &getType(const std::string &qualifiedName) const;
+  const std::string &getValue(int4 i) const { return *value[i]; }	///< Get the value of the i-th attribute
+  //const std::string &getValue(const std::string &uri,const std::string &localName) const;
   /// \brief Get the value of the attribute with the given qualified name
-  const string &getValue(const string &qualifiedName) const {
+  const std::string &getValue(const std::string &qualifiedName) const {
     for(uint4 i=0;i<name.size();++i)
       if (*name[i] == qualifiedName) return *value[i];
     return bogus_uri;
@@ -80,8 +78,8 @@ class ContentHandler {
   virtual void setDocumentLocator(Locator locator)=0;	///< Set the Locator object for documents
   virtual void startDocument(void)=0;			///< Start processing a new XML document
   virtual void endDocument(void)=0;			///< End processing for the current XML document
-  virtual void startPrefixMapping(const string &prefix,const string &uri)=0;	///< Start a new prefix to namespace URI mapping
-  virtual void endPrefixMapping(const string &prefix)=0;			///< Finish the current prefix
+  virtual void startPrefixMapping(const std::string &prefix,const std::string &uri)=0;	///< Start a new prefix to namespace URI mapping
+  virtual void endPrefixMapping(const std::string &prefix)=0;			///< Finish the current prefix
 
   /// \brief Callback indicating a new XML element has started.
   ///
@@ -89,16 +87,16 @@ class ContentHandler {
   /// \param localName is the local name of the new element
   /// \param qualifiedName is the fully qualified name of the new element
   /// \param atts is the set of (previously parsed) attributes to attach to the new element
-  virtual void startElement(const string &namespaceURI,const string &localName,
-			    const string &qualifiedName,const Attributes &atts)=0;
+  virtual void startElement(const std::string &namespaceURI,const std::string &localName,
+			    const std::string &qualifiedName,const Attributes &atts)=0;
 
   /// \brief Callback indicating parsing of the current XML element is finished.
   ///
   /// \param namespaceURI is the namespace to which the element belongs
   /// \param localName is the local name of the new element
   /// \param qualifiedName is the fully qualified name of the element.
-  virtual void endElement(const string &namespaceURI,const string &localName,
-			  const string &qualifiedName)=0;
+  virtual void endElement(const std::string &namespaceURI,const std::string &localName,
+			  const std::string &qualifiedName)=0;
 
   /// \brief Callback with raw characters to be inserted in the current XML element
   ///
@@ -117,48 +115,48 @@ class ContentHandler {
   /// \brief Set the XML version as specified by the current document
   ///
   /// \param version is the parsed version string
-  virtual void setVersion(const string &version)=0;
+  virtual void setVersion(const std::string &version)=0;
 
   /// \brief Set the character encoding as specified by the current document
   ///
   /// \param encoding is the parsed encoding string
-  virtual void setEncoding(const string &encoding)=0;
+  virtual void setEncoding(const std::string &encoding)=0;
 
   /// \brief Callback for a formal \e processing \e instruction seen in the current document
   ///
   /// \param target is the target instruction to process
   /// \param data is (optional) character data for the instruction
-  virtual void processingInstruction(const string &target,const string &data)=0;
+  virtual void processingInstruction(const std::string &target,const std::string &data)=0;
 
   /// \brief Callback for an XML entity skipped by the parser
   ///
   /// \param name is the name of the entity being skipped
-  virtual void skippedEntity(const string &name)=0;
+  virtual void skippedEntity(const std::string &name)=0;
 
   /// \brief Callback for handling an error condition during XML parsing
   ///
   /// \param errmsg is a message describing the error condition
-  virtual void setError(const string &errmsg)=0;
+  virtual void setError(const std::string &errmsg)=0;
 };
 
 class Element;
-typedef vector<Element *> List;		///< A list of XML elements
+typedef std::vector<Element *> List;		///< A list of XML elements
 
 /// \brief An XML element.  A node in the DOM tree.
 ///
 /// This is the main node for the in-memory representation of the XML (DOM) tree.
 class Element {
-  string name;			///< The (local) name of the element
-  string content;		///< Character content of the element
-  vector<string> attr;		///< A list of attribute names for \b this element
-  vector<string> value;		///< a (corresponding) list of attribute values for \b this element
+  std::string name;			///< The (local) name of the element
+  std::string content;		///< Character content of the element
+  std::vector<std::string> attr;		///< A list of attribute names for \b this element
+  std::vector<std::string> value;		///< a (corresponding) list of attribute values for \b this element
 protected:
   Element *parent;		///< The parent Element (or null)
   List children;		///< A list of child Element objects
 public:
   Element(Element *par) { parent = par; }	///< Constructor given a parent Element
   ~Element(void);				///< Destructor
-  void setName(const string &nm) { name = nm; }	///< Set the local name of the element
+  void setName(const std::string &nm) { name = nm; }	///< Set the local name of the element
 
   /// \brief Append new character content to \b this element
   ///
@@ -178,13 +176,13 @@ class Element {
   ///
   /// \param nm is the name of the attribute
   /// \param vl is the value of the attribute
-  void addAttribute(const string &nm,const string &vl) {
+  void addAttribute(const std::string &nm,const std::string &vl) {
     attr.push_back(nm); value.push_back(vl); }
 
   Element *getParent(void) const { return parent; }		///< Get the parent Element
-  const string &getName(void) const { return name; }		///< Get the local name of \b this element
+  const std::string &getName(void) const { return name; }		///< Get the local name of \b this element
   const List &getChildren(void) const { return children; }	///< Get the list of child elements
-  const string &getContent(void) const { return content; }	///< Get the character content of \b this element
+  const std::string &getContent(void) const { return content; }	///< Get the character content of \b this element
 
   /// \brief Get an attribute value by name
   ///
@@ -192,11 +190,11 @@ class Element {
   /// thrown if the attribute does not exist.
   /// \param nm is the name of the attribute
   /// \return the corresponding attribute value
-  const string &getAttributeValue(const string &nm) const;
+  const std::string &getAttributeValue(const std::string &nm) const;
 
   int4 getNumAttributes(void) const { return attr.size(); }	///< Get the number of attributes for \b this element
-  const string &getAttributeName(int4 i) const { return attr[i]; }	///< Get the name of the i-th attribute
-  const string &getAttributeValue(int4 i) const { return value[i]; }	///< Get the value of the i-th attribute
+  const std::string &getAttributeName(int4 i) const { return attr[i]; }	///< Get the name of the i-th attribute
+  const std::string &getAttributeValue(int4 i) const { return value[i]; }	///< Get the value of the i-th attribute
 };
 
 /// \brief A complete in-memory XML document.
@@ -217,27 +215,27 @@ class Document : public Element {
 class TreeHandler : public ContentHandler {
   Element *root;		///< The root XML element being processed by \b this handler
   Element *cur;			///< The \e current XML element being processed by \b this handler
-  string error;			///< The last error condition returned by the parser (if not empty)
+  std::string error;			///< The last error condition returned by the parser (if not empty)
 public:
   TreeHandler(Element *rt) { root = rt; cur = root; }	///< Constructor given root Element
   virtual ~TreeHandler(void) {}
   virtual void setDocumentLocator(Locator locator) {}
   virtual void startDocument(void) {}
   virtual void endDocument(void) {}
-  virtual void startPrefixMapping(const string &prefix,const string &uri) {}
-  virtual void endPrefixMapping(const string &prefix) {}
-  virtual void startElement(const string &namespaceURI,const string &localName,
-			    const string &qualifiedName,const Attributes &atts);
-  virtual void endElement(const string &namespaceURI,const string &localName,
-			  const string &qualifiedName);
+  virtual void startPrefixMapping(const std::string &prefix,const std::string &uri) {}
+  virtual void endPrefixMapping(const std::string &prefix) {}
+  virtual void startElement(const std::string &namespaceURI,const std::string &localName,
+			    const std::string &qualifiedName,const Attributes &atts);
+  virtual void endElement(const std::string &namespaceURI,const std::string &localName,
+			  const std::string &qualifiedName);
   virtual void characters(const char *text,int4 start,int4 length);
   virtual void ignorableWhitespace(const char *text,int4 start,int4 length) {}
-  virtual void processingInstruction(const string &target,const string &data) {}
-  virtual void setVersion(const string &val) {}
-  virtual void setEncoding(const string &val) {}
-  virtual void skippedEntity(const string &name) {}
-  virtual void setError(const string &errmsg) { error = errmsg; }
-  const string &getError(void) const { return error; }	///< Get the current error message
+  virtual void processingInstruction(const std::string &target,const std::string &data) {}
+  virtual void setVersion(const std::string &val) {}
+  virtual void setEncoding(const std::string &val) {}
+  virtual void skippedEntity(const std::string &name) {}
+  virtual void setError(const std::string &errmsg) { error = errmsg; }
+  const std::string &getError(void) const { return error; }	///< Get the current error message
 };
 
 /// \brief A container for parsed XML documents
@@ -247,8 +245,8 @@ class TreeHandler : public ContentHandler {
 /// or a filename via openDocument().  If they are explicitly registered, specific
 /// XML Elements can be looked up by name via getTag().
 class DocumentStorage {
-  vector<Document *> doclist;		///< The list of documents held by this container
-  map<string,const Element *> tagmap;	///< The map from name to registered XML elements
+  std::vector<Document *> doclist;		///< The list of documents held by this container
+  std::map<std::string,const Element *> tagmap;	///< The map from name to registered XML elements
 public:
   ~DocumentStorage(void);		///< Destructor
 
@@ -258,7 +256,7 @@ class DocumentStorage {
   /// An XmlException is thrown for any parsing error.
   /// \param s is the given stream to parse
   /// \return the in-memory DOM tree
-  Document *parseDocument(istream &s);
+  Document *parseDocument(std::istream &s);
 
   /// \brief Open and parse an XML file
   ///
@@ -266,7 +264,7 @@ class DocumentStorage {
   /// its contents into an in-memory DOM tree. An XmlException is thrown for any parsing error.
   /// \param filename is the name of the XML document file
   /// \return the in-memory DOM tree
-  Document *openDocument(const string &filename);
+  Document *openDocument(const std::string &filename);
 
   /// \brief Register the given XML Element object under its tag name
   ///
@@ -278,7 +276,7 @@ class DocumentStorage {
   ///
   /// \param nm is the XML tag name
   /// \return the matching registered Element or null
-  const Element *getTag(const string &nm) const;
+  const Element *getTag(const std::string &nm) const;
 };
 
 /// \brief An exception thrown by the XML parser
@@ -286,8 +284,8 @@ class DocumentStorage {
 /// This object holds the error message as passed to the SAX interface callback
 /// and is thrown as a formal exception.
 struct DecoderError {
-  string explain;		///< Explanatory string
-  DecoderError(const string &s) { explain = s; }	///< Constructor
+  std::string explain;		///< Explanatory string
+  DecoderError(const std::string &s) { explain = s; }	///< Constructor
 };
 
 /// \brief Start-up the XML parser given a stream and a handler
@@ -297,7 +295,7 @@ struct DecoderError {
 /// \param hand is the ContentHandler that stores or processes the XML content events
 /// \param dbg is non-zero if the parser should output debug information during its parse
 /// \return 0 if there is no error during parsing or a (non-zero) error condition
-extern int4 xml_parse(istream &i,ContentHandler *hand,int4 dbg=0);
+extern int4 xml_parse(std::istream &i,ContentHandler *hand,int4 dbg=0);
 
 /// \brief Parse the given XML stream into an in-memory document
 ///
@@ -305,7 +303,7 @@ extern int4 xml_parse(istream &i,ContentHandler *hand,int4 dbg=0);
 /// DOM representation of the XML document.
 /// \param i is the given stream
 /// \return the in-memory XML document
-extern Document *xml_tree(istream &i);
+extern Document *xml_tree(std::istream &i);
 
 /// \brief Send the given character array to a stream, escaping characters with special XML meaning
 ///
@@ -318,7 +316,7 @@ extern Document *xml_tree(istream &i);
 ///
 /// \param s is the stream to write to
 /// \param str is the given character array to escape
-extern void xml_escape(ostream &s,const char *str);
+extern void xml_escape(std::ostream &s,const char *str);
 
 // Some helper functions for writing XML documents directly to a stream
 
@@ -327,7 +325,7 @@ extern void xml_escape(ostream &s,const char *str);
 /// \param s is the output stream
 /// \param attr is the name of the attribute
 /// \param val is the attribute value
-inline void a_v(ostream &s,const string &attr,const string &val)
+inline void a_v(std::ostream &s,const std::string &attr,const std::string &val)
 
 {
   s << ' ' << attr << "=\"";
@@ -340,10 +338,10 @@ inline void a_v(ostream &s,const string &attr,const string &val)
 /// \param s is the output stream
 /// \param attr is the name of the attribute
 /// \param val is the given integer value
-inline void a_v_i(ostream &s,const string &attr,intb val)
+inline void a_v_i(std::ostream &s,const std::string &attr,intb val)
 
 {
-  s << ' ' << attr << "=\"" << dec << val << "\"";
+  s << ' ' << attr << "=\"" << std::dec << val << "\"";
 }
 
 /// \brief Output the given unsigned integer as an XML attribute value
@@ -351,10 +349,10 @@ inline void a_v_i(ostream &s,const string &attr,intb val)
 /// \param s is the output stream
 /// \param attr is the name of the attribute
 /// \param val is the given unsigned integer value
-inline void a_v_u(ostream &s,const string &attr,uintb val)
+inline void a_v_u(std::ostream &s,const std::string &attr,uintb val)
 
 {
-  s << ' ' << attr << "=\"0x" << hex << val << "\"";
+  s << ' ' << attr << "=\"0x" << std::hex << val << "\"";
 }
 
 /// \brief Output the given boolean value as an XML attribute
@@ -362,7 +360,7 @@ inline void a_v_u(ostream &s,const string &attr,uintb val)
 /// \param s is the output stream
 /// \param attr is the name of the attribute
 /// \param val is the given boolean value
-inline void a_v_b(ostream &s,const string &attr,bool val)
+inline void a_v_b(std::ostream &s,const std::string &attr,bool val)
 
 {
   s << ' ' << attr << "=\"";
@@ -379,7 +377,7 @@ inline void a_v_b(ostream &s,const string &attr,bool val)
 /// as a \b true value.  Anything else is returned as \b false.
 /// \param attr is the given XML attribute value (as a string)
 /// \return either \b true or \b false
-inline bool xml_readbool(const string &attr)
+inline bool xml_readbool(const std::string &attr)
 
 {
   if (attr.size()==0) return false;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
index 8f5386237..5d5f702cc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.y
@@ -25,6 +25,8 @@
 #include <iostream>
 #include <string>
 
+using namespace std;
+
 string Attributes::bogus_uri("http://unused.uri");
 
 /// \brief The XML character scanner
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
index c5c533ba9..21e6e390a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
@@ -15,6 +15,8 @@
  */
 #include "xml_arch.hh"
 
+using namespace std;
+
 ElementId ELEM_XML_SAVEFILE = ElementId("xml_savefile",236);
 
 // Constructing the singleton registers the capability
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.hh
index 6371148b0..e9598b9d5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.hh
@@ -32,8 +32,8 @@ class XmlArchitectureCapability : public ArchitectureCapability {
   XmlArchitectureCapability &operator=(const XmlArchitectureCapability &op2);	///< Not implemented
 public:
   virtual ~XmlArchitectureCapability(void);
-  virtual Architecture *buildArchitecture(const string &filename,const string &target,ostream *estream);
-  virtual bool isFileMatch(const string &filename) const;
+  virtual Architecture *buildArchitecture(const std::string &filename,const std::string &target,std::ostream *estream);
+  virtual bool isFileMatch(const std::string &filename) const;
   virtual bool isXmlMatch(Document *doc) const;
 };
 
@@ -46,7 +46,7 @@ class XmlArchitecture : public SleighArchitecture {
 public:
   virtual void encode(Encoder &encoder) const;
   virtual void restoreXml(DocumentStorage &store);
-  XmlArchitecture(const string &fname,const string &targ,ostream *estream);	///< Constructor
+  XmlArchitecture(const std::string &fname,const std::string &targ,std::ostream *estream);	///< Constructor
   virtual ~XmlArchitecture(void) {}
 };
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/unittests/testcirclerange.cc b/Ghidra/Features/Decompiler/src/decompile/unittests/testcirclerange.cc
index a8bf58ec5..6dcfc7930 100644
--- a/Ghidra/Features/Decompiler/src/decompile/unittests/testcirclerange.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/unittests/testcirclerange.cc
@@ -16,6 +16,8 @@
 #include "architecture.hh"
 #include "test.hh"
 
+using namespace std;
+
 class CircleRangeTestEnvironment {
   Architecture *g;
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc b/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
index 67d92c573..9cb08b3d1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/unittests/testfloatemu.cc
@@ -27,6 +27,8 @@
 #include <limits>
 #include <vector>
 
+using namespace std;
+
 // utility functions
 float floatFromRawBits(uintb e) {
     float f;
diff --git a/Ghidra/Features/Decompiler/src/decompile/unittests/testmarshal.cc b/Ghidra/Features/Decompiler/src/decompile/unittests/testmarshal.cc
index b941fede3..a09332af8 100644
--- a/Ghidra/Features/Decompiler/src/decompile/unittests/testmarshal.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/unittests/testmarshal.cc
@@ -16,6 +16,8 @@
 #include "translate.hh"
 #include "test.hh"
 
+using namespace std;
+
 class TestAddrSpaceManager : public AddrSpaceManager {
 public:
   TestAddrSpaceManager(Translate *t);
diff --git a/Ghidra/Features/Decompiler/src/decompile/unittests/testtypes.cc b/Ghidra/Features/Decompiler/src/decompile/unittests/testtypes.cc
index 4ce7cdde6..1ac3c3d5f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/unittests/testtypes.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/unittests/testtypes.cc
@@ -18,6 +18,8 @@
 #include "test.hh"
 #include <iostream>
 
+using namespace std;
+
 static Architecture *glb;
 static TypeFactory *types;
 static CastStrategy *strategy;
-- 
2.38.1

